{"version":3,"file":"..\\www\\javascripts\\vendor.js","sources":["vendor/scripts/jquery-1.9.1.js","vendor/scripts/underscore-1.4.4.js","vendor/scripts/backbone-1.0.0.js","C:/Users/Romain/Projects/cozy-files-mobile/www-src/node_modules/auto-reload-brunch/vendor/auto-reload.js","C:/Users/Romain/Projects/cozy-files-mobile/www-src/node_modules/jade-brunch/vendor/runtime.js","vendor/scripts/async.js","vendor/scripts/ionic.js","vendor/scripts/polyglot.js","vendor/scripts/pouchdb-2.1.0.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC73SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC3sCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCniDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC97BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCzxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC7PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A","sourcesContent":["/*!\n * jQuery JavaScript Library v1.9.1\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2012 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-2-4\n */\n(function( window, undefined ) {\n\n// Can't do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n//\"use strict\";\nvar\n\t// The deferred used on DOM ready\n\treadyList,\n\n\t// A central reference to the root jQuery(document)\n\trootjQuery,\n\n\t// Support: IE<9\n\t// For `typeof node.method` instead of `node.method !== undefined`\n\tcore_strundefined = typeof undefined,\n\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\tlocation = window.location,\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$,\n\n\t// [[Class]] -> type pairs\n\tclass2type = {},\n\n\t// List of deleted data cache ids, so we can reuse them\n\tcore_deletedIds = [],\n\n\tcore_version = \"1.9.1\",\n\n\t// Save a reference to some core methods\n\tcore_concat = core_deletedIds.concat,\n\tcore_push = core_deletedIds.push,\n\tcore_slice = core_deletedIds.slice,\n\tcore_indexOf = core_deletedIds.indexOf,\n\tcore_toString = class2type.toString,\n\tcore_hasOwn = class2type.hasOwnProperty,\n\tcore_trim = core_version.trim,\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\treturn new jQuery.fn.init( selector, context, rootjQuery );\n\t},\n\n\t// Used for matching numbers\n\tcore_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n\n\t// Used for splitting on whitespace\n\tcore_rnotwhite = /\\S+/g,\n\n\t// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\t// Match a standalone tag\n\trsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n\n\t// JSON RegExp\n\trvalidchars = /^[\\],:{}\\s]*$/,\n\trvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n\trvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,\n\trvalidtokens = /\"[^\"\\\\\\r\\n]*\"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t},\n\n\t// The ready event handler\n\tcompleted = function( event ) {\n\n\t\t// readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n\t\tif ( document.addEventListener || event.type === \"load\" || document.readyState === \"complete\" ) {\n\t\t\tdetach();\n\t\t\tjQuery.ready();\n\t\t}\n\t},\n\t// Clean-up method for dom ready events\n\tdetach = function() {\n\t\tif ( document.addEventListener ) {\n\t\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\t\t\twindow.removeEventListener( \"load\", completed, false );\n\n\t\t} else {\n\t\t\tdocument.detachEvent( \"onreadystatechange\", completed );\n\t\t\twindow.detachEvent( \"onload\", completed );\n\t\t}\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: core_version,\n\n\tconstructor: jQuery,\n\tinit: function( selector, context, rootjQuery ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id !== match[2] ) {\n\t\t\t\t\t\t\treturn rootjQuery.find( selector );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn rootjQuery.ready( selector );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t},\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\t// The number of elements contained in the matched element set\n\tsize: function() {\n\t\treturn this.length;\n\t},\n\n\ttoArray: function() {\n\t\treturn core_slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num == null ?\n\n\t\t\t// Return a 'clean' array\n\t\t\tthis.toArray() :\n\n\t\t\t// Return just the object\n\t\t\t( num < 0 ? this[ this.length + num ] : this[ num ] );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tready: function( fn ) {\n\t\t// Add the callback\n\t\tjQuery.ready.promise().done( fn );\n\n\t\treturn this;\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( core_slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: core_push,\n\tsort: [].sort,\n\tsplice: [].splice\n};\n\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar src, copyIsArray, copy, name, options, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length === i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\tnoConflict: function( deep ) {\n\t\tif ( window.$ === jQuery ) {\n\t\t\twindow.$ = _$;\n\t\t}\n\n\t\tif ( deep && window.jQuery === jQuery ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t},\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\t\tif ( !document.body ) {\n\t\t\treturn setTimeout( jQuery.ready );\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.trigger ) {\n\t\t\tjQuery( document ).trigger(\"ready\").off(\"ready\");\n\t\t}\n\t},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray || function( obj ) {\n\t\treturn jQuery.type(obj) === \"array\";\n\t},\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj == obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\treturn !isNaN( parseFloat(obj) ) && isFinite( obj );\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn String( obj );\n\t\t}\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ core_toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Must be an Object.\n\t\t// Because of IE, we also have to check the presence of the constructor property.\n\t\t// Make sure that DOM nodes and window objects don't pass through, as well\n\t\tif ( !obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\t// Not own constructor property must be Object\n\t\t\tif ( obj.constructor &&\n\t\t\t\t!core_hasOwn.call(obj, \"constructor\") &&\n\t\t\t\t!core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\t// IE8,9 Will throw exceptions on certain host objects #9897\n\t\t\treturn false;\n\t\t}\n\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\n\t\tvar key;\n\t\tfor ( key in obj ) {}\n\n\t\treturn key === undefined || core_hasOwn.call( obj, key );\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\t// data: string of html\n\t// context (optional): If specified, the fragment will be created in this context, defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tparseHTML: function( data, context, keepScripts ) {\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( typeof context === \"boolean\" ) {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\tcontext = context || document;\n\n\t\tvar parsed = rsingleTag.exec( data ),\n\t\t\tscripts = !keepScripts && [];\n\n\t\t// Single tag\n\t\tif ( parsed ) {\n\t\t\treturn [ context.createElement( parsed[1] ) ];\n\t\t}\n\n\t\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\t\tif ( scripts ) {\n\t\t\tjQuery( scripts ).remove();\n\t\t}\n\t\treturn jQuery.merge( [], parsed.childNodes );\n\t},\n\n\tparseJSON: function( data ) {\n\t\t// Attempt to parse using the native JSON parser first\n\t\tif ( window.JSON && window.JSON.parse ) {\n\t\t\treturn window.JSON.parse( data );\n\t\t}\n\n\t\tif ( data === null ) {\n\t\t\treturn data;\n\t\t}\n\n\t\tif ( typeof data === \"string\" ) {\n\n\t\t\t// Make sure leading/trailing whitespace is removed (IE can't handle it)\n\t\t\tdata = jQuery.trim( data );\n\n\t\t\tif ( data ) {\n\t\t\t\t// Make sure the incoming data is actual JSON\n\t\t\t\t// Logic borrowed from http://json.org/json2.js\n\t\t\t\tif ( rvalidchars.test( data.replace( rvalidescape, \"@\" )\n\t\t\t\t\t.replace( rvalidtokens, \"]\" )\n\t\t\t\t\t.replace( rvalidbraces, \"\")) ) {\n\n\t\t\t\t\treturn ( new Function( \"return \" + data ) )();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tjQuery.error( \"Invalid JSON: \" + data );\n\t},\n\n\t// Cross-browser xml parsing\n\tparseXML: function( data ) {\n\t\tvar xml, tmp;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tif ( window.DOMParser ) { // Standard\n\t\t\t\ttmp = new DOMParser();\n\t\t\t\txml = tmp.parseFromString( data , \"text/xml\" );\n\t\t\t} else { // IE\n\t\t\t\txml = new ActiveXObject( \"Microsoft.XMLDOM\" );\n\t\t\t\txml.async = \"false\";\n\t\t\t\txml.loadXML( data );\n\t\t\t}\n\t\t} catch( e ) {\n\t\t\txml = undefined;\n\t\t}\n\t\tif ( !xml || !xml.documentElement || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\t\treturn xml;\n\t},\n\n\tnoop: function() {},\n\n\t// Evaluates a script in a global context\n\t// Workarounds based on findings by Jim Driscoll\n\t// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n\tglobalEval: function( data ) {\n\t\tif ( data && jQuery.trim( data ) ) {\n\t\t\t// We use execScript on Internet Explorer\n\t\t\t// We use an anonymous function so that context is window\n\t\t\t// rather than jQuery in Firefox\n\t\t\t( window.execScript || function( data ) {\n\t\t\t\twindow[ \"eval\" ].call( window, data );\n\t\t\t} )( data );\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Use native String.trim function wherever possible\n\ttrim: core_trim && !core_trim.call(\"\\uFEFF\\xA0\") ?\n\t\tfunction( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\tcore_trim.call( text );\n\t\t} :\n\n\t\t// Otherwise use our own trimming functionality\n\t\tfunction( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcore_push.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\tvar len;\n\n\t\tif ( arr ) {\n\t\t\tif ( core_indexOf ) {\n\t\t\t\treturn core_indexOf.call( arr, elem, i );\n\t\t\t}\n\n\t\t\tlen = arr.length;\n\t\t\ti = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t// Skip accessing in sparse arrays\n\t\t\t\tif ( i in arr && arr[ i ] === elem ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar l = second.length,\n\t\t\ti = first.length,\n\t\t\tj = 0;\n\n\t\tif ( typeof l === \"number\" ) {\n\t\t\tfor ( ; j < l; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\t\t} else {\n\t\t\twhile ( second[j] !== undefined ) {\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t}\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, inv ) {\n\t\tvar retVal,\n\t\t\tret = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length;\n\t\tinv = !!inv;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tretVal = !!callback( elems[ i ], i );\n\t\t\tif ( inv !== retVal ) {\n\t\t\t\tret.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret[ ret.length ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret[ ret.length ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn core_concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar args, proxy, tmp;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = core_slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\taccess: function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\t\tvar i = 0,\n\t\t\tlength = elems.length,\n\t\t\tbulk = key == null;\n\n\t\t// Sets many values\n\t\tif ( jQuery.type( key ) === \"object\" ) {\n\t\t\tchainable = true;\n\t\t\tfor ( i in key ) {\n\t\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t\t}\n\n\t\t// Sets one value\n\t\t} else if ( value !== undefined ) {\n\t\t\tchainable = true;\n\n\t\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\t\traw = true;\n\t\t\t}\n\n\t\t\tif ( bulk ) {\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif ( raw ) {\n\t\t\t\t\tfn.call( elems, value );\n\t\t\t\t\tfn = null;\n\n\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( fn ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chainable ?\n\t\t\telems :\n\n\t\t\t// Gets\n\t\t\tbulk ?\n\t\t\t\tfn.call( elems ) :\n\t\t\t\tlength ? fn( elems[0], key ) : emptyGet;\n\t},\n\n\tnow: function() {\n\t\treturn ( new Date() ).getTime();\n\t}\n});\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t// Standards-based browsers support DOMContentLoaded\n\t\t} else if ( document.addEventListener ) {\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\n\t\t// If IE event model is used\n\t\t} else {\n\t\t\t// Ensure firing before onload, maybe late but safe also for iframes\n\t\t\tdocument.attachEvent( \"onreadystatechange\", completed );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.attachEvent( \"onload\", completed );\n\n\t\t\t// If IE and not a frame\n\t\t\t// continually check to see if the document is ready\n\t\t\tvar top = false;\n\n\t\t\ttry {\n\t\t\t\ttop = window.frameElement == null && document.documentElement;\n\t\t\t} catch(e) {}\n\n\t\t\tif ( top && top.doScroll ) {\n\t\t\t\t(function doScrollCheck() {\n\t\t\t\t\tif ( !jQuery.isReady ) {\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Use the trick by Diego Perini\n\t\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\n\t\t\t\t\t\t\ttop.doScroll(\"left\");\n\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\treturn setTimeout( doScrollCheck, 50 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// detach all dom ready events\n\t\t\t\t\t\tdetach();\n\n\t\t\t\t\t\t// and execute any waiting functions\n\t\t\t\t\t\tjQuery.ready();\n\t\t\t\t\t}\n\t\t\t\t})();\n\t\t\t}\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\tvar length = obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || type !== \"function\" &&\n\t\t( length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\n}\n\n// All jQuery objects should point back to these\nrootjQuery = jQuery(document);\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\t\t// Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\targs = args || [];\n\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar action = tuple[ 0 ],\n\t\t\t\t\t\t\t\tfn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ action + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = core_slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\n\t\t\t\t\tif( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\njQuery.support = (function() {\n\n\tvar support, all, a,\n\t\tinput, select, fragment,\n\t\topt, eventName, isSupported, i,\n\t\tdiv = document.createElement(\"div\");\n\n\t// Setup\n\tdiv.setAttribute( \"className\", \"t\" );\n\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\n\t// Support tests won't run in some limited or non-browser environments\n\tall = div.getElementsByTagName(\"*\");\n\ta = div.getElementsByTagName(\"a\")[ 0 ];\n\tif ( !all || !a || !all.length ) {\n\t\treturn {};\n\t}\n\n\t// First batch of tests\n\tselect = document.createElement(\"select\");\n\topt = select.appendChild( document.createElement(\"option\") );\n\tinput = div.getElementsByTagName(\"input\")[ 0 ];\n\n\ta.style.cssText = \"top:1px;float:left;opacity:.5\";\n\tsupport = {\n\t\t// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n\t\tgetSetAttribute: div.className !== \"t\",\n\n\t\t// IE strips leading whitespace when .innerHTML is used\n\t\tleadingWhitespace: div.firstChild.nodeType === 3,\n\n\t\t// Make sure that tbody elements aren't automatically inserted\n\t\t// IE will insert them into empty tables\n\t\ttbody: !div.getElementsByTagName(\"tbody\").length,\n\n\t\t// Make sure that link elements get serialized correctly by innerHTML\n\t\t// This requires a wrapper element in IE\n\t\thtmlSerialize: !!div.getElementsByTagName(\"link\").length,\n\n\t\t// Get the style information from getAttribute\n\t\t// (IE uses .cssText instead)\n\t\tstyle: /top/.test( a.getAttribute(\"style\") ),\n\n\t\t// Make sure that URLs aren't manipulated\n\t\t// (IE normalizes it by default)\n\t\threfNormalized: a.getAttribute(\"href\") === \"/a\",\n\n\t\t// Make sure that element opacity exists\n\t\t// (IE uses filter instead)\n\t\t// Use a regex to work around a WebKit issue. See #5145\n\t\topacity: /^0.5/.test( a.style.opacity ),\n\n\t\t// Verify style float existence\n\t\t// (IE uses styleFloat instead of cssFloat)\n\t\tcssFloat: !!a.style.cssFloat,\n\n\t\t// Check the default checkbox/radio value (\"\" on WebKit; \"on\" elsewhere)\n\t\tcheckOn: !!input.value,\n\n\t\t// Make sure that a selected-by-default option has a working selected property.\n\t\t// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n\t\toptSelected: opt.selected,\n\n\t\t// Tests for enctype support on a form (#6743)\n\t\tenctype: !!document.createElement(\"form\").enctype,\n\n\t\t// Makes sure cloning an html5 element does not cause problems\n\t\t// Where outerHTML is undefined, this still works\n\t\thtml5Clone: document.createElement(\"nav\").cloneNode( true ).outerHTML !== \"<:nav></:nav>\",\n\n\t\t// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode\n\t\tboxModel: document.compatMode === \"CSS1Compat\",\n\n\t\t// Will be defined later\n\t\tdeleteExpando: true,\n\t\tnoCloneEvent: true,\n\t\tinlineBlockNeedsLayout: false,\n\t\tshrinkWrapBlocks: false,\n\t\treliableMarginRight: true,\n\t\tboxSizingReliable: true,\n\t\tpixelPosition: false\n\t};\n\n\t// Make sure checked status is properly cloned\n\tinput.checked = true;\n\tsupport.noCloneChecked = input.cloneNode( true ).checked;\n\n\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t// (WebKit marks them as disabled)\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Support: IE<9\n\ttry {\n\t\tdelete div.test;\n\t} catch( e ) {\n\t\tsupport.deleteExpando = false;\n\t}\n\n\t// Check if we can trust getAttribute(\"value\")\n\tinput = document.createElement(\"input\");\n\tinput.setAttribute( \"value\", \"\" );\n\tsupport.input = input.getAttribute( \"value\" ) === \"\";\n\n\t// Check if an input maintains its value after becoming a radio\n\tinput.value = \"t\";\n\tinput.setAttribute( \"type\", \"radio\" );\n\tsupport.radioValue = input.value === \"t\";\n\n\t// #11217 - WebKit loses check when the name is after the checked attribute\n\tinput.setAttribute( \"checked\", \"t\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tfragment = document.createDocumentFragment();\n\tfragment.appendChild( input );\n\n\t// Check if a disconnected checkbox will retain its checked\n\t// value of true after appended to the DOM (IE6/7)\n\tsupport.appendChecked = input.checked;\n\n\t// WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE<9\n\t// Opera does not clone events (and typeof div.attachEvent === undefined).\n\t// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()\n\tif ( div.attachEvent ) {\n\t\tdiv.attachEvent( \"onclick\", function() {\n\t\t\tsupport.noCloneEvent = false;\n\t\t});\n\n\t\tdiv.cloneNode( true ).click();\n\t}\n\n\t// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)\n\t// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP), test/csp.php\n\tfor ( i in { submit: true, change: true, focusin: true }) {\n\t\tdiv.setAttribute( eventName = \"on\" + i, \"t\" );\n\n\t\tsupport[ i + \"Bubbles\" ] = eventName in window || div.attributes[ eventName ].expando === false;\n\t}\n\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\t// Run tests that need a body at doc ready\n\tjQuery(function() {\n\t\tvar container, marginDiv, tds,\n\t\t\tdivReset = \"padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;\",\n\t\t\tbody = document.getElementsByTagName(\"body\")[0];\n\n\t\tif ( !body ) {\n\t\t\t// Return for frameset docs that don't have a body\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer = document.createElement(\"div\");\n\t\tcontainer.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\";\n\n\t\tbody.appendChild( container ).appendChild( div );\n\n\t\t// Support: IE8\n\t\t// Check if table cells still have offsetWidth/Height when they are set\n\t\t// to display:none and there are still other visible table cells in a\n\t\t// table row; if so, offsetWidth/Height are not reliable for use when\n\t\t// determining if an element has been hidden directly using\n\t\t// display:none (it is still safe to use offsets if a parent element is\n\t\t// hidden; don safety goggles and see bug #4512 for more information).\n\t\tdiv.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n\t\ttds = div.getElementsByTagName(\"td\");\n\t\ttds[ 0 ].style.cssText = \"padding:0;margin:0;border:0;display:none\";\n\t\tisSupported = ( tds[ 0 ].offsetHeight === 0 );\n\n\t\ttds[ 0 ].style.display = \"\";\n\t\ttds[ 1 ].style.display = \"none\";\n\n\t\t// Support: IE8\n\t\t// Check if empty table cells still have offsetWidth/Height\n\t\tsupport.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );\n\n\t\t// Check box-sizing and margin behavior\n\t\tdiv.innerHTML = \"\";\n\t\tdiv.style.cssText = \"box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;\";\n\t\tsupport.boxSizing = ( div.offsetWidth === 4 );\n\t\tsupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );\n\n\t\t// Use window.getComputedStyle because jsdom on node.js will break without it.\n\t\tif ( window.getComputedStyle ) {\n\t\t\tsupport.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\n\t\t\tsupport.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\n\n\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t// Fails in WebKit before Feb 2011 nightlies\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\tmarginDiv = div.appendChild( document.createElement(\"div\") );\n\t\t\tmarginDiv.style.cssText = div.style.cssText = divReset;\n\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\tdiv.style.width = \"1px\";\n\n\t\t\tsupport.reliableMarginRight =\n\t\t\t\t!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );\n\t\t}\n\n\t\tif ( typeof div.style.zoom !== core_strundefined ) {\n\t\t\t// Support: IE<8\n\t\t\t// Check if natively block-level elements act like inline-block\n\t\t\t// elements when setting their display to 'inline' and giving\n\t\t\t// them layout\n\t\t\tdiv.innerHTML = \"\";\n\t\t\tdiv.style.cssText = divReset + \"width:1px;padding:1px;display:inline;zoom:1\";\n\t\t\tsupport.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );\n\n\t\t\t// Support: IE6\n\t\t\t// Check if elements with layout shrink-wrap their children\n\t\t\tdiv.style.display = \"block\";\n\t\t\tdiv.innerHTML = \"<div></div>\";\n\t\t\tdiv.firstChild.style.width = \"5px\";\n\t\t\tsupport.shrinkWrapBlocks = ( div.offsetWidth !== 3 );\n\n\t\t\tif ( support.inlineBlockNeedsLayout ) {\n\t\t\t\t// Prevent IE 6 from affecting layout for positioned elements #11048\n\t\t\t\t// Prevent IE from shrinking the body in IE 7 mode #12869\n\t\t\t\t// Support: IE<8\n\t\t\t\tbody.style.zoom = 1;\n\t\t\t}\n\t\t}\n\n\t\tbody.removeChild( container );\n\n\t\t// Null elements to avoid leaks in IE\n\t\tcontainer = div = tds = marginDiv = null;\n\t});\n\n\t// Null elements to avoid leaks in IE\n\tall = select = fragment = opt = a = input = null;\n\n\treturn support;\n})();\n\nvar rbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction internalData( elem, name, data, pvt /* Internal Use Only */ ){\n\tif ( !jQuery.acceptData( elem ) ) {\n\t\treturn;\n\t}\n\n\tvar thisCache, ret,\n\t\tinternalKey = jQuery.expando,\n\t\tgetByName = typeof name === \"string\",\n\n\t\t// We have to handle DOM nodes and JS objects differently because IE6-7\n\t\t// can't GC object references properly across the DOM-JS boundary\n\t\tisNode = elem.nodeType,\n\n\t\t// Only DOM nodes need the global jQuery cache; JS object data is\n\t\t// attached directly to the object so GC can occur automatically\n\t\tcache = isNode ? jQuery.cache : elem,\n\n\t\t// Only defining an ID for JS objects if its cache already exists allows\n\t\t// the code to shortcut on the same path as a DOM node with no cache\n\t\tid = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;\n\n\t// Avoid doing any more work than we need to when trying to get data on an\n\t// object that has no data at all\n\tif ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {\n\t\treturn;\n\t}\n\n\tif ( !id ) {\n\t\t// Only DOM nodes need a new unique ID for each element since their data\n\t\t// ends up in the global cache\n\t\tif ( isNode ) {\n\t\t\telem[ internalKey ] = id = core_deletedIds.pop() || jQuery.guid++;\n\t\t} else {\n\t\t\tid = internalKey;\n\t\t}\n\t}\n\n\tif ( !cache[ id ] ) {\n\t\tcache[ id ] = {};\n\n\t\t// Avoids exposing jQuery metadata on plain JS objects when the object\n\t\t// is serialized using JSON.stringify\n\t\tif ( !isNode ) {\n\t\t\tcache[ id ].toJSON = jQuery.noop;\n\t\t}\n\t}\n\n\t// An object can be passed to jQuery.data instead of a key/value pair; this gets\n\t// shallow copied over onto the existing cache\n\tif ( typeof name === \"object\" || typeof name === \"function\" ) {\n\t\tif ( pvt ) {\n\t\t\tcache[ id ] = jQuery.extend( cache[ id ], name );\n\t\t} else {\n\t\t\tcache[ id ].data = jQuery.extend( cache[ id ].data, name );\n\t\t}\n\t}\n\n\tthisCache = cache[ id ];\n\n\t// jQuery data() is stored in a separate object inside the object's internal data\n\t// cache in order to avoid key collisions between internal data and user-defined\n\t// data.\n\tif ( !pvt ) {\n\t\tif ( !thisCache.data ) {\n\t\t\tthisCache.data = {};\n\t\t}\n\n\t\tthisCache = thisCache.data;\n\t}\n\n\tif ( data !== undefined ) {\n\t\tthisCache[ jQuery.camelCase( name ) ] = data;\n\t}\n\n\t// Check for both converted-to-camel and non-converted data property names\n\t// If a data property was specified\n\tif ( getByName ) {\n\n\t\t// First Try to find as-is property data\n\t\tret = thisCache[ name ];\n\n\t\t// Test for null|undefined property data\n\t\tif ( ret == null ) {\n\n\t\t\t// Try to find the camelCased property\n\t\t\tret = thisCache[ jQuery.camelCase( name ) ];\n\t\t}\n\t} else {\n\t\tret = thisCache;\n\t}\n\n\treturn ret;\n}\n\nfunction internalRemoveData( elem, name, pvt ) {\n\tif ( !jQuery.acceptData( elem ) ) {\n\t\treturn;\n\t}\n\n\tvar i, l, thisCache,\n\t\tisNode = elem.nodeType,\n\n\t\t// See jQuery.data for more information\n\t\tcache = isNode ? jQuery.cache : elem,\n\t\tid = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\n\t// If there is already no cache entry for this object, there is no\n\t// purpose in continuing\n\tif ( !cache[ id ] ) {\n\t\treturn;\n\t}\n\n\tif ( name ) {\n\n\t\tthisCache = pvt ? cache[ id ] : cache[ id ].data;\n\n\t\tif ( thisCache ) {\n\n\t\t\t// Support array or space separated string names for data keys\n\t\t\tif ( !jQuery.isArray( name ) ) {\n\n\t\t\t\t// try the string as a key before any manipulation\n\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\tname = [ name ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// split the camel cased version by spaces unless a key with the spaces exists\n\t\t\t\t\tname = jQuery.camelCase( name );\n\t\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\t\tname = [ name ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tname = name.split(\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = name.concat( jQuery.map( name, jQuery.camelCase ) );\n\t\t\t}\n\n\t\t\tfor ( i = 0, l = name.length; i < l; i++ ) {\n\t\t\t\tdelete thisCache[ name[i] ];\n\t\t\t}\n\n\t\t\t// If there is no data left in the cache, we want to continue\n\t\t\t// and let the cache object itself get destroyed\n\t\t\tif ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// See jQuery.data for more information\n\tif ( !pvt ) {\n\t\tdelete cache[ id ].data;\n\n\t\t// Don't destroy the parent cache unless the internal data object\n\t\t// had been the only thing left in it\n\t\tif ( !isEmptyDataObject( cache[ id ] ) ) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Destroy the cache\n\tif ( isNode ) {\n\t\tjQuery.cleanData( [ elem ], true );\n\n\t// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n\t} else if ( jQuery.support.deleteExpando || cache != cache.window ) {\n\t\tdelete cache[ id ];\n\n\t// When all else fails, null\n\t} else {\n\t\tcache[ id ] = null;\n\t}\n}\n\njQuery.extend({\n\tcache: {},\n\n\t// Unique for each copy of jQuery on the page\n\t// Non-digits removed to match rinlinejQuery\n\texpando: \"jQuery\" + ( core_version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// The following elements throw uncatchable exceptions if you\n\t// attempt to add expando properties to them.\n\tnoData: {\n\t\t\"embed\": true,\n\t\t// Ban all objects except for Flash (which handle expandos)\n\t\t\"object\": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",\n\t\t\"applet\": true\n\t},\n\n\thasData: function( elem ) {\n\t\telem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];\n\t\treturn !!elem && !isEmptyDataObject( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn internalData( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\treturn internalRemoveData( elem, name );\n\t},\n\n\t// For internal use only.\n\t_data: function( elem, name, data ) {\n\t\treturn internalData( elem, name, data, true );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\treturn internalRemoveData( elem, name, true );\n\t},\n\n\t// A method for determining if a DOM node can handle the data expando\n\tacceptData: function( elem ) {\n\t\t// Do not set data on non-element because it will not be cleared (#8335).\n\t\tif ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];\n\n\t\t// nodes accept data unless otherwise specified; rejection can be conditional\n\t\treturn !noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar attrs, name,\n\t\t\telem = this[0],\n\t\t\ti = 0,\n\t\t\tdata = null;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = jQuery.data( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !jQuery._data( elem, \"parsedAttrs\" ) ) {\n\t\t\t\t\tattrs = elem.attributes;\n\t\t\t\t\tfor ( ; i < attrs.length; i++ ) {\n\t\t\t\t\t\tname = attrs[i].name;\n\n\t\t\t\t\t\tif ( !name.indexOf( \"data-\" ) ) {\n\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\n\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tjQuery._data( elem, \"parsedAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.data( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn jQuery.access( this, function( value ) {\n\n\t\t\tif ( value === undefined ) {\n\t\t\t\t// Try to fetch any internally stored data first\n\t\t\t\treturn elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;\n\t\t\t}\n\n\t\t\tthis.each(function() {\n\t\t\t\tjQuery.data( this, key, value );\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeData( this, key );\n\t\t});\n\t}\n});\n\nfunction dataAttr( elem, key, data ) {\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\n\t\tvar name = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tjQuery.data( elem, key, data );\n\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\n\treturn data;\n}\n\n// checks a cache object for emptiness\nfunction isEmptyDataObject( obj ) {\n\tvar name;\n\tfor ( name in obj ) {\n\n\t\t// if the public data object is empty, the private is still empty\n\t\tif ( name === \"data\" && jQuery.isEmptyObject( obj[name] ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( name !== \"toJSON\" ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = jQuery._data( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray(data) ) {\n\t\t\t\t\tqueue = jQuery._data( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\thooks.cur = fn;\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn jQuery._data( elem, key ) || jQuery._data( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tjQuery._removeData( elem, type + \"queue\" );\n\t\t\t\tjQuery._removeData( elem, key );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tdelay: function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue( type, function( next, hooks ) {\n\t\t\tvar timeout = setTimeout( next, time );\n\t\t\thooks.stop = function() {\n\t\t\t\tclearTimeout( timeout );\n\t\t\t};\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile( i-- ) {\n\t\t\ttmp = jQuery._data( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar nodeHook, boolHook,\n\trclass = /[\\t\\r\\n]/g,\n\trreturn = /\\r/g,\n\trfocusable = /^(?:input|select|textarea|button|object)$/i,\n\trclickable = /^(?:a|area)$/i,\n\trboolean = /^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,\n\truseDefault = /^(?:checked|selected)$/i,\n\tgetSetAttribute = jQuery.support.getSetAttribute,\n\tgetSetInput = jQuery.support.input;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t},\n\n\tprop: function( name, value ) {\n\t\treturn jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\tname = jQuery.propFix[ name ] || name;\n\t\treturn this.each(function() {\n\t\t\t// try/catch handles cases where IE balks (such as removing a property on window)\n\t\t\ttry {\n\t\t\t\tthis[ name ] = undefined;\n\t\t\t\tdelete this[ name ];\n\t\t\t} catch( e ) {}\n\t\t});\n\t},\n\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telem.className = jQuery.trim( cur );\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telem.className = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisBool = typeof stateVal === \"boolean\";\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tstate = stateVal,\n\t\t\t\t\tclassNames = value.match( core_rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// check each className given, space separated list\n\t\t\t\t\tstate = isBool ? state : !self.hasClass( className );\n\t\t\t\t\tself[ state ? \"addClass\" : \"removeClass\" ]( className );\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === core_strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tjQuery._data( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : jQuery._data( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\tval: function( value ) {\n\t\tvar ret, hooks, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val,\n\t\t\t\tself = jQuery(this);\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, self.val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map(val, function ( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\t// attributes.value is undefined in Blackberry 4.7 but\n\t\t\t\t// uses .value. See #6932\n\t\t\t\tvar val = elem.attributes.value;\n\t\t\t\treturn !val || val.specified ? elem.value : elem.text;\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// oldIE doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar values = jQuery.makeArray( value );\n\n\t\t\t\tjQuery(elem).find(\"option\").each(function() {\n\t\t\t\t\tthis.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;\n\t\t\t\t});\n\n\t\t\t\tif ( !values.length ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t},\n\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, notxml, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === core_strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( notxml ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && notxml && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && notxml && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\n\t\t\t// In IE9+, Flash objects don't have .getAttribute (#12945)\n\t\t\t// Support: IE9+\n\t\t\tif ( typeof elem.getAttribute !== core_strundefined ) {\n\t\t\t\tret =  elem.getAttribute( name );\n\t\t\t}\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( core_rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( rboolean.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false for boolean attributes\n\t\t\t\t\t// Also clear defaultChecked/defaultSelected (if appropriate) for IE<8\n\t\t\t\t\tif ( !getSetAttribute && ruseDefault.test( name ) ) {\n\t\t\t\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] =\n\t\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t}\n\n\t\t\t\t// See #9699 for explanation of this approach (setting first, then removal)\n\t\t\t\t} else {\n\t\t\t\t\tjQuery.attr( elem, name, \"\" );\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( getSetAttribute ? name : propName );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\ttabindex: \"tabIndex\",\n\t\treadonly: \"readOnly\",\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\",\n\t\tmaxlength: \"maxLength\",\n\t\tcellspacing: \"cellSpacing\",\n\t\tcellpadding: \"cellPadding\",\n\t\trowspan: \"rowSpan\",\n\t\tcolspan: \"colSpan\",\n\t\tusemap: \"useMap\",\n\t\tframeborder: \"frameBorder\",\n\t\tcontenteditable: \"contentEditable\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\treturn ( elem[ name ] = value );\n\t\t\t}\n\n\t\t} else {\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\treturn elem[ name ];\n\t\t\t}\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\t// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\tvar attributeNode = elem.getAttributeNode(\"tabindex\");\n\n\t\t\t\treturn attributeNode && attributeNode.specified ?\n\t\t\t\t\tparseInt( attributeNode.value, 10 ) :\n\t\t\t\t\trfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n\t\t\t\t\t\t0 :\n\t\t\t\t\t\tundefined;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hook for boolean attributes\nboolHook = {\n\tget: function( elem, name ) {\n\t\tvar\n\t\t\t// Use .prop to determine if this attribute is understood as boolean\n\t\t\tprop = jQuery.prop( elem, name ),\n\n\t\t\t// Fetch it accordingly\n\t\t\tattr = typeof prop === \"boolean\" && elem.getAttribute( name ),\n\t\t\tdetail = typeof prop === \"boolean\" ?\n\n\t\t\t\tgetSetInput && getSetAttribute ?\n\t\t\t\t\tattr != null :\n\t\t\t\t\t// oldIE fabricates an empty string for missing boolean attributes\n\t\t\t\t\t// and conflates checked/selected into attroperties\n\t\t\t\t\truseDefault.test( name ) ?\n\t\t\t\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] :\n\t\t\t\t\t\t!!attr :\n\n\t\t\t\t// fetch an attribute node for properties not recognized as boolean\n\t\t\t\telem.getAttributeNode( name );\n\n\t\treturn detail && detail.value !== false ?\n\t\t\tname.toLowerCase() :\n\t\t\tundefined;\n\t},\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n\t\t\t// IE<8 needs the *property* name\n\t\t\telem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );\n\n\t\t// Use defaultChecked and defaultSelected for oldIE\n\t\t} else {\n\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] = elem[ name ] = true;\n\t\t}\n\n\t\treturn name;\n\t}\n};\n\n// fix oldIE value attroperty\nif ( !getSetInput || !getSetAttribute ) {\n\tjQuery.attrHooks.value = {\n\t\tget: function( elem, name ) {\n\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\treturn jQuery.nodeName( elem, \"input\" ) ?\n\n\t\t\t\t// Ignore the value *property* by using defaultValue\n\t\t\t\telem.defaultValue :\n\n\t\t\t\tret && ret.specified ? ret.value : undefined;\n\t\t},\n\t\tset: function( elem, value, name ) {\n\t\t\tif ( jQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t// Does not return so that setAttribute is also used\n\t\t\t\telem.defaultValue = value;\n\t\t\t} else {\n\t\t\t\t// Use nodeHook if defined (#1954); otherwise setAttribute is fine\n\t\t\t\treturn nodeHook && nodeHook.set( elem, value, name );\n\t\t\t}\n\t\t}\n\t};\n}\n\n// IE6/7 do not support getting/setting some attributes with get/setAttribute\nif ( !getSetAttribute ) {\n\n\t// Use this for any attribute in IE6/7\n\t// This fixes almost every IE6/7 issue\n\tnodeHook = jQuery.valHooks.button = {\n\t\tget: function( elem, name ) {\n\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\treturn ret && ( name === \"id\" || name === \"name\" || name === \"coords\" ? ret.value !== \"\" : ret.specified ) ?\n\t\t\t\tret.value :\n\t\t\t\tundefined;\n\t\t},\n\t\tset: function( elem, value, name ) {\n\t\t\t// Set the existing or create a new attribute node\n\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\tif ( !ret ) {\n\t\t\t\telem.setAttributeNode(\n\t\t\t\t\t(ret = elem.ownerDocument.createAttribute( name ))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tret.value = value += \"\";\n\n\t\t\t// Break association with cloned elements by also using setAttribute (#9646)\n\t\t\treturn name === \"value\" || value === elem.getAttribute( name ) ?\n\t\t\t\tvalue :\n\t\t\t\tundefined;\n\t\t}\n\t};\n\n\t// Set contenteditable to false on removals(#10429)\n\t// Setting to empty string throws an error as an invalid value\n\tjQuery.attrHooks.contenteditable = {\n\t\tget: nodeHook.get,\n\t\tset: function( elem, value, name ) {\n\t\t\tnodeHook.set( elem, value === \"\" ? false : value, name );\n\t\t}\n\t};\n\n\t// Set width and height to auto instead of 0 on empty string( Bug #8150 )\n\t// This is for removals\n\tjQuery.each([ \"width\", \"height\" ], function( i, name ) {\n\t\tjQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( value === \"\" ) {\n\t\t\t\t\telem.setAttribute( name, \"auto\" );\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n\n// Some attributes require a special call on IE\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !jQuery.support.hrefNormalized ) {\n\tjQuery.each([ \"href\", \"src\", \"width\", \"height\" ], function( i, name ) {\n\t\tjQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar ret = elem.getAttribute( name, 2 );\n\t\t\t\treturn ret == null ? undefined : ret;\n\t\t\t}\n\t\t});\n\t});\n\n\t// href/src property should get the full normalized URL (#10299/#12915)\n\tjQuery.each([ \"href\", \"src\" ], function( i, name ) {\n\t\tjQuery.propHooks[ name ] = {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.getAttribute( name, 4 );\n\t\t\t}\n\t\t};\n\t});\n}\n\nif ( !jQuery.support.style ) {\n\tjQuery.attrHooks.style = {\n\t\tget: function( elem ) {\n\t\t\t// Return undefined in the case of empty string\n\t\t\t// Note: IE uppercases css property names, but if we were to .toLowerCase()\n\t\t\t// .cssText, that would destroy case senstitivity in URL's, like in \"background\"\n\t\t\treturn elem.style.cssText || undefined;\n\t\t},\n\t\tset: function( elem, value ) {\n\t\t\treturn ( elem.style.cssText = value + \"\" );\n\t\t}\n\t};\n}\n\n// Safari mis-reports the default selected property of an option\n// Accessing the parent's selectedIndex property fixes it\nif ( !jQuery.support.optSelected ) {\n\tjQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\t// Make sure that it also works with optgroups, see #5701\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t});\n}\n\n// IE6/7 call enctype encoding\nif ( !jQuery.support.enctype ) {\n\tjQuery.propFix.enctype = \"encoding\";\n}\n\n// Radios and checkboxes getter/setter\nif ( !jQuery.support.checkOn ) {\n\tjQuery.each([ \"radio\", \"checkbox\" ], function() {\n\t\tjQuery.valHooks[ this ] = {\n\t\t\tget: function( elem ) {\n\t\t\t\t// Handle the case where in Webkit \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t\t}\n\t\t};\n\t});\n}\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t});\n});\nvar rformElems = /^(?:input|select|textarea)$/i,\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\t\tvar tmp, events, t, handleObjIn,\n\t\t\tspecial, eventHandle, handleObj,\n\t\t\thandlers, type, namespaces, origType,\n\t\t\telemData = jQuery._data( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?\n\t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n\t\t\t\t\tundefined;\n\t\t\t};\n\t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\t\t\teventHandle.elem = elem;\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\t// jQuery(...).bind(\"mouseover mouseout\", fn);\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener/attachEvent if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\n\t\t\t\t\t} else if ( elem.attachEvent ) {\n\t\t\t\t\t\telem.attachEvent( \"on\" + type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\t\tvar j, handleObj, tmp,\n\t\t\torigCount, t, events,\n\t\t\tspecial, handlers, type,\n\t\t\tnamespaces, origType,\n\t\t\telemData = jQuery.hasData( elem ) && jQuery._data( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\n\t\t\t// removeData also checks for emptiness and clears the expando if empty\n\t\t\t// so use it instead of delete\n\t\t\tjQuery._removeData( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\t\tvar handle, ontype, cur,\n\t\t\tbubbleType, special, tmp, i,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = core_hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = core_hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\tevent.isTrigger = true;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( jQuery._data( cur, \"events\" ) || {} )[ event.type ] && jQuery._data( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&\n\t\t\t\t!(type === \"click\" && jQuery.nodeName( elem, \"a\" )) && jQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Can't use an .isFunction() check here because IE6/7 fails that test.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\ttry {\n\t\t\t\t\t\telem[ type ]();\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t// IE<9 dies on focus/blur to hidden element (#1486,#12518)\n\t\t\t\t\t\t// only reproducible on winXP IE8 native, not IE9 in IE8 mode\n\t\t\t\t\t}\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, ret, handleObj, matched, j,\n\t\t\thandlerQueue = [],\n\t\t\targs = core_slice.call( arguments ),\n\t\t\thandlers = ( jQuery._data( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or\n\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar sel, handleObj, matches, i,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\tfor ( ; cur != this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== \"click\") ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Fix target property (#1925)\n\t\tif ( !event.target ) {\n\t\t\tevent.target = originalEvent.srcElement || document;\n\t\t}\n\n\t\t// Support: Chrome 23+, Safari?\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)\n\t\tevent.metaKey = !!event.metaKey;\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar body, eventDoc, doc,\n\t\t\t\tbutton = original.button,\n\t\t\t\tfromElement = original.fromElement;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add relatedTarget, if necessary\n\t\t\tif ( !event.relatedTarget && fromElement ) {\n\t\t\t\tevent.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( jQuery.nodeName( this, \"input\" ) && this.type === \"checkbox\" && this.click ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== document.activeElement && this.focus ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t// If we error on focus to hidden element (#1486, #12518),\n\t\t\t\t\t\t// let .trigger() run the handlers\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === document.activeElement && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Even when returnValue equals to undefined Firefox will still show alert\n\t\t\t\tif ( event.result !== undefined ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{ type: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = document.removeEventListener ?\n\tfunction( elem, type, handle ) {\n\t\tif ( elem.removeEventListener ) {\n\t\t\telem.removeEventListener( type, handle, false );\n\t\t}\n\t} :\n\tfunction( elem, type, handle ) {\n\t\tvar name = \"on\" + type;\n\n\t\tif ( elem.detachEvent ) {\n\n\t\t\t// #8545, #7054, preventing memory leaks for custom events in IE6-8\n\t\t\t// detachEvent needed property on element, by name of that event, to properly expose it to GC\n\t\t\tif ( typeof elem[ name ] === core_strundefined ) {\n\t\t\t\telem[ name ] = null;\n\t\t\t}\n\n\t\t\telem.detachEvent( name, handle );\n\t\t}\n\t};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||\n\t\t\tsrc.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\t\tif ( !e ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If preventDefault exists, run it on the original event\n\t\tif ( e.preventDefault ) {\n\t\t\te.preventDefault();\n\n\t\t// Support: IE\n\t\t// Otherwise set the returnValue property of the original event to false\n\t\t} else {\n\t\t\te.returnValue = false;\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\t\tif ( !e ) {\n\t\t\treturn;\n\t\t}\n\t\t// If stopPropagation exists, run it on the original event\n\t\tif ( e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\n\t\t// Support: IE\n\t\t// Set the cancelBubble property of the original event to true\n\t\te.cancelBubble = true;\n\t},\n\tstopImmediatePropagation: function() {\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// IE submit delegation\nif ( !jQuery.support.submitBubbles ) {\n\n\tjQuery.event.special.submit = {\n\t\tsetup: function() {\n\t\t\t// Only need this for delegated form submit events\n\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Lazy-add a submit handler when a descendant form may potentially be submitted\n\t\t\tjQuery.event.add( this, \"click._submit keypress._submit\", function( e ) {\n\t\t\t\t// Node name check avoids a VML-related crash in IE (#9807)\n\t\t\t\tvar elem = e.target,\n\t\t\t\t\tform = jQuery.nodeName( elem, \"input\" ) || jQuery.nodeName( elem, \"button\" ) ? elem.form : undefined;\n\t\t\t\tif ( form && !jQuery._data( form, \"submitBubbles\" ) ) {\n\t\t\t\t\tjQuery.event.add( form, \"submit._submit\", function( event ) {\n\t\t\t\t\t\tevent._submit_bubble = true;\n\t\t\t\t\t});\n\t\t\t\t\tjQuery._data( form, \"submitBubbles\", true );\n\t\t\t\t}\n\t\t\t});\n\t\t\t// return undefined since we don't need an event listener\n\t\t},\n\n\t\tpostDispatch: function( event ) {\n\t\t\t// If form was submitted by the user, bubble the event up the tree\n\t\t\tif ( event._submit_bubble ) {\n\t\t\t\tdelete event._submit_bubble;\n\t\t\t\tif ( this.parentNode && !event.isTrigger ) {\n\t\t\t\t\tjQuery.event.simulate( \"submit\", this.parentNode, event, true );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tteardown: function() {\n\t\t\t// Only need this for delegated form submit events\n\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n\t\t\tjQuery.event.remove( this, \"._submit\" );\n\t\t}\n\t};\n}\n\n// IE change delegation and checkbox/radio fix\nif ( !jQuery.support.changeBubbles ) {\n\n\tjQuery.event.special.change = {\n\n\t\tsetup: function() {\n\n\t\t\tif ( rformElems.test( this.nodeName ) ) {\n\t\t\t\t// IE doesn't fire change on a check/radio until blur; trigger it on click\n\t\t\t\t// after a propertychange. Eat the blur-change in special.change.handle.\n\t\t\t\t// This still fires onchange a second time for check/radio after blur.\n\t\t\t\tif ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n\t\t\t\t\tjQuery.event.add( this, \"propertychange._change\", function( event ) {\n\t\t\t\t\t\tif ( event.originalEvent.propertyName === \"checked\" ) {\n\t\t\t\t\t\t\tthis._just_changed = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tjQuery.event.add( this, \"click._change\", function( event ) {\n\t\t\t\t\t\tif ( this._just_changed && !event.isTrigger ) {\n\t\t\t\t\t\t\tthis._just_changed = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Allow triggered, simulated change events (#11500)\n\t\t\t\t\t\tjQuery.event.simulate( \"change\", this, event, true );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Delegated event; lazy-add a change handler on descendant inputs\n\t\t\tjQuery.event.add( this, \"beforeactivate._change\", function( e ) {\n\t\t\t\tvar elem = e.target;\n\n\t\t\t\tif ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, \"changeBubbles\" ) ) {\n\t\t\t\t\tjQuery.event.add( elem, \"change._change\", function( event ) {\n\t\t\t\t\t\tif ( this.parentNode && !event.isSimulated && !event.isTrigger ) {\n\t\t\t\t\t\t\tjQuery.event.simulate( \"change\", this.parentNode, event, true );\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tjQuery._data( elem, \"changeBubbles\", true );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\thandle: function( event ) {\n\t\t\tvar elem = event.target;\n\n\t\t\t// Swallow native change events from checkbox/radio, we already triggered them above\n\t\t\tif ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== \"radio\" && elem.type !== \"checkbox\") ) {\n\t\t\t\treturn event.handleObj.handler.apply( this, arguments );\n\t\t\t}\n\t\t},\n\n\t\tteardown: function() {\n\t\t\tjQuery.event.remove( this, \"._change\" );\n\n\t\t\treturn !rformElems.test( this.nodeName );\n\t\t}\n\t};\n}\n\n// Create \"bubbling\" focus and blur events\nif ( !jQuery.support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler while someone wants focusin/focusout\n\t\tvar attaches = 0,\n\t\t\thandler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tif ( attaches++ === 0 ) {\n\t\t\t\t\tdocument.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tif ( --attaches === 0 ) {\n\t\t\t\t\tdocument.removeEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar type, origFn;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\n/*!\n * Sizzle CSS Selector Engine\n * Copyright 2012 jQuery Foundation and other contributors\n * Released under the MIT license\n * http://sizzlejs.com/\n */\n(function( window, undefined ) {\n\nvar i,\n\tcachedruns,\n\tExpr,\n\tgetText,\n\tisXML,\n\tcompile,\n\thasDuplicate,\n\toutermostContext,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsXML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\tsortOrder,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + -(new Date()),\n\tpreferredDoc = window.document,\n\tsupport = {},\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\n\t// General-purpose constants\n\tstrundefined = typeof undefined,\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Array methods\n\tarr = [],\n\tpop = arr.pop,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf if we can't use a native one\n\tindexOf = arr.indexOf || function( elem ) {\n\t\tvar i = 0,\n\t\t\tlen = this.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( this[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\n\toperators = \"([*^$|!~]?=)\",\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace +\n\t\t\"*(?:\" + operators + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\n\n\t// Prefer arguments quoted,\n\t//   then not containing pseudos/brackets,\n\t//   then attribute selectors/non-parenthetical expressions,\n\t//   then anything else\n\t// These preferences are here to reduce the number of selectors\n\t//   needing tokenize in the PSEUDO preFilter\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace( 3, 8 ) + \")*)|.*)\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([\\\\x20\\\\t\\\\r\\\\n\\\\f>+~])\" + whitespace + \"*\" ),\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"NAME\": new RegExp( \"^\\\\[name=['\\\"]?(\" + characterEncoding + \")['\\\"]?\\\\]\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trsibling = /[\\x20\\t\\r\\n\\f]*[+~]/,\n\n\trnative = /^[^{]+\\{\\s*\\[native code/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trescape = /'|\\\\/g,\n\trattributeQuotes = /\\=[\\x20\\t\\r\\n\\f]*([^'\"\\]]*)[\\x20\\t\\r\\n\\f]*\\]/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = /\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|.)/g,\n\tfunescape = function( _, escaped ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\treturn high !== high ?\n\t\t\tescaped :\n\t\t\t// BMP codepoint\n\t\t\thigh < 0 ?\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t};\n\n// Use a stripped-down slice if we can't use a native one\ntry {\n\tslice.call( preferredDoc.documentElement.childNodes, 0 )[0].nodeType;\n} catch ( e ) {\n\tslice = function( i ) {\n\t\tvar elem,\n\t\t\tresults = [];\n\t\twhile ( (elem = this[i++]) ) {\n\t\t\tresults.push( elem );\n\t\t}\n\t\treturn results;\n\t};\n}\n\n/**\n * For feature detection\n * @param {Function} fn The function to test for native support\n */\nfunction isNative( fn ) {\n\treturn rnative.test( fn + \"\" );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar cache,\n\t\tkeys = [];\n\n\treturn (cache = function( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key += \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key ] = value);\n\t});\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tif ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\n\tif ( !documentIsXML && !seed ) {\n\n\t\t// Shortcuts\n\t\tif ( (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getByClassName && context.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, slice.call(context.getElementsByClassName( m ), 0) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && !rbuggyQSA.test(selector) ) {\n\t\t\told = true;\n\t\t\tnid = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType === 9 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && context.parentNode || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results, slice.call( newContext.querySelectorAll(\n\t\t\t\t\t\tnewSelector\n\t\t\t\t\t), 0 ) );\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Detect xml\n * @param {Element|Object} elem An element or a document\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar doc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\n\t// Support tests\n\tdocumentIsXML = isXML( doc );\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.tagNameNoComments = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Check if attributes should be retrieved by attribute nodes\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.innerHTML = \"<select></select>\";\n\t\tvar type = typeof div.lastChild.getAttribute(\"multiple\");\n\t\t// IE8 returns a string for some attributes even when not present\n\t\treturn type !== \"boolean\" && type !== \"string\";\n\t});\n\n\t// Check if getElementsByClassName can be trusted\n\tsupport.getByClassName = assert(function( div ) {\n\t\t// Opera can't find a second classname (in 9.6)\n\t\tdiv.innerHTML = \"<div class='hidden e'></div><div class='hidden'></div>\";\n\t\tif ( !div.getElementsByClassName || !div.getElementsByClassName(\"e\").length ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Safari 3.2 caches class attributes and doesn't catch changes\n\t\tdiv.lastChild.className = \"e\";\n\t\treturn div.getElementsByClassName(\"e\").length === 2;\n\t});\n\n\t// Check if getElementById returns elements by name\n\t// Check if getElementsByName privileges form controls or returns elements by ID\n\tsupport.getByName = assert(function( div ) {\n\t\t// Inject content\n\t\tdiv.id = expando + 0;\n\t\tdiv.innerHTML = \"<a name='\" + expando + \"'></a><div name='\" + expando + \"'></div>\";\n\t\tdocElem.insertBefore( div, docElem.firstChild );\n\n\t\t// Test\n\t\tvar pass = doc.getElementsByName &&\n\t\t\t// buggy browsers will return fewer than the correct 2\n\t\t\tdoc.getElementsByName( expando ).length === 2 +\n\t\t\t// buggy browsers will return more than the correct 0\n\t\t\tdoc.getElementsByName( expando + 0 ).length;\n\t\tsupport.getIdNotName = !doc.getElementById( expando );\n\n\t\t// Cleanup\n\t\tdocElem.removeChild( div );\n\n\t\treturn pass;\n\t});\n\n\t// IE6/7 return modified attributes\n\tExpr.attrHandle = assert(function( div ) {\n\t\tdiv.innerHTML = \"<a href='#'></a>\";\n\t\treturn div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&\n\t\t\tdiv.firstChild.getAttribute(\"href\") === \"#\";\n\t}) ?\n\t\t{} :\n\t\t{\n\t\t\t\"href\": function( elem ) {\n\t\t\t\treturn elem.getAttribute( \"href\", 2 );\n\t\t\t},\n\t\t\t\"type\": function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"type\");\n\t\t\t}\n\t\t};\n\n\t// ID find and filter\n\tif ( support.getIdNotName ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== strundefined && !documentIsXML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [m] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== strundefined && !documentIsXML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\n\t\t\t\treturn m ?\n\t\t\t\t\tm.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode(\"id\").value === id ?\n\t\t\t\t\t\t[m] :\n\t\t\t\t\t\tundefined :\n\t\t\t\t\t[];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.tagNameNoComments ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== strundefined ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\t\t\t}\n\t\t} :\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Name\n\tExpr.find[\"NAME\"] = support.getByName && function( tag, context ) {\n\t\tif ( typeof context.getElementsByName !== strundefined ) {\n\t\t\treturn context.getElementsByName( name );\n\t\t}\n\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== strundefined && !documentIsXML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21),\n\t// no need to also add to buggyMatches since matches checks buggyQSA\n\t// A support test would require too much code (would include document ready)\n\trbuggyQSA = [ \":focus\" ];\n\n\tif ( (support.qsa = isNative(doc.querySelectorAll)) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explictly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdiv.innerHTML = \"<select><option selected=''></option></select>\";\n\n\t\t\t// IE8 - Some boolean attributes are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:checked|disabled|ismap|multiple|readonly|selected|value)\" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\n\t\t\t// Opera 10-12/IE8 - ^= $= *= and empty values\n\t\t\t// Should not select anything\n\t\t\tdiv.innerHTML = \"<input type='hidden' i=''/>\";\n\t\t\tif ( div.querySelectorAll(\"[i^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:\\\"\\\"|'')\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = isNative( (matches = docElem.matchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = new RegExp( rbuggyMatches.join(\"|\") );\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = isNative(docElem.contains) || docElem.compareDocumentPosition ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t// Document order sorting\n\tsortOrder = docElem.compareDocumentPosition ?\n\tfunction( a, b ) {\n\t\tvar compare;\n\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ( (compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b )) ) {\n\t\t\tif ( compare & 1 || a.parentNode && a.parentNode.nodeType === 11 ) {\n\t\t\t\tif ( a === doc || contains( preferredDoc, a ) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif ( b === doc || contains( preferredDoc, b ) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t}\n\n\t\treturn a.compareDocumentPosition ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\t} else if ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\t// Always assume the presence of duplicates if sort doesn't\n\t// pass them to our comparison function (as in Google Chrome).\n\thasDuplicate = false;\n\t[0, 0].sort( sortOrder );\n\tsupport.detectDuplicates = hasDuplicate;\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\t// rbuggyQSA always contains :focus, so no need for an existence check\n\tif ( support.matchesSelector && !documentIsXML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && !rbuggyQSA.test(expr) ) {\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch(e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [elem] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\tvar val;\n\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tif ( !documentIsXML ) {\n\t\tname = name.toLowerCase();\n\t}\n\tif ( (val = Expr.attrHandle[ name ]) ) {\n\t\treturn val( elem );\n\t}\n\tif ( documentIsXML || support.attributes ) {\n\t\treturn elem.getAttribute( name );\n\t}\n\treturn ( (val = elem.getAttributeNode( name )) || elem.getAttribute( name ) ) && elem[ name ] === true ?\n\t\tname :\n\t\tval && val.specified ? val.value : null;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n// Document sorting and removing duplicates\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\ti = 1,\n\t\tj = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\tfor ( ; (elem = results[i]); i++ ) {\n\t\t\tif ( elem === results[ i - 1 ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\treturn results;\n};\n\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && ( ~b.sourceIndex || MAX_NEGATIVE ) - ( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n// Returns a function to use in pseudos for input types\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n// Returns a function to use in pseudos for buttons\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n// Returns a function to use in pseudos for positionals\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\tfor ( ; (node = elem[i]); i++ ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (see #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[5] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[4] ) {\n\t\t\t\tmatch[2] = match[4];\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeName ) {\n\t\t\tif ( nodeName === \"*\" ) {\n\t\t\t\treturn function() { return true; };\n\t\t\t}\n\n\t\t\tnodeName = nodeName.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\")) || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifider\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsXML ?\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\") :\n\t\t\t\t\t\telem.lang) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),\n\t\t\t//   not comment, processing instructions, or others\n\t\t\t// Thanks to Diego Perini for the nodeName shortcut\n\t\t\t//   Greater than \"@\" means alpha characters (specifically not starting with \"#\" or \"?\")\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeName > \"@\" || elem.nodeType === 3 || elem.nodeType === 4 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\t// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\n\t\t\t// use getAttribute instead to test this case\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === elem.type );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\nfunction tokenize( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( tokens = [] );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push( {\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t} );\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push( {\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t} );\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n}\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar data, cache, outerCache,\n\t\t\t\tdirkey = dirruns + \" \" + doneName;\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {\n\t\t\t\t\t\t\tif ( (data = cache[1]) === true || data === cachedruns ) {\n\t\t\t\t\t\t\t\treturn data === true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcache = outerCache[ dir ] = [ dirkey ];\n\t\t\t\t\t\t\tcache[1] = matcher( elem, context, xml ) || cachedruns;\n\t\t\t\t\t\t\tif ( cache[1] === true ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf.call( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\treturn ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector( tokens.slice( 0, i - 1 ) ).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\t// A counter to specify which element is currently being matched\n\tvar matcherCachedRuns = 0,\n\t\tbySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, expandContext ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tsetMatched = [],\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\toutermost = expandContext != null,\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", expandContext && context.parentNode || context ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t\tcachedruns = matcherCachedRuns;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\tcachedruns = ++matcherCachedRuns;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !group ) {\n\t\t\tgroup = tokenize( selector );\n\t\t}\n\t\ti = group.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( group[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\t}\n\treturn cached;\n};\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction select( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tmatch = tokenize( selector );\n\n\tif ( !seed ) {\n\t\t// Try to minimize operations if there is only one group\n\t\tif ( match.length === 1 ) {\n\n\t\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tcontext.nodeType === 9 && !documentIsXML &&\n\t\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\t\tcontext = Expr.find[\"ID\"]( token.matches[0].replace( runescape, funescape ), context )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && context.parentNode || context\n\t\t\t\t\t)) ) {\n\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, slice.call( seed, 0 ) );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\tcompile( selector, match )(\n\t\tseed,\n\t\tcontext,\n\t\tdocumentIsXML,\n\t\tresults,\n\t\trsibling.test( selector )\n\t);\n\treturn results;\n}\n\n// Deprecated\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nExpr.filters = setFilters.prototype = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\n// Initialize with the default document\nsetDocument();\n\n// Override sizzle attribute retrieval\nSizzle.attr = jQuery.attr;\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n})( window );\nvar runtil = /Until$/,\n\trparentsprev = /^(?:parents|prev(?:Until|All))/,\n\tisSimple = /^.[^:#\\[\\.,]*$/,\n\trneedsContext = jQuery.expr.match.needsContext,\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i, ret, self,\n\t\t\tlen = this.length;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\tself = this;\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tret = [];\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, this[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = ( this.selector ? this.selector + \" \" : \"\" ) + selector;\n\t\treturn ret;\n\t},\n\n\thas: function( target ) {\n\t\tvar i,\n\t\t\ttargets = jQuery( target, this ),\n\t\t\tlen = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector, false) );\n\t},\n\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector, true) );\n\t},\n\n\tis: function( selector ) {\n\t\treturn !!selector && (\n\t\t\ttypeof selector === \"string\" ?\n\t\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\t\trneedsContext.test( selector ) ?\n\t\t\t\t\tjQuery( selector, this.context ).index( this[0] ) >= 0 :\n\t\t\t\t\tjQuery.filter( selector, this ).length > 0 :\n\t\t\t\tthis.filter( selector ).length > 0 );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tret = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tcur = this[i];\n\n\t\t\twhile ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {\n\t\t\t\tif ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {\n\t\t\t\t\tret.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn jQuery.inArray( this[0], jQuery( elem ) );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn jQuery.inArray(\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[0] : elem, this );\n\t},\n\n\tadd: function( selector, context ) {\n\t\tvar set = typeof selector === \"string\" ?\n\t\t\t\tjQuery( selector, context ) :\n\t\t\t\tjQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),\n\t\t\tall = jQuery.merge( this.get(), set );\n\n\t\treturn this.pushStack( jQuery.unique(all) );\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\nfunction sibling( cur, dir ) {\n\tdo {\n\t\tcur = cur[ dir ];\n\t} while ( cur && cur.nodeType !== 1 );\n\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn jQuery.nodeName( elem, \"iframe\" ) ?\n\t\t\telem.contentDocument || elem.contentWindow.document :\n\t\t\tjQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;\n\n\t\tif ( this.length > 1 && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\njQuery.extend({\n\tfilter: function( expr, elems, not ) {\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\n\t\treturn elems.length === 1 ?\n\t\t\tjQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :\n\t\t\tjQuery.find.matches(expr, elems);\n\t},\n\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\tcur = elem[ dir ];\n\n\t\twhile ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {\n\t\t\tif ( cur.nodeType === 1 ) {\n\t\t\t\tmatched.push( cur );\n\t\t\t}\n\t\t\tcur = cur[dir];\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar r = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tr.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn r;\n\t}\n});\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, keep ) {\n\n\t// Can't pass null or undefined to indexOf in Firefox 4\n\t// Set to 0 to skip string check\n\tqualifier = qualifier || 0;\n\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep(elements, function( elem, i ) {\n\t\t\tvar retVal = !!qualifier.call( elem, i, elem );\n\t\t\treturn retVal === keep;\n\t\t});\n\n\t} else if ( qualifier.nodeType ) {\n\t\treturn jQuery.grep(elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) === keep;\n\t\t});\n\n\t} else if ( typeof qualifier === \"string\" ) {\n\t\tvar filtered = jQuery.grep(elements, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t});\n\n\t\tif ( isSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter(qualifier, filtered, !keep);\n\t\t} else {\n\t\t\tqualifier = jQuery.filter( qualifier, filtered );\n\t\t}\n\t}\n\n\treturn jQuery.grep(elements, function( elem ) {\n\t\treturn ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;\n\t});\n}\nfunction createSafeFragment( document ) {\n\tvar list = nodeNames.split( \"|\" ),\n\t\tsafeFrag = document.createDocumentFragment();\n\n\tif ( safeFrag.createElement ) {\n\t\twhile ( list.length ) {\n\t\t\tsafeFrag.createElement(\n\t\t\t\tlist.pop()\n\t\t\t);\n\t\t}\n\t}\n\treturn safeFrag;\n}\n\nvar nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" +\n\t\t\"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n\trinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n\trnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n\trleadingWhitespace = /^\\s+/,\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trtbody = /<tbody/i,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\tmanipulation_rcheckableType = /^(?:checkbox|radio)$/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\t\tlegend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n\t\tarea: [ 1, \"<map>\", \"</map>\" ],\n\t\tparam: [ 1, \"<object>\", \"</object>\" ],\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\tcol: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n\t\t// unless wrapped in a div with non-breaking characters in front of it.\n\t\t_default: jQuery.support.htmlSerialize ? [ 0, \"\", \"\" ] : [ 1, \"X<div>\", \"</div>\"  ]\n\t},\n\tsafeFragment = createSafeFragment( document ),\n\tfragmentDiv = safeFragment.appendChild( document.createElement(\"div\") );\n\nwrapMap.optgroup = wrapMap.option;\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );\n\t\t}, null, value, arguments.length );\n\t},\n\n\twrapAll: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tjQuery(this).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[0] ) {\n\t\t\t// The elements to wrap the target around\n\t\t\tvar wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);\n\n\t\t\tif ( this[0].parentNode ) {\n\t\t\t\twrap.insertBefore( this[0] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n\t\t\t\t\telem = elem.firstChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tjQuery(this).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function(i) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip(arguments, true, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tthis.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip(arguments, true, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tthis.insertBefore( elem, this.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, false, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, false, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\t// keepData is for internal use only--do not document\n\tremove: function( selector, keepData ) {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( !selector || jQuery.filter( selector, [ elem ] ).length > 0 ) {\n\t\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t\t}\n\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t}\n\n\t\t\t// Remove any remaining nodes\n\t\t\twhile ( elem.firstChild ) {\n\t\t\t\telem.removeChild( elem.firstChild );\n\t\t\t}\n\n\t\t\t// If this is a select, ensure that it displays empty (#12336)\n\t\t\t// Support: IE<9\n\t\t\tif ( elem.options && jQuery.nodeName( elem, \"select\" ) ) {\n\t\t\t\telem.options.length = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function () {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\tvar elem = this[0] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined ) {\n\t\t\t\treturn elem.nodeType === 1 ?\n\t\t\t\t\telem.innerHTML.replace( rinlinejQuery, \"\" ) :\n\t\t\t\t\tundefined;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n\t\t\t\t( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [\"\", \"\"] )[1].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (; i < l; i++ ) {\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\telem = this[i] || {};\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function( value ) {\n\t\tvar isFunc = jQuery.isFunction( value );\n\n\t\t// Make sure that the elements are removed from the DOM before they are inserted\n\t\t// this can help fix replacing a parent with child elements\n\t\tif ( !isFunc && typeof value !== \"string\" ) {\n\t\t\tvalue = jQuery( value ).not( this ).detach();\n\t\t}\n\n\t\treturn this.domManip( [ value ], true, function( elem ) {\n\t\t\tvar next = this.nextSibling,\n\t\t\t\tparent = this.parentNode;\n\n\t\t\tif ( parent ) {\n\t\t\t\tjQuery( this ).remove();\n\t\t\t\tparent.insertBefore( elem, next );\n\t\t\t}\n\t\t});\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, table, callback ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = core_concat.apply( [], args );\n\n\t\tvar first, node, hasScripts,\n\t\t\tscripts, doc, fragment,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[0],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction || !( l <= 1 || typeof value !== \"string\" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[0] = value.call( this, index, table ? self.html() : undefined );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, table, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\ttable = table && jQuery.nodeName( first, \"tr\" );\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call(\n\t\t\t\t\t\ttable && jQuery.nodeName( this[i], \"table\" ) ?\n\t\t\t\t\t\t\tfindOrAppend( this[i], \"tbody\" ) :\n\t\t\t\t\t\t\tthis[i],\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\ti\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!jQuery._data( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Hope ajax is available...\n\t\t\t\t\t\t\t\tjQuery.ajax({\n\t\t\t\t\t\t\t\t\turl: node.src,\n\t\t\t\t\t\t\t\t\ttype: \"GET\",\n\t\t\t\t\t\t\t\t\tdataType: \"script\",\n\t\t\t\t\t\t\t\t\tasync: false,\n\t\t\t\t\t\t\t\t\tglobal: false,\n\t\t\t\t\t\t\t\t\t\"throws\": true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( ( node.text || node.textContent || node.innerHTML || \"\" ).replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Fix #11809: Avoid leaking memory\n\t\t\t\tfragment = first = null;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\nfunction findOrAppend( elem, tag ) {\n\treturn elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\tvar attr = elem.getAttributeNode(\"type\");\n\telem.type = ( attr && attr.specified ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\tif ( match ) {\n\t\telem.type = match[1];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar elem,\n\t\ti = 0;\n\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\tjQuery._data( elem, \"globalEval\", !refElements || jQuery._data( refElements[i], \"globalEval\" ) );\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\n\tif ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n\t\treturn;\n\t}\n\n\tvar type, i, l,\n\t\toldData = jQuery._data( src ),\n\t\tcurData = jQuery._data( dest, oldData ),\n\t\tevents = oldData.events;\n\n\tif ( events ) {\n\t\tdelete curData.handle;\n\t\tcurData.events = {};\n\n\t\tfor ( type in events ) {\n\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t// make the cloned public data object a copy from the original\n\tif ( curData.data ) {\n\t\tcurData.data = jQuery.extend( {}, curData.data );\n\t}\n}\n\nfunction fixCloneNodeIssues( src, dest ) {\n\tvar nodeName, e, data;\n\n\t// We do not need to do anything for non-Elements\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\tnodeName = dest.nodeName.toLowerCase();\n\n\t// IE6-8 copies events bound via attachEvent when using cloneNode.\n\tif ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {\n\t\tdata = jQuery._data( dest );\n\n\t\tfor ( e in data.events ) {\n\t\t\tjQuery.removeEvent( dest, e, data.handle );\n\t\t}\n\n\t\t// Event data gets referenced instead of copied if the expando gets copied too\n\t\tdest.removeAttribute( jQuery.expando );\n\t}\n\n\t// IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n\tif ( nodeName === \"script\" && dest.text !== src.text ) {\n\t\tdisableScript( dest ).text = src.text;\n\t\trestoreScript( dest );\n\n\t// IE6-10 improperly clones children of object elements using classid.\n\t// IE10 throws NoModificationAllowedError if parent is null, #12132.\n\t} else if ( nodeName === \"object\" ) {\n\t\tif ( dest.parentNode ) {\n\t\t\tdest.outerHTML = src.outerHTML;\n\t\t}\n\n\t\t// This path appears unavoidable for IE9. When cloning an object\n\t\t// element in IE9, the outerHTML strategy above is not sufficient.\n\t\t// If the src has innerHTML and the destination does not,\n\t\t// copy the src.innerHTML into the dest.innerHTML. #10324\n\t\tif ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {\n\t\t\tdest.innerHTML = src.innerHTML;\n\t\t}\n\n\t} else if ( nodeName === \"input\" && manipulation_rcheckableType.test( src.type ) ) {\n\t\t// IE6-8 fails to persist the checked state of a cloned checkbox\n\t\t// or radio button. Worse, IE6-7 fail to give the cloned element\n\t\t// a checked appearance if the defaultChecked value isn't also set\n\n\t\tdest.defaultChecked = dest.checked = src.checked;\n\n\t\t// IE6-7 get confused and end up setting the value of a cloned\n\t\t// checkbox/radio button to an empty string instead of \"on\"\n\t\tif ( dest.value !== src.value ) {\n\t\t\tdest.value = src.value;\n\t\t}\n\n\t// IE6-8 fails to return the selected option to the default selected\n\t// state when cloning options\n\t} else if ( nodeName === \"option\" ) {\n\t\tdest.defaultSelected = dest.selected = src.defaultSelected;\n\n\t// IE6-8 fails to set the defaultValue to the correct value when\n\t// cloning other types of input fields\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\ti = 0,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone(true);\n\t\t\tjQuery( insert[i] )[ original ]( elems );\n\n\t\t\t// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n\t\t\tcore_push.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\nfunction getAll( context, tag ) {\n\tvar elems, elem,\n\t\ti = 0,\n\t\tfound = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\ttypeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\tundefined;\n\n\tif ( !found ) {\n\t\tfor ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !tag || jQuery.nodeName( elem, tag ) ) {\n\t\t\t\tfound.push( elem );\n\t\t\t} else {\n\t\t\t\tjQuery.merge( found, getAll( elem, tag ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], found ) :\n\t\tfound;\n}\n\n// Used in buildFragment, fixes the defaultChecked property\nfunction fixDefaultChecked( elem ) {\n\tif ( manipulation_rcheckableType.test( elem.type ) ) {\n\t\telem.defaultChecked = elem.checked;\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar destElements, node, clone, i, srcElements,\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\tif ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( \"<\" + elem.nodeName + \">\" ) ) {\n\t\t\tclone = elem.cloneNode( true );\n\n\t\t// IE<=8 does not properly clone detached, unknown element nodes\n\t\t} else {\n\t\t\tfragmentDiv.innerHTML = elem.outerHTML;\n\t\t\tfragmentDiv.removeChild( clone = fragmentDiv.firstChild );\n\t\t}\n\n\t\tif ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&\n\t\t\t\t(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\t// Fix all IE cloning issues\n\t\t\tfor ( i = 0; (node = srcElements[i]) != null; ++i ) {\n\t\t\t\t// Ensure that the destination node is not null; Fixes #9587\n\t\t\t\tif ( destElements[i] ) {\n\t\t\t\t\tfixCloneNodeIssues( node, destElements[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0; (node = srcElements[i]) != null; i++ ) {\n\t\t\t\t\tcloneCopyEvent( node, destElements[i] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\tdestElements = srcElements = node = null;\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar j, elem, contains,\n\t\t\ttmp, tag, tbody, wrap,\n\t\t\tl = elems.length,\n\n\t\t\t// Ensure a safe fragment\n\t\t\tsafe = createSafeFragment( context ),\n\n\t\t\tnodes = [],\n\t\t\ti = 0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || safe.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [\"\", \"\"] )[1].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\n\t\t\t\t\ttmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[2];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[0];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Manually add leading whitespace removed by IE\n\t\t\t\t\tif ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n\t\t\t\t\t\tnodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove IE's autoinserted <tbody> from table fragments\n\t\t\t\t\tif ( !jQuery.support.tbody ) {\n\n\t\t\t\t\t\t// String was a <table>, *may* have spurious <tbody>\n\t\t\t\t\t\telem = tag === \"table\" && !rtbody.test( elem ) ?\n\t\t\t\t\t\t\ttmp.firstChild :\n\n\t\t\t\t\t\t\t// String was a bare <thead> or <tfoot>\n\t\t\t\t\t\t\twrap[1] === \"<table>\" && !rtbody.test( elem ) ?\n\t\t\t\t\t\t\t\ttmp :\n\t\t\t\t\t\t\t\t0;\n\n\t\t\t\t\t\tj = elem && elem.childNodes.length;\n\t\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\t\tif ( jQuery.nodeName( (tbody = elem.childNodes[j]), \"tbody\" ) && !tbody.childNodes.length ) {\n\t\t\t\t\t\t\t\telem.removeChild( tbody );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Fix #12392 for WebKit and IE > 9\n\t\t\t\t\ttmp.textContent = \"\";\n\n\t\t\t\t\t// Fix #12392 for oldIE\n\t\t\t\t\twhile ( tmp.firstChild ) {\n\t\t\t\t\t\ttmp.removeChild( tmp.firstChild );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remember the top-level container for proper cleanup\n\t\t\t\t\ttmp = safe.lastChild;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Fix #11356: Clear elements from fragment\n\t\tif ( tmp ) {\n\t\t\tsafe.removeChild( tmp );\n\t\t}\n\n\t\t// Reset defaultChecked for any radios and checkboxes\n\t\t// about to be appended to the DOM in IE 6/7 (#8060)\n\t\tif ( !jQuery.support.appendChecked ) {\n\t\t\tjQuery.grep( getAll( nodes, \"input\" ), fixDefaultChecked );\n\t\t}\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( safe.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttmp = null;\n\n\t\treturn safe;\n\t},\n\n\tcleanData: function( elems, /* internal */ acceptData ) {\n\t\tvar elem, type, id, data,\n\t\t\ti = 0,\n\t\t\tinternalKey = jQuery.expando,\n\t\t\tcache = jQuery.cache,\n\t\t\tdeleteExpando = jQuery.support.deleteExpando,\n\t\t\tspecial = jQuery.event.special;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\n\t\t\tif ( acceptData || jQuery.acceptData( elem ) ) {\n\n\t\t\t\tid = elem[ internalKey ];\n\t\t\t\tdata = id && cache[ id ];\n\n\t\t\t\tif ( data ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove cache only if it was not already removed by jQuery.event.remove\n\t\t\t\t\tif ( cache[ id ] ) {\n\n\t\t\t\t\t\tdelete cache[ id ];\n\n\t\t\t\t\t\t// IE does not allow us to delete expando properties from nodes,\n\t\t\t\t\t\t// nor does it have a removeAttribute function on Document nodes;\n\t\t\t\t\t\t// we must handle all of these cases\n\t\t\t\t\t\tif ( deleteExpando ) {\n\t\t\t\t\t\t\tdelete elem[ internalKey ];\n\n\t\t\t\t\t\t} else if ( typeof elem.removeAttribute !== core_strundefined ) {\n\t\t\t\t\t\t\telem.removeAttribute( internalKey );\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telem[ internalKey ] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcore_deletedIds.push( id );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\nvar iframe, getStyles, curCSS,\n\tralpha = /alpha\\([^)]*\\)/i,\n\tropacity = /opacity\\s*=\\s*([^)]*)/,\n\trposition = /^(top|right|bottom|left)$/,\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trmargin = /^margin/,\n\trnumsplit = new RegExp( \"^(\" + core_pnum + \")(.*)$\", \"i\" ),\n\trnumnonpx = new RegExp( \"^(\" + core_pnum + \")(?!px)[a-z%]+$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + core_pnum + \")\", \"i\" ),\n\telemdisplay = { BODY: \"block\" },\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: 0,\n\t\tfontWeight: 400\n\t},\n\n\tcssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ],\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// check for vendor prefixed names\n\tvar capName = name.charAt(0).toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction isHidden( elem, el ) {\n\t// isHidden might be called from jQuery#filter function;\n\t// in that case, element will be second argument\n\telem = el || elem;\n\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\", css_defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\n\t\t\tif ( !values[ index ] ) {\n\t\t\t\thidden = isHidden( elem );\n\n\t\t\t\tif ( display && display !== \"none\" || !hidden ) {\n\t\t\t\t\tjQuery._data( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn jQuery.access( this, function( elem, name, value ) {\n\t\t\tvar len, styles,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tvar bool = typeof state === \"boolean\";\n\n\t\treturn this.each(function() {\n\t\t\tif ( bool ? state : isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Exclude the following css properties to add px\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t// normalize float css property\n\t\t\"float\": jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that NaN and null values aren't set. See: #7116\n\t\t\tif ( value == null || type === \"number\" && isNaN( value ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n\t\t\t// but it would mean to define eight (for every problematic property) identical functions\n\t\t\tif ( !jQuery.support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\n\t\t\t\t// Wrapped to prevent IE from throwing errors when 'invalid' values are provided\n\t\t\t\t// Fixes bug #5509\n\t\t\t\ttry {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar num, val, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t//convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t},\n\n\t// A method for quickly swapping in/out CSS properties to get correct calculations\n\tswap: function( elem, options, callback, args ) {\n\t\tvar ret, name,\n\t\t\told = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\n\t\tret = callback.apply( elem, args || [] );\n\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\n\t\treturn ret;\n\t}\n});\n\n// NOTE: we've included the \"window\" in window.getComputedStyle\n// because jsdom on node.js will break without it.\nif ( window.getComputedStyle ) {\n\tgetStyles = function( elem ) {\n\t\treturn window.getComputedStyle( elem, null );\n\t};\n\n\tcurCSS = function( elem, name, _computed ) {\n\t\tvar width, minWidth, maxWidth,\n\t\t\tcomputed = _computed || getStyles( elem ),\n\n\t\t\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\t\t\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,\n\t\t\tstyle = elem.style;\n\n\t\tif ( computed ) {\n\n\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\tret = jQuery.style( elem, name );\n\t\t\t}\n\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// Chrome < 17 and Safari 5.0 uses \"computed value\" instead of \"used value\" for margin-right\n\t\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n} else if ( document.documentElement.currentStyle ) {\n\tgetStyles = function( elem ) {\n\t\treturn elem.currentStyle;\n\t};\n\n\tcurCSS = function( elem, name, _computed ) {\n\t\tvar left, rs, rsLeft,\n\t\t\tcomputed = _computed || getStyles( elem ),\n\t\t\tret = computed ? computed[ name ] : undefined,\n\t\t\tstyle = elem.style;\n\n\t\t// Avoid setting ret to empty string here\n\t\t// so we don't default to auto\n\t\tif ( ret == null && style && style[ name ] ) {\n\t\t\tret = style[ name ];\n\t\t}\n\n\t\t// From the awesome hack by Dean Edwards\n\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t// If we're not dealing with a regular pixel number\n\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\t// but not position css attributes, as those are proportional to the parent element instead\n\t\t// and we can't measure the parent instead because it might trigger a \"stacking dolls\" problem\n\t\tif ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\tleft = style.left;\n\t\t\trs = elem.runtimeStyle;\n\t\t\trsLeft = rs && rs.left;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tif ( rsLeft ) {\n\t\t\t\trs.left = elem.currentStyle.left;\n\t\t\t}\n\t\t\tstyle.left = name === \"fontSize\" ? \"1em\" : ret;\n\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.left = left;\n\t\t\tif ( rsLeft ) {\n\t\t\t\trs.left = rsLeft;\n\t\t\t}\n\t\t}\n\n\t\treturn ret === \"\" ? \"auto\" : ret;\n\t};\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// at this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\n// Try to determine the default display value of an element\nfunction css_defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = ( iframe ||\n\t\t\t\tjQuery(\"<iframe frameborder='0' width='0' height='0'/>\")\n\t\t\t\t.css( \"cssText\", \"display:block !important\" )\n\t\t\t).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;\n\t\t\tdoc.write(\"<!doctype html><html><body>\");\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\n\n// Called ONLY from within css_defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\t\tdisplay = jQuery.css( elem[0], \"display\" );\n\telem.remove();\n\treturn display;\n}\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\treturn elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, \"display\" ) ) ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\nif ( !jQuery.support.opacity ) {\n\tjQuery.cssHooks.opacity = {\n\t\tget: function( elem, computed ) {\n\t\t\t// IE uses filters for opacity\n\t\t\treturn ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\" ) ?\n\t\t\t\t( 0.01 * parseFloat( RegExp.$1 ) ) + \"\" :\n\t\t\t\tcomputed ? \"1\" : \"\";\n\t\t},\n\n\t\tset: function( elem, value ) {\n\t\t\tvar style = elem.style,\n\t\t\t\tcurrentStyle = elem.currentStyle,\n\t\t\t\topacity = jQuery.isNumeric( value ) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n\t\t\t\tfilter = currentStyle && currentStyle.filter || style.filter || \"\";\n\n\t\t\t// IE has trouble with opacity if it does not have layout\n\t\t\t// Force it by setting the zoom level\n\t\t\tstyle.zoom = 1;\n\n\t\t\t// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n\t\t\t// if value === \"\", then remove inline opacity #12685\n\t\t\tif ( ( value >= 1 || value === \"\" ) &&\n\t\t\t\t\tjQuery.trim( filter.replace( ralpha, \"\" ) ) === \"\" &&\n\t\t\t\t\tstyle.removeAttribute ) {\n\n\t\t\t\t// Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n\t\t\t\t// if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n\t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...\n\t\t\t\tstyle.removeAttribute( \"filter\" );\n\n\t\t\t\t// if there is no filter style applied in a css rule or unset inline opacity, we are done\n\t\t\t\tif ( value === \"\" || currentStyle && !currentStyle.filter ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// otherwise, set new filter values\n\t\t\tstyle.filter = ralpha.test( filter ) ?\n\t\t\t\tfilter.replace( ralpha, opacity ) :\n\t\t\t\tfilter + \" \" + opacity;\n\t\t}\n\t};\n}\n\n// These hooks cannot be added until DOM ready because the support test\n// for it is not run until after DOM ready\njQuery(function() {\n\tif ( !jQuery.support.reliableMarginRight ) {\n\t\tjQuery.cssHooks.marginRight = {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t\t// Work around by temporarily setting element display to inline-block\n\t\t\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// getComputedStyle returns percent when specified for top/left/bottom/right\n\t// rather than make the css module depend on the offset module, we just check for it here\n\tif ( !jQuery.support.pixelPosition && jQuery.fn.position ) {\n\t\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\t\t\tjQuery.cssHooks[ prop ] = {\n\t\t\t\tget: function( elem, computed ) {\n\t\t\t\t\tif ( computed ) {\n\t\t\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\t\t\tcomputed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n});\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.hidden = function( elem ) {\n\t\t// Support: Opera <= 12.12\n\t\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\t\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||\n\t\t\t(!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, \"display\" )) === \"none\");\n\t};\n\n\tjQuery.expr.filters.visible = function( elem ) {\n\t\treturn !jQuery.expr.filters.hidden( elem );\n\t};\n}\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function(){\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function(){\n\t\t\tvar type = this.type;\n\t\t\t// Use .is(\":disabled\") so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !manipulation_rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ){\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ){\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n//Serialize an array of form elements or a set of\n//key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.hover = function( fnOver, fnOut ) {\n\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n};\nvar\n\t// Document location\n\tajaxLocParts,\n\tajaxLocation,\n\tajax_nonce = jQuery.now(),\n\n\tajax_rquery = /\\?/,\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg, // IE leaves an \\r character at EOL\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t// Keep a copy of the old load method\n\t_load = jQuery.fn.load,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\");\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\ntry {\n\tajaxLocation = location.href;\n} catch( e ) {\n\t// Use the href attribute of an A element\n\t// since IE will modify it given document.location\n\tajaxLocation = document.createElement( \"a\" );\n\tajaxLocation.href = \"\";\n\tajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar deep, key,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, response, type,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = url.slice( off, url.length );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ){\n\tjQuery.fn[ type ] = function( fn ){\n\t\treturn this.on( type, fn );\n\t};\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": window.String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar // Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers as string\n\t\t\tresponseHeadersString,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\ttransport,\n\t\t\t// Response headers\n\t\t\tresponseHeaders,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" ).replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( core_rnotwhite ) || [\"\"];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? 80 : 443 ) ) !=\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? 80 : 443 ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\tfireGlobals = s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + ajax_nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ajax_nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( status >= 200 && status < 300 || status === 304 ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 ) {\n\t\t\t\t\tisSuccess = true;\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tisSuccess = true;\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tisSuccess = ajaxConvert( s, response );\n\t\t\t\t\tstatusText = isSuccess.state;\n\t\t\t\t\tsuccess = isSuccess.data;\n\t\t\t\t\terror = isSuccess.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We extract error from statusText\n\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t}\n});\n\n/* Handles responses to an ajax request:\n * - sets all responseXXX fields accordingly\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\tvar firstDataType, ct, finalDataType, type,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes,\n\t\tresponseFields = s.responseFields;\n\n\t// Fill responseXXX fields\n\tfor ( type in responseFields ) {\n\t\tif ( type in responses ) {\n\t\t\tjqXHR[ responseFields[type] ] = responses[ type ];\n\t\t}\n\t}\n\n\t// Remove auto dataType and get content-type in the process\n\twhile( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n// Chain conversions given the request and the original response\nfunction ajaxConvert( s, response ) {\n\tvar conv2, current, conv, tmp,\n\t\tconverters = {},\n\t\ti = 0,\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice(),\n\t\tprev = dataTypes[ 0 ];\n\n\t// Apply the dataFilter if provided\n\tif ( s.dataFilter ) {\n\t\tresponse = s.dataFilter( response, s.dataType );\n\t}\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\t// Convert to each sequential dataType, tolerating list modification\n\tfor ( ; (current = dataTypes[++i]); ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\tif ( current !== \"*\" ) {\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\tif ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split(\" \");\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.splice( i--, 0, current );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[\"throws\"] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update prev for next iteration\n\t\t\tprev = current;\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and global\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t\ts.global = false;\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function(s) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\n\t\tvar script,\n\t\t\thead = document.head || jQuery(\"head\")[0] || document.documentElement;\n\n\t\treturn {\n\n\t\t\tsend: function( _, callback ) {\n\n\t\t\t\tscript = document.createElement(\"script\");\n\n\t\t\t\tscript.async = true;\n\n\t\t\t\tif ( s.scriptCharset ) {\n\t\t\t\t\tscript.charset = s.scriptCharset;\n\t\t\t\t}\n\n\t\t\t\tscript.src = s.url;\n\n\t\t\t\t// Attach handlers for all browsers\n\t\t\t\tscript.onload = script.onreadystatechange = function( _, isAbort ) {\n\n\t\t\t\t\tif ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n\t\t\t\t\t\t// Handle memory leak in IE\n\t\t\t\t\t\tscript.onload = script.onreadystatechange = null;\n\n\t\t\t\t\t\t// Remove the script\n\t\t\t\t\t\tif ( script.parentNode ) {\n\t\t\t\t\t\t\tscript.parentNode.removeChild( script );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Dereference the script\n\t\t\t\t\t\tscript = null;\n\n\t\t\t\t\t\t// Callback if not abort\n\t\t\t\t\t\tif ( !isAbort ) {\n\t\t\t\t\t\t\tcallback( 200, \"success\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\thead.insertBefore( script, head.firstChild );\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( script ) {\n\t\t\t\t\tscript.onload( undefined, true );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( ajax_nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( ajax_rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\nvar xhrCallbacks, xhrSupported,\n\txhrId = 0,\n\t// #5280: Internet Explorer will keep connections alive if we don't abort on unload\n\txhrOnUnloadAbort = window.ActiveXObject && function() {\n\t\t// Abort all pending requests\n\t\tvar key;\n\t\tfor ( key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]( undefined, true );\n\t\t}\n\t};\n\n// Functions to create xhrs\nfunction createStandardXHR() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch( e ) {}\n}\n\nfunction createActiveXHR() {\n\ttry {\n\t\treturn new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n\t} catch( e ) {}\n}\n\n// Create the request object\n// (This is still attached to ajaxSettings for backward compatibility)\njQuery.ajaxSettings.xhr = window.ActiveXObject ?\n\t/* Microsoft failed to properly\n\t * implement the XMLHttpRequest in IE7 (can't request local files),\n\t * so we use the ActiveXObject when it is available\n\t * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\n\t * we need a fallback.\n\t */\n\tfunction() {\n\t\treturn !this.isLocal && createStandardXHR() || createActiveXHR();\n\t} :\n\t// For all other browsers, use the standard XMLHttpRequest object\n\tcreateStandardXHR;\n\n// Determine support properties\nxhrSupported = jQuery.ajaxSettings.xhr();\njQuery.support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nxhrSupported = jQuery.support.ajax = !!xhrSupported;\n\n// Create transport if the browser can provide an xhr\nif ( xhrSupported ) {\n\n\tjQuery.ajaxTransport(function( s ) {\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif ( !s.crossDomain || jQuery.support.cors ) {\n\n\t\t\tvar callback;\n\n\t\t\treturn {\n\t\t\t\tsend: function( headers, complete ) {\n\n\t\t\t\t\t// Get a new xhr\n\t\t\t\t\tvar handle, i,\n\t\t\t\t\t\txhr = s.xhr();\n\n\t\t\t\t\t// Open the socket\n\t\t\t\t\t// Passing null username, generates a login popup on Opera (#2865)\n\t\t\t\t\tif ( s.username ) {\n\t\t\t\t\t\txhr.open( s.type, s.url, s.async, s.username, s.password );\n\t\t\t\t\t} else {\n\t\t\t\t\t\txhr.open( s.type, s.url, s.async );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif ( s.xhrFields ) {\n\t\t\t\t\t\tfor ( i in s.xhrFields ) {\n\t\t\t\t\t\t\txhr[ i ] = s.xhrFields[ i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif ( s.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\txhr.overrideMimeType( s.mimeType );\n\t\t\t\t\t}\n\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif ( !s.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Need an extra try/catch for cross domain requests in Firefox 3\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch( err ) {}\n\n\t\t\t\t\t// Do send the request\n\t\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\t\txhr.send( ( s.hasContent && s.data ) || null );\n\n\t\t\t\t\t// Listener\n\t\t\t\t\tcallback = function( _, isAbort ) {\n\t\t\t\t\t\tvar status, responseHeaders, statusText, responses;\n\n\t\t\t\t\t\t// Firefox throws exceptions when accessing properties\n\t\t\t\t\t\t// of an xhr when a network error occurred\n\t\t\t\t\t\t// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\t// Was never called and is aborted or complete\n\t\t\t\t\t\t\tif ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n\n\t\t\t\t\t\t\t\t// Only called once\n\t\t\t\t\t\t\t\tcallback = undefined;\n\n\t\t\t\t\t\t\t\t// Do not keep as active anymore\n\t\t\t\t\t\t\t\tif ( handle ) {\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = jQuery.noop;\n\t\t\t\t\t\t\t\t\tif ( xhrOnUnloadAbort ) {\n\t\t\t\t\t\t\t\t\t\tdelete xhrCallbacks[ handle ];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// If it's an abort\n\t\t\t\t\t\t\t\tif ( isAbort ) {\n\t\t\t\t\t\t\t\t\t// Abort it manually if needed\n\t\t\t\t\t\t\t\t\tif ( xhr.readyState !== 4 ) {\n\t\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tresponses = {};\n\t\t\t\t\t\t\t\t\tstatus = xhr.status;\n\t\t\t\t\t\t\t\t\tresponseHeaders = xhr.getAllResponseHeaders();\n\n\t\t\t\t\t\t\t\t\t// When requesting binary data, IE6-9 will throw an exception\n\t\t\t\t\t\t\t\t\t// on any attempt to access responseText (#11426)\n\t\t\t\t\t\t\t\t\tif ( typeof xhr.responseText === \"string\" ) {\n\t\t\t\t\t\t\t\t\t\tresponses.text = xhr.responseText;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Firefox throws an exception when accessing\n\t\t\t\t\t\t\t\t\t// statusText for faulty cross-domain requests\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tstatusText = xhr.statusText;\n\t\t\t\t\t\t\t\t\t} catch( e ) {\n\t\t\t\t\t\t\t\t\t\t// We normalize with Webkit giving an empty statusText\n\t\t\t\t\t\t\t\t\t\tstatusText = \"\";\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Filter status for non standard behaviors\n\n\t\t\t\t\t\t\t\t\t// If the request is local and we have data: assume a success\n\t\t\t\t\t\t\t\t\t// (success with no data won't get notified, that's the best we\n\t\t\t\t\t\t\t\t\t// can do given current implementations)\n\t\t\t\t\t\t\t\t\tif ( !status && s.isLocal && !s.crossDomain ) {\n\t\t\t\t\t\t\t\t\t\tstatus = responses.text ? 200 : 404;\n\t\t\t\t\t\t\t\t\t// IE - #1450: sometimes returns 1223 when it should be 204\n\t\t\t\t\t\t\t\t\t} else if ( status === 1223 ) {\n\t\t\t\t\t\t\t\t\t\tstatus = 204;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch( firefoxAccessException ) {\n\t\t\t\t\t\t\tif ( !isAbort ) {\n\t\t\t\t\t\t\t\tcomplete( -1, firefoxAccessException );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Call complete if needed\n\t\t\t\t\t\tif ( responses ) {\n\t\t\t\t\t\t\tcomplete( status, statusText, responses, responseHeaders );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( !s.async ) {\n\t\t\t\t\t\t// if we're in sync mode we fire the callback\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t} else if ( xhr.readyState === 4 ) {\n\t\t\t\t\t\t// (IE6 & IE7) if it's in cache and has been\n\t\t\t\t\t\t// retrieved directly we need to fire the callback\n\t\t\t\t\t\tsetTimeout( callback );\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandle = ++xhrId;\n\t\t\t\t\t\tif ( xhrOnUnloadAbort ) {\n\t\t\t\t\t\t\t// Create the active xhrs callbacks list if needed\n\t\t\t\t\t\t\t// and attach the unload handler\n\t\t\t\t\t\t\tif ( !xhrCallbacks ) {\n\t\t\t\t\t\t\t\txhrCallbacks = {};\n\t\t\t\t\t\t\t\tjQuery( window ).unload( xhrOnUnloadAbort );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Add to list of active xhrs callbacks\n\t\t\t\t\t\t\txhrCallbacks[ handle ] = callback;\n\t\t\t\t\t\t}\n\t\t\t\t\t\txhr.onreadystatechange = callback;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback( undefined, true );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n}\nvar fxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + core_pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [function( prop, value ) {\n\t\t\tvar end, unit,\n\t\t\t\ttween = this.createTween( prop, value ),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tstart = +target || 0,\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( parts ) {\n\t\t\t\tend = +parts[2];\n\t\t\t\tunit = parts[3] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\n\t\t\t\t// We need to compute starting value\n\t\t\t\tif ( unit !== \"px\" && start ) {\n\t\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\t\t// Prefer the current property, because this process will be trivial if it uses the same units\n\t\t\t\t\t// Fallback to end or a simple constant\n\t\t\t\t\tstart = jQuery.css( tween.elem, prop, true ) || end || 1;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\t\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\t\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t\t// Adjust and apply\n\t\t\t\t\t\tstart = start / scale;\n\t\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t\t}\n\n\t\t\t\ttween.unit = unit;\n\t\t\t\ttween.start = start;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;\n\t\t\t}\n\t\t\treturn tween;\n\t\t}]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\nfunction createTweens( animation, props ) {\n\tjQuery.each( props, function( prop, value ) {\n\t\tvar collection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\t\tindex = 0,\n\t\t\tlength = collection.length;\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tif ( collection[ index ].call( animation, prop, value ) ) {\n\n\t\t\t\t// we're done with this property\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// resolve when we played the last frame\n\t\t\t\t// otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tcreateTweens( animation, props );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar value, name, index, easing, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/*jshint validthis:true */\n\tvar prop, index, length,\n\t\tvalue, dataShow, toggle,\n\t\ttween, hooks, oldfire,\n\t\tanim = this,\n\t\tstyle = elem.style,\n\t\torig = {},\n\t\thandled = [],\n\t\thidden = elem.nodeType && isHidden( elem );\n\n\t// handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t// before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE does not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tif ( jQuery.css( elem, \"display\" ) === \"inline\" &&\n\t\t\t\tjQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t// inline-level elements accept inline-block;\n\t\t\t// block-level elements need to be inline with layout\n\t\t\tif ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === \"inline\" ) {\n\t\t\t\tstyle.display = \"inline-block\";\n\n\t\t\t} else {\n\t\t\t\tstyle.zoom = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tif ( !jQuery.support.shrinkWrapBlocks ) {\n\t\t\tanim.always(function() {\n\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t\t});\n\t\t}\n\t}\n\n\n\t// show/hide pass\n\tfor ( index in props ) {\n\t\tvalue = props[ index ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ index ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thandled.push( index );\n\t\t}\n\t}\n\n\tlength = handled.length;\n\tif ( length ) {\n\t\tdataShow = jQuery._data( elem, \"fxshow\" ) || jQuery._data( elem, \"fxshow\", {} );\n\t\tif ( \"hidden\" in dataShow ) {\n\t\t\thidden = dataShow.hidden;\n\t\t}\n\n\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\t\t\tjQuery._removeData( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( index = 0 ; index < length ; index++ ) {\n\t\t\tprop = handled[ index ];\n\t\t\ttween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );\n\t\t\torig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t// available and use plain properties where available\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Remove in 2.0 - this supports IE8's panic based approach\n// to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\t\t\t\tdoAnimation.finish = function() {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t};\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || jQuery._data( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = jQuery._data( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t// but only if they were gotoEnd\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = jQuery._data( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.cur && hooks.cur.finish ) {\n\t\t\t\thooks.cur.finish.call( this );\n\t\t\t}\n\n\t\t\t// look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\tattrs = { height: type },\n\t\ti = 0;\n\n\t// if we include width, step value is 1 to do all cssExpand values,\n\t// if we don't include width, step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth? 1 : 0;\n\tfor( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p*Math.PI ) / 2;\n\t}\n};\n\njQuery.timers = [];\njQuery.fx = Tween.prototype.init;\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ttimers = jQuery.timers,\n\t\ti = 0;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tif ( timer() && jQuery.timers.push( timer ) ) {\n\t\tjQuery.fx.start();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.animated = function( elem ) {\n\t\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n}\njQuery.fn.offset = function( options ) {\n\tif ( arguments.length ) {\n\t\treturn options === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function( i ) {\n\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t});\n\t}\n\n\tvar docElem, win,\n\t\tbox = { top: 0, left: 0 },\n\t\telem = this[ 0 ],\n\t\tdoc = elem && elem.ownerDocument;\n\n\tif ( !doc ) {\n\t\treturn;\n\t}\n\n\tdocElem = doc.documentElement;\n\n\t// Make sure it's not a disconnected DOM node\n\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\treturn box;\n\t}\n\n\t// If we don't have gBCR, just use 0,0 rather than error\n\t// BlackBerry 5, iOS 3 (original iPhone)\n\tif ( typeof elem.getBoundingClientRect !== core_strundefined ) {\n\t\tbox = elem.getBoundingClientRect();\n\t}\n\twin = getWindow( doc );\n\treturn {\n\t\ttop: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),\n\t\tleft: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )\n\t};\n};\n\njQuery.offset = {\n\n\tsetOffset: function( elem, options, i ) {\n\t\tvar position = jQuery.css( elem, \"position\" );\n\n\t\t// set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tvar curElem = jQuery( elem ),\n\t\t\tcurOffset = curElem.offset(),\n\t\t\tcurCSSTop = jQuery.css( elem, \"top\" ),\n\t\t\tcurCSSLeft = jQuery.css( elem, \"left\" ),\n\t\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) && jQuery.inArray(\"auto\", [curCSSTop, curCSSLeft]) > -1,\n\t\t\tprops = {}, curPosition = {}, curTop, curLeft;\n\n\t\t// need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\n\njQuery.fn.extend({\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\tparentOffset = { top: 0, left: 0 },\n\t\t\telem = this[ 0 ];\n\n\t\t// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// we assume that getBoundingClientRect is available when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top  += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\t// note: when an element has margin: auto the offsetLeft and marginLeft\n\t\t// are the same in Safari causing offset.left to incorrectly be 0\n\t\treturn {\n\t\t\ttop:  offset.top  - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true)\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || document.documentElement;\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\") === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\t\t\treturn offsetParent || document.documentElement;\n\t\t});\n\t}\n});\n\n\n// Create scrollLeft and scrollTop methods\njQuery.each( {scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\"}, function( method, prop ) {\n\tvar top = /Y/.test( prop );\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn jQuery.access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? (prop in win) ? win[ prop ] :\n\t\t\t\t\twin.document.documentElement[ method ] :\n\t\t\t\t\telem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : jQuery( win ).scrollLeft(),\n\t\t\t\t\ttop ? val : jQuery( win ).scrollTop()\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ?\n\t\telem :\n\t\telem.nodeType === 9 ?\n\t\t\telem.defaultView || elem.parentWindow :\n\t\t\tfalse;\n}\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn jQuery.access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest\n\t\t\t\t\t// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n// Limit scope pollution from any deprecated API\n// (function() {\n\n// })();\n// Expose jQuery to the global object\nwindow.jQuery = window.$ = jQuery;\n\n// Expose jQuery as an AMD module, but only for AMD loaders that\n// understand the issues with loading multiple versions of jQuery\n// in a page that all might call define(). The loader will indicate\n// they have special allowances for multiple jQuery versions by\n// specifying define.amd.jQuery = true. Register as a named module,\n// since jQuery can be concatenated with other files that may use define,\n// but not use a proper concatenation script that understands anonymous\n// AMD modules. A named AMD is safest and most robust way to register.\n// Lowercase jquery is used because AMD module names are derived from\n// file names, and jQuery is normally delivered in a lowercase file name.\n// Do this after creating the global so that if an AMD module wants to call\n// noConflict to hide this version of jQuery, it will work.\nif ( typeof define === \"function\" && define.amd && define.amd.jQuery ) {\n\tdefine( \"jquery\", [], function () { return jQuery; } );\n}\n\n})( window );\n","// Underscore.js 1.4.4\n// ===================\n\n// > http://underscorejs.org\n// > (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n// > Underscore may be freely distributed under the MIT license.\n\n// Baseline setup\n// --------------\n(function() {\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.4';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? null : [];\n    return _[first ? 'find' : 'filter'](obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function() {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function(func) {\n    var args = slice.call(arguments, 1);\n    return function() {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n","//     Backbone.js 1.0.0\n\n//     (c) 2010-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n\n(function(){\n\n  // Initial Setup\n  // -------------\n\n  // Save a reference to the global object (`window` in the browser, `exports`\n  // on the server).\n  var root = this;\n\n  // Save the previous value of the `Backbone` variable, so that it can be\n  // restored later on, if `noConflict` is used.\n  var previousBackbone = root.Backbone;\n\n  // Create local references to array methods we'll want to use later.\n  var array = [];\n  var push = array.push;\n  var slice = array.slice;\n  var splice = array.splice;\n\n  // The top-level namespace. All public Backbone classes and modules will\n  // be attached to this. Exported for both the browser and the server.\n  var Backbone;\n  if (typeof exports !== 'undefined') {\n    Backbone = exports;\n  } else {\n    Backbone = root.Backbone = {};\n  }\n\n  // Current version of the library. Keep in sync with `package.json`.\n  Backbone.VERSION = '1.0.0';\n\n  // Require Underscore, if we're on the server, and it's not already present.\n  var _ = root._;\n  if (!_ && (typeof require !== 'undefined')) _ = require('underscore');\n\n  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\n  // the `$` variable.\n  Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;\n\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n  // to its previous owner. Returns a reference to this Backbone object.\n  Backbone.noConflict = function() {\n    root.Backbone = previousBackbone;\n    return this;\n  };\n\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n  // will fake `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n  // set a `X-Http-Method-Override` header.\n  Backbone.emulateHTTP = false;\n\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n  // `application/json` requests ... will encode the body as\n  // `application/x-www-form-urlencoded` instead and will send the model in a\n  // form param named `model`.\n  Backbone.emulateJSON = false;\n\n  // Backbone.Events\n  // ---------------\n\n  // A module that can be mixed in to *any object* in order to provide it with\n  // custom events. You may bind with `on` or remove with `off` callback\n  // functions to an event; `trigger`-ing an event fires all callbacks in\n  // succession.\n  //\n  //     var object = {};\n  //     _.extend(object, Backbone.Events);\n  //     object.on('expand', function(){ alert('expanded'); });\n  //     object.trigger('expand');\n  //\n  var Events = Backbone.Events = {\n\n    // Bind an event to a `callback` function. Passing `\"all\"` will bind\n    // the callback to all events fired.\n    on: function(name, callback, context) {\n      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n      this._events || (this._events = {});\n      var events = this._events[name] || (this._events[name] = []);\n      events.push({callback: callback, context: context, ctx: context || this});\n      return this;\n    },\n\n    // Bind an event to only be triggered a single time. After the first time\n    // the callback is invoked, it will be removed.\n    once: function(name, callback, context) {\n      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n      var self = this;\n      var once = _.once(function() {\n        self.off(name, once);\n        callback.apply(this, arguments);\n      });\n      once._callback = callback;\n      return this.on(name, once, context);\n    },\n\n    // Remove one or many callbacks. If `context` is null, removes all\n    // callbacks with that function. If `callback` is null, removes all\n    // callbacks for the event. If `name` is null, removes all bound\n    // callbacks for all events.\n    off: function(name, callback, context) {\n      var retain, ev, events, names, i, l, j, k;\n      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n      if (!name && !callback && !context) {\n        this._events = {};\n        return this;\n      }\n\n      names = name ? [name] : _.keys(this._events);\n      for (i = 0, l = names.length; i < l; i++) {\n        name = names[i];\n        if (events = this._events[name]) {\n          this._events[name] = retain = [];\n          if (callback || context) {\n            for (j = 0, k = events.length; j < k; j++) {\n              ev = events[j];\n              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\n                  (context && context !== ev.context)) {\n                retain.push(ev);\n              }\n            }\n          }\n          if (!retain.length) delete this._events[name];\n        }\n      }\n\n      return this;\n    },\n\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    trigger: function(name) {\n      if (!this._events) return this;\n      var args = slice.call(arguments, 1);\n      if (!eventsApi(this, 'trigger', name, args)) return this;\n      var events = this._events[name];\n      var allEvents = this._events.all;\n      if (events) triggerEvents(events, args);\n      if (allEvents) triggerEvents(allEvents, arguments);\n      return this;\n    },\n\n    // Tell this object to stop listening to either specific events ... or\n    // to every object it's currently listening to.\n    stopListening: function(obj, name, callback) {\n      var listeners = this._listeners;\n      if (!listeners) return this;\n      var deleteListener = !name && !callback;\n      if (typeof name === 'object') callback = this;\n      if (obj) (listeners = {})[obj._listenerId] = obj;\n      for (var id in listeners) {\n        listeners[id].off(name, callback, this);\n        if (deleteListener) delete this._listeners[id];\n      }\n      return this;\n    }\n\n  };\n\n  // Regular expression used to split event strings.\n  var eventSplitter = /\\s+/;\n\n  // Implement fancy features of the Events API such as multiple event\n  // names `\"change blur\"` and jQuery-style event maps `{change: action}`\n  // in terms of the existing API.\n  var eventsApi = function(obj, action, name, rest) {\n    if (!name) return true;\n\n    // Handle event maps.\n    if (typeof name === 'object') {\n      for (var key in name) {\n        obj[action].apply(obj, [key, name[key]].concat(rest));\n      }\n      return false;\n    }\n\n    // Handle space separated event names.\n    if (eventSplitter.test(name)) {\n      var names = name.split(eventSplitter);\n      for (var i = 0, l = names.length; i < l; i++) {\n        obj[action].apply(obj, [names[i]].concat(rest));\n      }\n      return false;\n    }\n\n    return true;\n  };\n\n  // A difficult-to-believe, but optimized internal dispatch function for\n  // triggering events. Tries to keep the usual cases speedy (most internal\n  // Backbone events have 3 arguments).\n  var triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\n    }\n  };\n\n  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};\n\n  // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n  // listen to an event in another object ... keeping track of what it's\n  // listening to.\n  _.each(listenMethods, function(implementation, method) {\n    Events[method] = function(obj, name, callback) {\n      var listeners = this._listeners || (this._listeners = {});\n      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));\n      listeners[id] = obj;\n      if (typeof name === 'object') callback = this;\n      obj[implementation](name, callback, this);\n      return this;\n    };\n  });\n\n  // Aliases for backwards compatibility.\n  Events.bind   = Events.on;\n  Events.unbind = Events.off;\n\n  // Allow the `Backbone` object to serve as a global event bus, for folks who\n  // want global \"pubsub\" in a convenient place.\n  _.extend(Backbone, Events);\n\n  // Backbone.Model\n  // --------------\n\n  // Backbone **Models** are the basic data object in the framework --\n  // frequently representing a row in a table in a database on your server.\n  // A discrete chunk of data and a bunch of useful, related methods for\n  // performing computations and transformations on that data.\n\n  // Create a new model with the specified attributes. A client id (`cid`)\n  // is automatically generated and assigned for you.\n  var Model = Backbone.Model = function(attributes, options) {\n    var defaults;\n    var attrs = attributes || {};\n    options || (options = {});\n    this.cid = _.uniqueId('c');\n    this.attributes = {};\n    _.extend(this, _.pick(options, modelOptions));\n    if (options.parse) attrs = this.parse(attrs, options) || {};\n    if (defaults = _.result(this, 'defaults')) {\n      attrs = _.defaults({}, attrs, defaults);\n    }\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n  };\n\n  // A list of options to be attached directly to the model, if provided.\n  var modelOptions = ['url', 'urlRoot', 'collection'];\n\n  // Attach all inheritable methods to the Model prototype.\n  _.extend(Model.prototype, Events, {\n\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n\n    // The value returned during the last failed validation.\n    validationError: null,\n\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n    // CouchDB users may want to set this to `\"_id\"`.\n    idAttribute: 'id',\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Return a copy of the model's `attributes` object.\n    toJSON: function(options) {\n      return _.clone(this.attributes);\n    },\n\n    // Proxy `Backbone.sync` by default -- but override this if you need\n    // custom syncing semantics for *this* particular model.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Get the value of an attribute.\n    get: function(attr) {\n      return this.attributes[attr];\n    },\n\n    // Get the HTML-escaped value of an attribute.\n    escape: function(attr) {\n      return _.escape(this.get(attr));\n    },\n\n    // Returns `true` if the attribute contains a value that is not null\n    // or undefined.\n    has: function(attr) {\n      return this.get(attr) != null;\n    },\n\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\n    // the core primitive operation of a model, updating the data and notifying\n    // anyone who needs to know about the change in state. The heart of the beast.\n    set: function(key, val, options) {\n      var attr, attrs, unset, changes, silent, changing, prev, current;\n      if (key == null) return this;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      if (typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options || (options = {});\n\n      // Run validation.\n      if (!this._validate(attrs, options)) return false;\n\n      // Extract attributes and options.\n      unset           = options.unset;\n      silent          = options.silent;\n      changes         = [];\n      changing        = this._changing;\n      this._changing  = true;\n\n      if (!changing) {\n        this._previousAttributes = _.clone(this.attributes);\n        this.changed = {};\n      }\n      current = this.attributes, prev = this._previousAttributes;\n\n      // Check for changes of `id`.\n      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\n\n      // For each `set` attribute, update or delete the current value.\n      for (attr in attrs) {\n        val = attrs[attr];\n        if (!_.isEqual(current[attr], val)) changes.push(attr);\n        if (!_.isEqual(prev[attr], val)) {\n          this.changed[attr] = val;\n        } else {\n          delete this.changed[attr];\n        }\n        unset ? delete current[attr] : current[attr] = val;\n      }\n\n      // Trigger all relevant attribute changes.\n      if (!silent) {\n        if (changes.length) this._pending = true;\n        for (var i = 0, l = changes.length; i < l; i++) {\n          this.trigger('change:' + changes[i], this, current[changes[i]], options);\n        }\n      }\n\n      // You might be wondering why there's a `while` loop here. Changes can\n      // be recursively nested within `\"change\"` events.\n      if (changing) return this;\n      if (!silent) {\n        while (this._pending) {\n          this._pending = false;\n          this.trigger('change', this, options);\n        }\n      }\n      this._pending = false;\n      this._changing = false;\n      return this;\n    },\n\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n    // if the attribute doesn't exist.\n    unset: function(attr, options) {\n      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\n    },\n\n    // Clear all attributes on the model, firing `\"change\"`.\n    clear: function(options) {\n      var attrs = {};\n      for (var key in this.attributes) attrs[key] = void 0;\n      return this.set(attrs, _.extend({}, options, {unset: true}));\n    },\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged: function(attr) {\n      if (attr == null) return !_.isEmpty(this.changed);\n      return _.has(this.changed, attr);\n    },\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes: function(diff) {\n      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\n      var val, changed = false;\n      var old = this._changing ? this._previousAttributes : this.attributes;\n      for (var attr in diff) {\n        if (_.isEqual(old[attr], (val = diff[attr]))) continue;\n        (changed || (changed = {}))[attr] = val;\n      }\n      return changed;\n    },\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous: function(attr) {\n      if (attr == null || !this._previousAttributes) return null;\n      return this._previousAttributes[attr];\n    },\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes: function() {\n      return _.clone(this._previousAttributes);\n    },\n\n    // Fetch the model from the server. If the server's representation of the\n    // model differs from its current attributes, they will be overridden,\n    // triggering a `\"change\"` event.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      if (options.parse === void 0) options.parse = true;\n      var model = this;\n      var success = options.success;\n      options.success = function(resp) {\n        if (!model.set(model.parse(resp, options), options)) return false;\n        if (success) success(model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Set a hash of model attributes, and sync the model to the server.\n    // If the server returns an attributes hash that differs, the model's\n    // state will be `set` again.\n    save: function(key, val, options) {\n      var attrs, method, xhr, attributes = this.attributes;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      if (key == null || typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.\n      if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;\n\n      options = _.extend({validate: true}, options);\n\n      // Do not persist invalid models.\n      if (!this._validate(attrs, options)) return false;\n\n      // Set temporary attributes if `{wait: true}`.\n      if (attrs && options.wait) {\n        this.attributes = _.extend({}, attributes, attrs);\n      }\n\n      // After a successful server-side save, the client is (optionally)\n      // updated with the server-side state.\n      if (options.parse === void 0) options.parse = true;\n      var model = this;\n      var success = options.success;\n      options.success = function(resp) {\n        // Ensure attributes are restored during synchronous saves.\n        model.attributes = attributes;\n        var serverAttrs = model.parse(resp, options);\n        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);\n        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {\n          return false;\n        }\n        if (success) success(model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n\n      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n      if (method === 'patch') options.attrs = attrs;\n      xhr = this.sync(method, this, options);\n\n      // Restore attributes.\n      if (attrs && options.wait) this.attributes = attributes;\n\n      return xhr;\n    },\n\n    // Destroy this model on the server if it was already persisted.\n    // Optimistically removes the model from its collection, if it has one.\n    // If `wait: true` is passed, waits for the server to respond before removal.\n    destroy: function(options) {\n      options = options ? _.clone(options) : {};\n      var model = this;\n      var success = options.success;\n\n      var destroy = function() {\n        model.trigger('destroy', model, model.collection, options);\n      };\n\n      options.success = function(resp) {\n        if (options.wait || model.isNew()) destroy();\n        if (success) success(model, resp, options);\n        if (!model.isNew()) model.trigger('sync', model, resp, options);\n      };\n\n      if (this.isNew()) {\n        options.success();\n        return false;\n      }\n      wrapError(this, options);\n\n      var xhr = this.sync('delete', this, options);\n      if (!options.wait) destroy();\n      return xhr;\n    },\n\n    // Default URL for the model's representation on the server -- if you're\n    // using Backbone's restful methods, override this to change the endpoint\n    // that will be called.\n    url: function() {\n      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();\n      if (this.isNew()) return base;\n      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);\n    },\n\n    // **parse** converts a response into the hash of attributes to be `set` on\n    // the model. The default implementation is just to pass the response along.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new model with identical attributes to this one.\n    clone: function() {\n      return new this.constructor(this.attributes);\n    },\n\n    // A model is new if it has never been saved to the server, and lacks an id.\n    isNew: function() {\n      return this.id == null;\n    },\n\n    // Check if the model is currently in a valid state.\n    isValid: function(options) {\n      return this._validate({}, _.extend(options || {}, { validate: true }));\n    },\n\n    // Run validation against the next complete set of model attributes,\n    // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n    _validate: function(attrs, options) {\n      if (!options.validate || !this.validate) return true;\n      attrs = _.extend({}, this.attributes, attrs);\n      var error = this.validationError = this.validate(attrs, options) || null;\n      if (!error) return true;\n      this.trigger('invalid', this, error, _.extend(options || {}, {validationError: error}));\n      return false;\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Model.\n  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];\n\n  // Mix in each Underscore method as a proxy to `Model#attributes`.\n  _.each(modelMethods, function(method) {\n    Model.prototype[method] = function() {\n      var args = slice.call(arguments);\n      args.unshift(this.attributes);\n      return _[method].apply(_, args);\n    };\n  });\n\n  // Backbone.Collection\n  // -------------------\n\n  // If models tend to represent a single row of data, a Backbone Collection is\n  // more analagous to a table full of data ... or a small slice or page of that\n  // table, or a collection of rows that belong together for a particular reason\n  // -- all of the messages in this particular folder, all of the documents\n  // belonging to this particular author, and so on. Collections maintain\n  // indexes of their models, both in order, and for lookup by `id`.\n\n  // Create a new **Collection**, perhaps to contain a specific type of `model`.\n  // If a `comparator` is specified, the Collection will maintain\n  // its models in sort order, as they're added and removed.\n  var Collection = Backbone.Collection = function(models, options) {\n    options || (options = {});\n    if (options.url) this.url = options.url;\n    if (options.model) this.model = options.model;\n    if (options.comparator !== void 0) this.comparator = options.comparator;\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, _.extend({silent: true}, options));\n  };\n\n  // Default options for `Collection#set`.\n  var setOptions = {add: true, remove: true, merge: true};\n  var addOptions = {add: true, merge: false, remove: false};\n\n  // Define the Collection's inheritable methods.\n  _.extend(Collection.prototype, Events, {\n\n    // The default model for a collection is just a **Backbone.Model**.\n    // This should be overridden in most cases.\n    model: Model,\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // The JSON representation of a Collection is an array of the\n    // models' attributes.\n    toJSON: function(options) {\n      return this.map(function(model){ return model.toJSON(options); });\n    },\n\n    // Proxy `Backbone.sync` by default.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Add a model, or list of models to the set.\n    add: function(models, options) {\n      return this.set(models, _.defaults(options || {}, addOptions));\n    },\n\n    // Remove a model, or a list of models from the set.\n    remove: function(models, options) {\n      models = _.isArray(models) ? models.slice() : [models];\n      options || (options = {});\n      var i, l, index, model;\n      for (i = 0, l = models.length; i < l; i++) {\n        model = this.get(models[i]);\n        if (!model) continue;\n        delete this._byId[model.id];\n        delete this._byId[model.cid];\n        index = this.indexOf(model);\n        this.models.splice(index, 1);\n        this.length--;\n        if (!options.silent) {\n          options.index = index;\n          model.trigger('remove', model, this, options);\n        }\n        this._removeReference(model);\n      }\n      return this;\n    },\n\n    // Update a collection by `set`-ing a new list of models, adding new ones,\n    // removing models that are no longer present, and merging models that\n    // already exist in the collection, as necessary. Similar to **Model#set**,\n    // the core operation for updating the data contained by the collection.\n    set: function(models, options) {\n      options = _.defaults(options || {}, setOptions);\n      if (options.parse) models = this.parse(models, options);\n      if (!_.isArray(models)) models = models ? [models] : [];\n      var i, l, model, attrs, existing, sort;\n      var at = options.at;\n      var sortable = this.comparator && (at == null) && options.sort !== false;\n      var sortAttr = _.isString(this.comparator) ? this.comparator : null;\n      var toAdd = [], toRemove = [], modelMap = {};\n\n      // Turn bare objects into model references, and prevent invalid models\n      // from being added.\n      for (i = 0, l = models.length; i < l; i++) {\n        if (!(model = this._prepareModel(models[i], options))) continue;\n\n        // If a duplicate is found, prevent it from being added and\n        // optionally merge it into the existing model.\n        if (existing = this.get(model)) {\n          if (options.remove) modelMap[existing.cid] = true;\n          if (options.merge) {\n            existing.set(model.attributes, options);\n            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;\n          }\n\n        // This is a new model, push it to the `toAdd` list.\n        } else if (options.add) {\n          toAdd.push(model);\n\n          // Listen to added models' events, and index models for lookup by\n          // `id` and by `cid`.\n          model.on('all', this._onModelEvent, this);\n          this._byId[model.cid] = model;\n          if (model.id != null) this._byId[model.id] = model;\n        }\n      }\n\n      // Remove nonexistent models if appropriate.\n      if (options.remove) {\n        for (i = 0, l = this.length; i < l; ++i) {\n          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);\n        }\n        if (toRemove.length) this.remove(toRemove, options);\n      }\n\n      // See if sorting is needed, update `length` and splice in new models.\n      if (toAdd.length) {\n        if (sortable) sort = true;\n        this.length += toAdd.length;\n        if (at != null) {\n          splice.apply(this.models, [at, 0].concat(toAdd));\n        } else {\n          push.apply(this.models, toAdd);\n        }\n      }\n\n      // Silently sort the collection if appropriate.\n      if (sort) this.sort({silent: true});\n\n      if (options.silent) return this;\n\n      // Trigger `add` events.\n      for (i = 0, l = toAdd.length; i < l; i++) {\n        (model = toAdd[i]).trigger('add', model, this, options);\n      }\n\n      // Trigger `sort` if the collection was sorted.\n      if (sort) this.trigger('sort', this, options);\n      return this;\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any granular `add` or `remove` events. Fires `reset` when finished.\n    // Useful for bulk operations and optimizations.\n    reset: function(models, options) {\n      options || (options = {});\n      for (var i = 0, l = this.models.length; i < l; i++) {\n        this._removeReference(this.models[i]);\n      }\n      options.previousModels = this.models;\n      this._reset();\n      this.add(models, _.extend({silent: true}, options));\n      if (!options.silent) this.trigger('reset', this, options);\n      return this;\n    },\n\n    // Add a model to the end of the collection.\n    push: function(model, options) {\n      model = this._prepareModel(model, options);\n      this.add(model, _.extend({at: this.length}, options));\n      return model;\n    },\n\n    // Remove a model from the end of the collection.\n    pop: function(options) {\n      var model = this.at(this.length - 1);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Add a model to the beginning of the collection.\n    unshift: function(model, options) {\n      model = this._prepareModel(model, options);\n      this.add(model, _.extend({at: 0}, options));\n      return model;\n    },\n\n    // Remove a model from the beginning of the collection.\n    shift: function(options) {\n      var model = this.at(0);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Slice out a sub-array of models from the collection.\n    slice: function(begin, end) {\n      return this.models.slice(begin, end);\n    },\n\n    // Get a model from the set by id.\n    get: function(obj) {\n      if (obj == null) return void 0;\n      return this._byId[obj.id != null ? obj.id : obj.cid || obj];\n    },\n\n    // Get the model at the given index.\n    at: function(index) {\n      return this.models[index];\n    },\n\n    // Return models with matching attributes. Useful for simple cases of\n    // `filter`.\n    where: function(attrs, first) {\n      if (_.isEmpty(attrs)) return first ? void 0 : [];\n      return this[first ? 'find' : 'filter'](function(model) {\n        for (var key in attrs) {\n          if (attrs[key] !== model.get(key)) return false;\n        }\n        return true;\n      });\n    },\n\n    // Return the first model with matching attributes. Useful for simple cases\n    // of `find`.\n    findWhere: function(attrs) {\n      return this.where(attrs, true);\n    },\n\n    // Force the collection to re-sort itself. You don't need to call this under\n    // normal circumstances, as the set will maintain sort order as each item\n    // is added.\n    sort: function(options) {\n      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');\n      options || (options = {});\n\n      // Run sort based on type of `comparator`.\n      if (_.isString(this.comparator) || this.comparator.length === 1) {\n        this.models = this.sortBy(this.comparator, this);\n      } else {\n        this.models.sort(_.bind(this.comparator, this));\n      }\n\n      if (!options.silent) this.trigger('sort', this, options);\n      return this;\n    },\n\n    // Figure out the smallest index at which a model should be inserted so as\n    // to maintain order.\n    sortedIndex: function(model, value, context) {\n      value || (value = this.comparator);\n      var iterator = _.isFunction(value) ? value : function(model) {\n        return model.get(value);\n      };\n      return _.sortedIndex(this.models, model, iterator, context);\n    },\n\n    // Pluck an attribute from each model in the collection.\n    pluck: function(attr) {\n      return _.invoke(this.models, 'get', attr);\n    },\n\n    // Fetch the default set of models for this collection, resetting the\n    // collection when they arrive. If `reset: true` is passed, the response\n    // data will be passed through the `reset` method instead of `set`.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      if (options.parse === void 0) options.parse = true;\n      var success = options.success;\n      var collection = this;\n      options.success = function(resp) {\n        var method = options.reset ? 'reset' : 'set';\n        collection[method](resp, options);\n        if (success) success(collection, resp, options);\n        collection.trigger('sync', collection, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Create a new instance of a model in this collection. Add the model to the\n    // collection immediately, unless `wait: true` is passed, in which case we\n    // wait for the server to agree.\n    create: function(model, options) {\n      options = options ? _.clone(options) : {};\n      if (!(model = this._prepareModel(model, options))) return false;\n      if (!options.wait) this.add(model, options);\n      var collection = this;\n      var success = options.success;\n      options.success = function(resp) {\n        if (options.wait) collection.add(model, options);\n        if (success) success(model, resp, options);\n      };\n      model.save(null, options);\n      return model;\n    },\n\n    // **parse** converts a response into a list of models to be added to the\n    // collection. The default implementation is just to pass it through.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new collection with an identical list of models as this one.\n    clone: function() {\n      return new this.constructor(this.models);\n    },\n\n    // Private method to reset all internal state. Called when the collection\n    // is first initialized or reset.\n    _reset: function() {\n      this.length = 0;\n      this.models = [];\n      this._byId  = {};\n    },\n\n    // Prepare a hash of attributes (or other model) to be added to this\n    // collection.\n    _prepareModel: function(attrs, options) {\n      if (attrs instanceof Model) {\n        if (!attrs.collection) attrs.collection = this;\n        return attrs;\n      }\n      options || (options = {});\n      options.collection = this;\n      var model = new this.model(attrs, options);\n      if (!model._validate(attrs, options)) {\n        this.trigger('invalid', this, attrs, options);\n        return false;\n      }\n      return model;\n    },\n\n    // Internal method to sever a model's ties to a collection.\n    _removeReference: function(model) {\n      if (this === model.collection) delete model.collection;\n      model.off('all', this._onModelEvent, this);\n    },\n\n    // Internal method called every time a model in the set fires an event.\n    // Sets need to update their indexes when models change ids. All other\n    // events simply proxy through. \"add\" and \"remove\" events that originate\n    // in other collections are ignored.\n    _onModelEvent: function(event, model, collection, options) {\n      if ((event === 'add' || event === 'remove') && collection !== this) return;\n      if (event === 'destroy') this.remove(model, options);\n      if (model && event === 'change:' + model.idAttribute) {\n        delete this._byId[model.previous(model.idAttribute)];\n        if (model.id != null) this._byId[model.id] = model;\n      }\n      this.trigger.apply(this, arguments);\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Collection.\n  // 90% of the core usefulness of Backbone Collections is actually implemented\n  // right here:\n  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',\n    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',\n    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',\n    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',\n    'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf',\n    'isEmpty', 'chain'];\n\n  // Mix in each Underscore method as a proxy to `Collection#models`.\n  _.each(methods, function(method) {\n    Collection.prototype[method] = function() {\n      var args = slice.call(arguments);\n      args.unshift(this.models);\n      return _[method].apply(_, args);\n    };\n  });\n\n  // Underscore methods that take a property name as an argument.\n  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];\n\n  // Use attributes instead of properties.\n  _.each(attributeMethods, function(method) {\n    Collection.prototype[method] = function(value, context) {\n      var iterator = _.isFunction(value) ? value : function(model) {\n        return model.get(value);\n      };\n      return _[method](this.models, iterator, context);\n    };\n  });\n\n  // Backbone.View\n  // -------------\n\n  // Backbone Views are almost more convention than they are actual code. A View\n  // is simply a JavaScript object that represents a logical chunk of UI in the\n  // DOM. This might be a single item, an entire list, a sidebar or panel, or\n  // even the surrounding frame which wraps your whole app. Defining a chunk of\n  // UI as a **View** allows you to define your DOM events declaratively, without\n  // having to worry about render order ... and makes it easy for the view to\n  // react to specific changes in the state of your models.\n\n  // Creating a Backbone.View creates its initial element outside of the DOM,\n  // if an existing element is not provided...\n  var View = Backbone.View = function(options) {\n    this.cid = _.uniqueId('view');\n    this._configure(options || {});\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n    this.delegateEvents();\n  };\n\n  // Cached regex to split keys for `delegate`.\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n  // List of view options to be merged as properties.\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\n\n  // Set up all inheritable **Backbone.View** properties and methods.\n  _.extend(View.prototype, Events, {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    // jQuery delegate for element lookup, scoped to DOM elements within the\n    // current view. This should be prefered to global lookups where possible.\n    $: function(selector) {\n      return this.$el.find(selector);\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function() {\n      return this;\n    },\n\n    // Remove this view by taking the element out of the DOM, and removing any\n    // applicable Backbone.Events listeners.\n    remove: function() {\n      this.$el.remove();\n      this.stopListening();\n      return this;\n    },\n\n    // Change the view's element (`this.el` property), including event\n    // re-delegation.\n    setElement: function(element, delegate) {\n      if (this.$el) this.undelegateEvents();\n      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);\n      this.el = this.$el[0];\n      if (delegate !== false) this.delegateEvents();\n      return this;\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save'\n    //       'click .open':       function(e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    // This only works for delegate-able events: not `focus`, `blur`, and\n    // not `change`, `submit`, and `reset` in Internet Explorer.\n    delegateEvents: function(events) {\n      if (!(events || (events = _.result(this, 'events')))) return this;\n      this.undelegateEvents();\n      for (var key in events) {\n        var method = events[key];\n        if (!_.isFunction(method)) method = this[events[key]];\n        if (!method) continue;\n\n        var match = key.match(delegateEventSplitter);\n        var eventName = match[1], selector = match[2];\n        method = _.bind(method, this);\n        eventName += '.delegateEvents' + this.cid;\n        if (selector === '') {\n          this.$el.on(eventName, method);\n        } else {\n          this.$el.on(eventName, selector, method);\n        }\n      }\n      return this;\n    },\n\n    // Clears all callbacks previously bound to the view with `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // Backbone views attached to the same DOM element.\n    undelegateEvents: function() {\n      this.$el.off('.delegateEvents' + this.cid);\n      return this;\n    },\n\n    // Performs the initial configuration of a View with a set of options.\n    // Keys with special meaning *(e.g. model, collection, id, className)* are\n    // attached directly to the view.  See `viewOptions` for an exhaustive\n    // list.\n    _configure: function(options) {\n      if (this.options) options = _.extend({}, _.result(this, 'options'), options);\n      _.extend(this, _.pick(options, viewOptions));\n      this.options = options;\n    },\n\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function() {\n      if (!this.el) {\n        var attrs = _.extend({}, _.result(this, 'attributes'));\n        if (this.id) attrs.id = _.result(this, 'id');\n        if (this.className) attrs['class'] = _.result(this, 'className');\n        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);\n        this.setElement($el, false);\n      } else {\n        this.setElement(_.result(this, 'el'), false);\n      }\n    }\n\n  });\n\n  // Backbone.sync\n  // -------------\n\n  // Override this function to change the manner in which Backbone persists\n  // models to the server. You will be passed the type of request, and the\n  // model in question. By default, makes a RESTful Ajax request\n  // to the model's `url()`. Some possible customizations could be:\n  //\n  // * Use `setTimeout` to batch rapid-fire updates into a single request.\n  // * Send up the models as XML instead of JSON.\n  // * Persist models via WebSockets instead of Ajax.\n  //\n  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n  // as `POST`, with a `_method` parameter containing the true HTTP method,\n  // as well as all requests with the body as `application/x-www-form-urlencoded`\n  // instead of `application/json` with the model in a param named `model`.\n  // Useful when interfacing with server-side languages like **PHP** that make\n  // it difficult to read the body of `PUT` requests.\n  Backbone.sync = function(method, model, options) {\n    var type = methodMap[method];\n\n    // Default options, unless specified.\n    _.defaults(options || (options = {}), {\n      emulateHTTP: Backbone.emulateHTTP,\n      emulateJSON: Backbone.emulateJSON\n    });\n\n    // Default JSON-request options.\n    var params = {type: type, dataType: 'json'};\n\n    // Ensure that we have a URL.\n    if (!options.url) {\n      params.url = _.result(model, 'url') || urlError();\n    }\n\n    // Ensure that we have the appropriate request data.\n    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\n      params.contentType = 'application/json';\n      params.data = JSON.stringify(options.attrs || model.toJSON(options));\n    }\n\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\n    if (options.emulateJSON) {\n      params.contentType = 'application/x-www-form-urlencoded';\n      params.data = params.data ? {model: params.data} : {};\n    }\n\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n    // And an `X-HTTP-Method-Override` header.\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\n      params.type = 'POST';\n      if (options.emulateJSON) params.data._method = type;\n      var beforeSend = options.beforeSend;\n      options.beforeSend = function(xhr) {\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\n        if (beforeSend) return beforeSend.apply(this, arguments);\n      };\n    }\n\n    // Don't process data on a non-GET request.\n    if (params.type !== 'GET' && !options.emulateJSON) {\n      params.processData = false;\n    }\n\n    // If we're sending a `PATCH` request, and we're in an old Internet Explorer\n    // that still has ActiveX enabled by default, override jQuery to use that\n    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.\n    if (params.type === 'PATCH' && window.ActiveXObject &&\n          !(window.external && window.external.msActiveXFilteringEnabled)) {\n      params.xhr = function() {\n        return new ActiveXObject(\"Microsoft.XMLHTTP\");\n      };\n    }\n\n    // Make the request, allowing the user to override any Ajax options.\n    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\n    model.trigger('request', model, xhr, options);\n    return xhr;\n  };\n\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n  var methodMap = {\n    'create': 'POST',\n    'update': 'PUT',\n    'patch':  'PATCH',\n    'delete': 'DELETE',\n    'read':   'GET'\n  };\n\n  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n  // Override this if you'd like to use a different library.\n  Backbone.ajax = function() {\n    return Backbone.$.ajax.apply(Backbone.$, arguments);\n  };\n\n  // Backbone.Router\n  // ---------------\n\n  // Routers map faux-URLs to actions, and fire events when routes are\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\n  var Router = Backbone.Router = function(options) {\n    options || (options = {});\n    if (options.routes) this.routes = options.routes;\n    this._bindRoutes();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regular expressions for matching named param parts and splatted\n  // parts of route strings.\n  var optionalParam = /\\((.*?)\\)/g;\n  var namedParam    = /(\\(\\?)?:\\w+/g;\n  var splatParam    = /\\*\\w+/g;\n  var escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n  // Set up all inheritable **Backbone.Router** properties and methods.\n  _.extend(Router.prototype, Events, {\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Manually bind a single named route to a callback. For example:\n    //\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\n    //       ...\n    //     });\n    //\n    route: function(route, name, callback) {\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\n      if (_.isFunction(name)) {\n        callback = name;\n        name = '';\n      }\n      if (!callback) callback = this[name];\n      var router = this;\n      Backbone.history.route(route, function(fragment) {\n        var args = router._extractParameters(route, fragment);\n        callback && callback.apply(router, args);\n        router.trigger.apply(router, ['route:' + name].concat(args));\n        router.trigger('route', name, args);\n        Backbone.history.trigger('route', router, name, args);\n      });\n      return this;\n    },\n\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\n    navigate: function(fragment, options) {\n      Backbone.history.navigate(fragment, options);\n      return this;\n    },\n\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\n    // order of the routes here to support behavior where the most general\n    // routes can be defined at the bottom of the route map.\n    _bindRoutes: function() {\n      if (!this.routes) return;\n      this.routes = _.result(this, 'routes');\n      var route, routes = _.keys(this.routes);\n      while ((route = routes.pop()) != null) {\n        this.route(route, this.routes[route]);\n      }\n    },\n\n    // Convert a route string into a regular expression, suitable for matching\n    // against the current location hash.\n    _routeToRegExp: function(route) {\n      route = route.replace(escapeRegExp, '\\\\$&')\n                   .replace(optionalParam, '(?:$1)?')\n                   .replace(namedParam, function(match, optional){\n                     return optional ? match : '([^\\/]+)';\n                   })\n                   .replace(splatParam, '(.*?)');\n      return new RegExp('^' + route + '$');\n    },\n\n    // Given a route, and a URL fragment that it matches, return the array of\n    // extracted decoded parameters. Empty or unmatched parameters will be\n    // treated as `null` to normalize cross-browser behavior.\n    _extractParameters: function(route, fragment) {\n      var params = route.exec(fragment).slice(1);\n      return _.map(params, function(param) {\n        return param ? decodeURIComponent(param) : null;\n      });\n    }\n\n  });\n\n  // Backbone.History\n  // ----------------\n\n  // Handles cross-browser history management, based on either\n  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n  // and URL fragments. If the browser supports neither (old IE, natch),\n  // falls back to polling.\n  var History = Backbone.History = function() {\n    this.handlers = [];\n    _.bindAll(this, 'checkUrl');\n\n    // Ensure that `History` can be used outside of the browser.\n    if (typeof window !== 'undefined') {\n      this.location = window.location;\n      this.history = window.history;\n    }\n  };\n\n  // Cached regex for stripping a leading hash/slash and trailing space.\n  var routeStripper = /^[#\\/]|\\s+$/g;\n\n  // Cached regex for stripping leading and trailing slashes.\n  var rootStripper = /^\\/+|\\/+$/g;\n\n  // Cached regex for detecting MSIE.\n  var isExplorer = /msie [\\w.]+/;\n\n  // Cached regex for removing a trailing slash.\n  var trailingSlash = /\\/$/;\n\n  // Has the history handling already been started?\n  History.started = false;\n\n  // Set up all inheritable **Backbone.History** properties and methods.\n  _.extend(History.prototype, Events, {\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    interval: 50,\n\n    // Gets the true hash value. Cannot use location.hash directly due to bug\n    // in Firefox where location.hash will always be decoded.\n    getHash: function(window) {\n      var match = (window || this).location.href.match(/#(.*)$/);\n      return match ? match[1] : '';\n    },\n\n    // Get the cross-browser normalized URL fragment, either from the URL,\n    // the hash, or the override.\n    getFragment: function(fragment, forcePushState) {\n      if (fragment == null) {\n        if (this._hasPushState || !this._wantsHashChange || forcePushState) {\n          fragment = this.location.pathname;\n          var root = this.root.replace(trailingSlash, '');\n          if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);\n        } else {\n          fragment = this.getHash();\n        }\n      }\n      return fragment.replace(routeStripper, '');\n    },\n\n    // Start the hash change handling, returning `true` if the current URL matches\n    // an existing route, and `false` otherwise.\n    start: function(options) {\n      if (History.started) throw new Error(\"Backbone.history has already been started\");\n      History.started = true;\n\n      // Figure out the initial configuration. Do we need an iframe?\n      // Is pushState desired ... is it available?\n      this.options          = _.extend({}, {root: '/'}, this.options, options);\n      this.root             = this.options.root;\n      this._wantsHashChange = this.options.hashChange !== false;\n      this._wantsPushState  = !!this.options.pushState;\n      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);\n      var fragment          = this.getFragment();\n      var docMode           = document.documentMode;\n      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\n\n      // Normalize root to always include a leading and trailing slash.\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n\n      if (oldIE && this._wantsHashChange) {\n        this.iframe = Backbone.$('<iframe src=\"javascript:0\" tabindex=\"-1\" />').hide().appendTo('body')[0].contentWindow;\n        this.navigate(fragment);\n      }\n\n      // Depending on whether we're using pushState or hashes, and whether\n      // 'onhashchange' is supported, determine how we check the URL state.\n      if (this._hasPushState) {\n        Backbone.$(window).on('popstate', this.checkUrl);\n      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\n        Backbone.$(window).on('hashchange', this.checkUrl);\n      } else if (this._wantsHashChange) {\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n      }\n\n      // Determine if we need to change the base url, for a pushState link\n      // opened by a non-pushState browser.\n      this.fragment = fragment;\n      var loc = this.location;\n      var atRoot = loc.pathname.replace(/[^\\/]$/, '$&/') === this.root;\n\n      // If we've started off with a route from a `pushState`-enabled browser,\n      // but we're currently in a browser that doesn't support it...\n      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {\n        this.fragment = this.getFragment(null, true);\n        this.location.replace(this.root + this.location.search + '#' + this.fragment);\n        // Return immediately as browser will do redirect to new url\n        return true;\n\n      // Or if we've started out with a hash-based route, but we're currently\n      // in a browser where it could be `pushState`-based instead...\n      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {\n        this.fragment = this.getHash().replace(routeStripper, '');\n        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);\n      }\n\n      if (!this.options.silent) return this.loadUrl();\n    },\n\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n    // but possibly useful for unit testing Routers.\n    stop: function() {\n      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);\n      clearInterval(this._checkUrlInterval);\n      History.started = false;\n    },\n\n    // Add a route to be tested when the fragment changes. Routes added later\n    // may override previous routes.\n    route: function(route, callback) {\n      this.handlers.unshift({route: route, callback: callback});\n    },\n\n    // Checks the current URL to see if it has changed, and if it has,\n    // calls `loadUrl`, normalizing across the hidden iframe.\n    checkUrl: function(e) {\n      var current = this.getFragment();\n      if (current === this.fragment && this.iframe) {\n        current = this.getFragment(this.getHash(this.iframe));\n      }\n      if (current === this.fragment) return false;\n      if (this.iframe) this.navigate(current);\n      this.loadUrl() || this.loadUrl(this.getHash());\n    },\n\n    // Attempt to load the current URL fragment. If a route succeeds with a\n    // match, returns `true`. If no defined routes matches the fragment,\n    // returns `false`.\n    loadUrl: function(fragmentOverride) {\n      var fragment = this.fragment = this.getFragment(fragmentOverride);\n      var matched = _.any(this.handlers, function(handler) {\n        if (handler.route.test(fragment)) {\n          handler.callback(fragment);\n          return true;\n        }\n      });\n      return matched;\n    },\n\n    // Save a fragment into the hash history, or replace the URL state if the\n    // 'replace' option is passed. You are responsible for properly URL-encoding\n    // the fragment in advance.\n    //\n    // The options object can contain `trigger: true` if you wish to have the\n    // route callback be fired (not usually desirable), or `replace: true`, if\n    // you wish to modify the current URL without adding an entry to the history.\n    navigate: function(fragment, options) {\n      if (!History.started) return false;\n      if (!options || options === true) options = {trigger: options};\n      fragment = this.getFragment(fragment || '');\n      if (this.fragment === fragment) return;\n      this.fragment = fragment;\n      var url = this.root + fragment;\n\n      // If pushState is available, we use it to set the fragment as a real URL.\n      if (this._hasPushState) {\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n      // If hash changes haven't been explicitly disabled, update the hash\n      // fragment to store history.\n      } else if (this._wantsHashChange) {\n        this._updateHash(this.location, fragment, options.replace);\n        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {\n          // Opening and closing the iframe tricks IE7 and earlier to push a\n          // history entry on hash-tag change.  When replace is true, we don't\n          // want this.\n          if(!options.replace) this.iframe.document.open().close();\n          this._updateHash(this.iframe.location, fragment, options.replace);\n        }\n\n      // If you've told us that you explicitly don't want fallback hashchange-\n      // based history, then `navigate` becomes a page refresh.\n      } else {\n        return this.location.assign(url);\n      }\n      if (options.trigger) this.loadUrl(fragment);\n    },\n\n    // Update the hash location, either replacing the current entry, or adding\n    // a new one to the browser history.\n    _updateHash: function(location, fragment, replace) {\n      if (replace) {\n        var href = location.href.replace(/(javascript:|#).*$/, '');\n        location.replace(href + '#' + fragment);\n      } else {\n        // Some browsers require that `hash` contains a leading #.\n        location.hash = '#' + fragment;\n      }\n    }\n\n  });\n\n  // Create the default Backbone.history.\n  Backbone.history = new History;\n\n  // Helpers\n  // -------\n\n  // Helper function to correctly set up the prototype chain, for subclasses.\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\n  // class properties to be extended.\n  var extend = function(protoProps, staticProps) {\n    var parent = this;\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent's constructor.\n    if (protoProps && _.has(protoProps, 'constructor')) {\n      child = protoProps.constructor;\n    } else {\n      child = function(){ return parent.apply(this, arguments); };\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    _.extend(child, parent, staticProps);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function.\n    var Surrogate = function(){ this.constructor = child; };\n    Surrogate.prototype = parent.prototype;\n    child.prototype = new Surrogate;\n\n    // Add prototype properties (instance properties) to the subclass,\n    // if supplied.\n    if (protoProps) _.extend(child.prototype, protoProps);\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n\n    return child;\n  };\n\n  // Set up inheritance for the model, collection, router, view and history.\n  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\n\n  // Throw an error when a URL is needed, and none is supplied.\n  var urlError = function() {\n    throw new Error('A \"url\" property or function must be specified');\n  };\n\n  // Wrap an optional error callback with a fallback error event.\n  var wrapError = function (model, options) {\n    var error = options.error;\n    options.error = function(resp) {\n      if (error) error(model, resp, options);\n      model.trigger('error', model, resp, options);\n    };\n  };\n\n}).call(this);\n","(function() {\n  var WebSocket = window.WebSocket || window.MozWebSocket;\n  var br = window.brunch || {};\n  var ar = br['auto-reload'] || {};\n  if (!WebSocket || !ar.enabled) return;\n\n  var cacheBuster = function(url){\n    var date = Math.round(Date.now() / 1000).toString();\n    url = url.replace(/(\\&|\\\\?)cacheBuster=\\d*/, '');\n    return url + (url.indexOf('?') >= 0 ? '&' : '?') +'cacheBuster=' + date;\n  };\n\n  var reloaders = {\n    page: function(){\n      window.location.reload(true);\n    },\n\n    stylesheet: function(){\n      [].slice\n        .call(document.querySelectorAll('link[rel=\"stylesheet\"]'))\n        .filter(function(link){\n          return (link != null && link.href != null);\n        })\n        .forEach(function(link) {\n          link.href = cacheBuster(link.href);\n        });\n    }\n  };\n  var port = ar.port || 9485;\n  var host = (!br['server']) ? window.location.hostname : br['server'];\n  var connection = new WebSocket('ws://' + host + ':' + port);\n  connection.onmessage = function(event) {\n    var message = event.data;\n    var b = window.brunch;\n    if (!b || !b['auto-reload'] || !b['auto-reload'].enabled) return;\n    if (reloaders[message] != null) {\n      reloaders[message]();\n    } else {\n      reloaders.page();\n    }\n  };\n})();\n","\njade = (function(exports){\n/*!\n * Jade - runtime\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Lame Array.isArray() polyfill for now.\n */\n\nif (!Array.isArray) {\n  Array.isArray = function(arr){\n    return '[object Array]' == Object.prototype.toString.call(arr);\n  };\n}\n\n/**\n * Lame Object.keys() polyfill for now.\n */\n\nif (!Object.keys) {\n  Object.keys = function(obj){\n    var arr = [];\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        arr.push(key);\n      }\n    }\n    return arr;\n  }\n}\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = function merge(a, b) {\n  var ac = a['class'];\n  var bc = b['class'];\n\n  if (ac || bc) {\n    ac = ac || [];\n    bc = bc || [];\n    if (!Array.isArray(ac)) ac = [ac];\n    if (!Array.isArray(bc)) bc = [bc];\n    ac = ac.filter(nulls);\n    bc = bc.filter(nulls);\n    a['class'] = ac.concat(bc).join(' ');\n  }\n\n  for (var key in b) {\n    if (key != 'class') {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Filter null `val`s.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction nulls(val) {\n  return val != null;\n}\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} escaped\n * @return {String}\n * @api private\n */\n\nexports.attrs = function attrs(obj, escaped){\n  var buf = []\n    , terse = obj.terse;\n\n  delete obj.terse;\n  var keys = Object.keys(obj)\n    , len = keys.length;\n\n  if (len) {\n    buf.push('');\n    for (var i = 0; i < len; ++i) {\n      var key = keys[i]\n        , val = obj[key];\n\n      if ('boolean' == typeof val || null == val) {\n        if (val) {\n          terse\n            ? buf.push(key)\n            : buf.push(key + '=\"' + key + '\"');\n        }\n      } else if (0 == key.indexOf('data') && 'string' != typeof val) {\n        buf.push(key + \"='\" + JSON.stringify(val) + \"'\");\n      } else if ('class' == key && Array.isArray(val)) {\n        buf.push(key + '=\"' + exports.escape(val.join(' ')) + '\"');\n      } else if (escaped && escaped[key]) {\n        buf.push(key + '=\"' + exports.escape(val) + '\"');\n      } else {\n        buf.push(key + '=\"' + val + '\"');\n      }\n    }\n  }\n\n  return buf.join(' ');\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nexports.escape = function escape(html){\n  return String(html)\n    .replace(/&(?!(\\w+|\\#\\d+);)/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the jade in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @api private\n */\n\nexports.rethrow = function rethrow(err, filename, lineno){\n  if (!filename) throw err;\n\n  var context = 3\n    , str = require('fs').readFileSync(filename, 'utf8')\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Jade') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n\n  return exports;\n\n})({});\n","/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor !== Array) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","/*!\n * Copyright 2014 Drifty Co.\n * http://drifty.com/\n *\n * Ionic, v1.0.0-beta.3\n * A powerful HTML5 mobile app framework.\n * http://ionicframework.com/\n *\n * By @maxlynch, @benjsperry, @adamdbradley <3\n *\n * Licensed under the MIT license. Please see LICENSE for more information.\n *\n */\n\n(function() {\n\n// Create namespaces\n//\nwindow.ionic = {\n  controllers: {},\n  views: {},\n  version: '1.0.0-beta.3'\n};\n\n(function(ionic) {\n\n  var bezierCoord = function (x,y) {\n    if(!x) x=0;\n    if(!y) y=0;\n    return {x: x, y: y};\n  };\n\n  function B1(t) { return t*t*t; }\n  function B2(t) { return 3*t*t*(1-t); }\n  function B3(t) { return 3*t*(1-t)*(1-t); }\n  function B4(t) { return (1-t)*(1-t)*(1-t); }\n\n  ionic.Animator = {\n    // Quadratic bezier solver\n    getQuadraticBezier: function(percent,C1,C2,C3,C4) {\n      var pos = new bezierCoord();\n      pos.x = C1.x*B1(percent) + C2.x*B2(percent) + C3.x*B3(percent) + C4.x*B4(percent);\n      pos.y = C1.y*B1(percent) + C2.y*B2(percent) + C3.y*B3(percent) + C4.y*B4(percent);\n      return pos;\n    },\n\n    // Cubic bezier solver from https://github.com/arian/cubic-bezier (MIT)\n    getCubicBezier: function(x1, y1, x2, y2, duration) {\n      // Precision\n      epsilon = (1000 / 60 / duration) / 4;\n\n      var curveX = function(t){\n        var v = 1 - t;\n        return 3 * v * v * t * x1 + 3 * v * t * t * x2 + t * t * t;\n      };\n\n      var curveY = function(t){\n        var v = 1 - t;\n        return 3 * v * v * t * y1 + 3 * v * t * t * y2 + t * t * t;\n      };\n\n      var derivativeCurveX = function(t){\n        var v = 1 - t;\n        return 3 * (2 * (t - 1) * t + v * v) * x1 + 3 * (- t * t * t + 2 * v * t) * x2;\n      };\n\n      return function(t) {\n\n        var x = t, t0, t1, t2, x2, d2, i;\n\n        // First try a few iterations of Newton's method -- normally very fast.\n        for (t2 = x, i = 0; i < 8; i++){\n          x2 = curveX(t2) - x;\n          if (Math.abs(x2) < epsilon) return curveY(t2);\n          d2 = derivativeCurveX(t2);\n          if (Math.abs(d2) < 1e-6) break;\n          t2 = t2 - x2 / d2;\n        }\n\n        t0 = 0, t1 = 1, t2 = x;\n\n        if (t2 < t0) return curveY(t0);\n        if (t2 > t1) return curveY(t1);\n\n        // Fallback to the bisection method for reliability.\n        while (t0 < t1){\n          x2 = curveX(t2);\n          if (Math.abs(x2 - x) < epsilon) return curveY(t2);\n          if (x > x2) t0 = t2;\n          else t1 = t2;\n          t2 = (t1 - t0) * 0.5 + t0;\n        }\n\n        // Failure\n        return curveY(t2);\n      };\n    },\n\n    animate: function(element, className, fn) {\n      return {\n        leave: function() {\n          var endFunc = function() {\n\n            element.classList.remove('leave');\n            element.classList.remove('leave-active');\n\n            element.removeEventListener('webkitTransitionEnd', endFunc);\n            element.removeEventListener('transitionEnd', endFunc);\n          };\n          element.addEventListener('webkitTransitionEnd', endFunc);\n          element.addEventListener('transitionEnd', endFunc);\n\n          element.classList.add('leave');\n          element.classList.add('leave-active');\n          return this;\n        },\n        enter: function() {\n          var endFunc = function() {\n\n            element.classList.remove('enter');\n            element.classList.remove('enter-active');\n\n            element.removeEventListener('webkitTransitionEnd', endFunc);\n            element.removeEventListener('transitionEnd', endFunc);\n          };\n          element.addEventListener('webkitTransitionEnd', endFunc);\n          element.addEventListener('transitionEnd', endFunc);\n\n          element.classList.add('enter');\n          element.classList.add('enter-active');\n\n          return this;\n        }\n      };\n    }\n  };\n})(ionic);\n\n(function(window, document, ionic) {\n\n  var readyCallbacks = [];\n  var isDomReady = false;\n\n  function domReady() {\n    isDomReady = true;\n    for(var x=0; x<readyCallbacks.length; x++) {\n      ionic.requestAnimationFrame(readyCallbacks[x]);\n    }\n    readyCallbacks = [];\n    document.removeEventListener('DOMContentLoaded', domReady);\n  }\n  document.addEventListener('DOMContentLoaded', domReady);\n\n  // From the man himself, Mr. Paul Irish.\n  // The requestAnimationFrame polyfill\n  // Put it on window just to preserve its context\n  // without having to use .call\n  window._rAF = (function(){\n    return  window.requestAnimationFrame       ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame    ||\n            function( callback ){\n              window.setTimeout(callback, 16);\n            };\n  })();\n\n  /**\n  * @ngdoc utility\n  * @name ionic.DomUtil\n  * @module ionic\n  */\n  ionic.DomUtil = {\n    //Call with proper context\n    /**\n     * @ngdoc method\n     * @name ionic.DomUtil#requestAnimationFrame\n     * @alias ionic.requestAnimationFrame\n     * @description Calls [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame), or a polyfill if not available.\n     * @param {function} callback The function to call when the next frame\n     * happens.\n     */\n    requestAnimationFrame: function(cb) {\n      window._rAF(cb);\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.DomUtil#animationFrameThrottle\n     * @alias ionic.animationFrameThrottle\n     * @description\n     * When given a callback, if that callback is called 100 times between\n     * animation frames, adding Throttle will make it only run the last of\n     * the 100 calls.\n     *\n     * @param {function} callback a function which will be throttled to\n     * requestAnimationFrame\n     * @returns {function} A function which will then call the passed in callback.\n     * The passed in callback will receive the context the returned function is\n     * called with.\n     */\n    animationFrameThrottle: function(cb) {\n      var args, isQueued, context;\n      return function() {\n        args = arguments;\n        context = this;\n        if (!isQueued) {\n          isQueued = true;\n          ionic.requestAnimationFrame(function() {\n            cb.apply(context, args);\n            isQueued = false;\n          });\n        }\n      };\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.DomUtil#getPositionInParent\n     * @description\n     * Find an element's scroll offset within its container.\n     * @param {DOMElement} element The element to find the offset of.\n     * @returns {object} A position object with the following properties:\n     *   - `{number}` `left` The left offset of the element.\n     *   - `{number}` `top` The top offset of the element.\n     */\n    getPositionInParent: function(el) {\n      return {\n        left: el.offsetLeft,\n        top: el.offsetTop\n      };\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.DomUtil#ready\n     * @description\n     * Call a function when the DOM is ready, or if it is already ready\n     * call the function immediately.\n     * @param {function} callback The function to be called.\n     */\n    ready: function(cb) {\n      if(isDomReady || document.readyState === \"complete\") {\n        ionic.requestAnimationFrame(cb);\n      } else {\n        readyCallbacks.push(cb);\n      }\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.DomUtil#getTextBounds\n     * @description\n     * Get a rect representing the bounds of the given textNode.\n     * @param {DOMElement} textNode The textNode to find the bounds of.\n     * @returns {object} An object representing the bounds of the node. Properties:\n     *   - `{number}` `left` The left positton of the textNode.\n     *   - `{number}` `right` The right positton of the textNode.\n     *   - `{number}` `top` The top positton of the textNode.\n     *   - `{number}` `bottom` The bottom position of the textNode.\n     *   - `{number}` `width` The width of the textNode.\n     *   - `{number}` `height` The height of the textNode.\n     */\n    getTextBounds: function(textNode) {\n      if(document.createRange) {\n        var range = document.createRange();\n        range.selectNodeContents(textNode);\n        if(range.getBoundingClientRect) {\n          var rect = range.getBoundingClientRect();\n          if(rect) {\n            var sx = window.scrollX;\n            var sy = window.scrollY;\n\n            return {\n              top: rect.top + sy,\n              left: rect.left + sx,\n              right: rect.left + sx + rect.width,\n              bottom: rect.top + sy + rect.height,\n              width: rect.width,\n              height: rect.height\n            };\n          }\n        }\n      }\n      return null;\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.DomUtil#getChildIndex\n     * @description\n     * Get the first index of a child node within the given element of the\n     * specified type.\n     * @param {DOMElement} element The element to find the index of.\n     * @param {string} type The nodeName to match children of element against.\n     * @returns {number} The index, or -1, of a child with nodeName matching type.\n     */\n    getChildIndex: function(element, type) {\n      if(type) {\n        var ch = element.parentNode.children;\n        var c;\n        for(var i = 0, k = 0, j = ch.length; i < j; i++) {\n          c = ch[i];\n          if(c.nodeName && c.nodeName.toLowerCase() == type) {\n            if(c == element) {\n              return k;\n            }\n            k++;\n          }\n        }\n      }\n      return Array.prototype.slice.call(element.parentNode.children).indexOf(element);\n    },\n\n    /**\n     * @private\n     */\n    swapNodes: function(src, dest) {\n      dest.parentNode.insertBefore(src, dest);\n    },\n\n    /**\n     * @private\n     */\n    centerElementByMargin: function(el) {\n      el.style.marginLeft = (-el.offsetWidth) / 2 + 'px';\n      el.style.marginTop = (-el.offsetHeight) / 2 + 'px';\n    },\n    //Center twice, after raf, to fix a bug with ios and showing elements\n    //that have just been attached to the DOM.\n    centerElementByMarginTwice: function(el) {\n      ionic.requestAnimationFrame(function() {\n        ionic.DomUtil.centerElementByMargin(el);\n        ionic.requestAnimationFrame(function() {\n          ionic.DomUtil.centerElementByMargin(el);\n        });\n      });\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.DomUtil#getParentWithClass\n     * @param {DOMElement} element\n     * @param {string} className\n     * @returns {DOMElement} The closest parent of element matching the\n     * className, or null.\n     */\n    getParentWithClass: function(e, className, depth) {\n      depth = depth || 10;\n      while(e.parentNode && depth--) {\n        if(e.parentNode.classList && e.parentNode.classList.contains(className)) {\n          return e.parentNode;\n        }\n        e = e.parentNode;\n      }\n      return null;\n    },\n    /**\n     * @ngdoc method\n     * @name ionic.DomUtil#getParentWithClass\n     * @param {DOMElement} element\n     * @param {string} className\n     * @returns {DOMElement} The closest parent or self matching the\n     * className, or null.\n     */\n    getParentOrSelfWithClass: function(e, className, depth) {\n      depth = depth || 10;\n      while(e && depth--) {\n        if(e.classList && e.classList.contains(className)) {\n          return e;\n        }\n        e = e.parentNode;\n      }\n      return null;\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.DomUtil#rectContains\n     * @param {number} x\n     * @param {number} y\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @returns {boolean} Whether {x,y} fits within the rectangle defined by\n     * {x1,y1,x2,y2}.\n     */\n    rectContains: function(x, y, x1, y1, x2, y2) {\n      if(x < x1 || x > x2) return false;\n      if(y < y1 || y > y2) return false;\n      return true;\n    }\n  };\n\n  //Shortcuts\n  ionic.requestAnimationFrame = ionic.DomUtil.requestAnimationFrame;\n  ionic.animationFrameThrottle = ionic.DomUtil.animationFrameThrottle;\n})(window, document, ionic);\n\n/**\n * ion-events.js\n *\n * Author: Max Lynch <max@drifty.com>\n *\n * Framework events handles various mobile browser events, and\n * detects special events like tap/swipe/etc. and emits them\n * as custom events that can be used in an app.\n *\n * Portions lovingly adapted from github.com/maker/ratchet and github.com/alexgibson/tap.js - thanks guys!\n */\n\n(function(ionic) {\n\n  // Custom event polyfill\n  if(!window.CustomEvent) {\n    (function() {\n      var CustomEvent;\n\n      CustomEvent = function(event, params) {\n        var evt;\n        params = params || {\n          bubbles: false,\n          cancelable: false,\n          detail: undefined\n        };\n        try {\n          evt = document.createEvent(\"CustomEvent\");\n          evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n        } catch (error) {\n          // fallback for browsers that don't support createEvent('CustomEvent')\n          evt = document.createEvent(\"Event\");\n          for (var param in params) {\n            evt[param] = params[param];\n          }\n          evt.initEvent(event, params.bubbles, params.cancelable);\n        }\n        return evt;\n      };\n\n      CustomEvent.prototype = window.Event.prototype;\n\n      window.CustomEvent = CustomEvent;\n    })();\n  }\n\n\n  /**\n   * @ngdoc utility\n   * @name ionic.EventController\n   * @module ionic\n   */\n  ionic.EventController = {\n    VIRTUALIZED_EVENTS: ['tap', 'swipe', 'swiperight', 'swipeleft', 'drag', 'hold', 'release'],\n\n    /**\n     * @ngdoc method\n     * @name ionic.EventController#trigger\n     * @alias ionic.trigger\n     * @param {string} eventType The event to trigger.\n     * @param {object} data The data for the event. Hint: pass in\n     * `{target: targetElement}`\n     * @param {boolean=} bubbles Whether the event should bubble up the DOM.\n     * @param {boolean=} cancelable Whether the event should be cancelable.\n     */\n    // Trigger a new event\n    trigger: function(eventType, data, bubbles, cancelable) {\n      var event = new CustomEvent(eventType, {\n        detail: data,\n        bubbles: !!bubbles,\n        cancelable: !!cancelable\n      });\n\n      // Make sure to trigger the event on the given target, or dispatch it from\n      // the window if we don't have an event target\n      data && data.target && data.target.dispatchEvent && data.target.dispatchEvent(event) || window.dispatchEvent(event);\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.EventController#on\n     * @alias ionic.on\n     * @description Listen to an event on an element.\n     * @param {string} type The event to listen for.\n     * @param {function} callback The listener to be called.\n     * @param {DOMElement} element The element to listen for the event on.\n     */\n    on: function(type, callback, element) {\n      var e = element || window;\n\n      // Bind a gesture if it's a virtual event\n      for(var i = 0, j = this.VIRTUALIZED_EVENTS.length; i < j; i++) {\n        if(type == this.VIRTUALIZED_EVENTS[i]) {\n          var gesture = new ionic.Gesture(element);\n          gesture.on(type, callback);\n          return gesture;\n        }\n      }\n\n      // Otherwise bind a normal event\n      e.addEventListener(type, callback);\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.EventController#off\n     * @alias ionic.off\n     * @description Remove an event listener.\n     * @param {string} type\n     * @param {function} callback\n     * @param {DOMElement} element\n     */\n    off: function(type, callback, element) {\n      element.removeEventListener(type, callback);\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.EventController#onGesture\n     * @alias ionic.onGesture\n     * @description Add an event listener for a gesture on an element.\n     *\n     * Available eventTypes (from [hammer.js](http://eightmedia.github.io/hammer.js/)):\n     *\n     * `hold`, `tap`, `doubletap`, `drag`, `dragstart`, `dragend`, `dragup`, `dragdown`, <br/>\n     * `dragleft`, `dragright`, `swipe`, `swipeup`, `swipedown`, `swipeleft`, `swiperight`, <br/>\n     * `transform`, `transformstart`, `transformend`, `rotate`, `pinch`, `pinchin`, `pinchout`, </br>\n     * `touch`, `release`\n     *\n     * @param {string} eventType The gesture event to listen for.\n     * @param {function(e)} callback The function to call when the gesture\n     * happens.\n     * @param {DOMElement} element The angular element to listen for the event on.\n     */\n    onGesture: function(type, callback, element) {\n      var gesture = new ionic.Gesture(element);\n      gesture.on(type, callback);\n      return gesture;\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.EventController#offGesture\n     * @alias ionic.offGesture\n     * @description Remove an event listener for a gesture on an element.\n     * @param {string} eventType The gesture event.\n     * @param {function(e)} callback The listener that was added earlier.\n     * @param {DOMElement} element The element the listener was added on.\n     */\n    offGesture: function(gesture, type, callback) {\n      gesture.off(type, callback);\n    },\n\n    handlePopState: function(event) {\n    },\n  };\n\n\n  // Map some convenient top-level functions for event handling\n  ionic.on = function() { ionic.EventController.on.apply(ionic.EventController, arguments); };\n  ionic.off = function() { ionic.EventController.off.apply(ionic.EventController, arguments); };\n  ionic.trigger = ionic.EventController.trigger;//function() { ionic.EventController.trigger.apply(ionic.EventController.trigger, arguments); };\n  ionic.onGesture = function() { return ionic.EventController.onGesture.apply(ionic.EventController.onGesture, arguments); };\n  ionic.offGesture = function() { return ionic.EventController.offGesture.apply(ionic.EventController.offGesture, arguments); };\n\n})(window.ionic);\n\n/**\n  * Simple gesture controllers with some common gestures that emit\n  * gesture events.\n  *\n  * Ported from github.com/EightMedia/hammer.js Gestures - thanks!\n  */\n(function(ionic) {\n\n  /**\n   * ionic.Gestures\n   * use this to create instances\n   * @param   {HTMLElement}   element\n   * @param   {Object}        options\n   * @returns {ionic.Gestures.Instance}\n   * @constructor\n   */\n  ionic.Gesture = function(element, options) {\n    return new ionic.Gestures.Instance(element, options || {});\n  };\n\n  ionic.Gestures = {};\n\n  // default settings\n  ionic.Gestures.defaults = {\n    // add css to the element to prevent the browser from doing\n    // its native behavior. this doesnt prevent the scrolling,\n    // but cancels the contextmenu, tap highlighting etc\n    // set to false to disable this\n    stop_browser_behavior: 'disable-user-behavior'\n  };\n\n  // detect touchevents\n  ionic.Gestures.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;\n  ionic.Gestures.HAS_TOUCHEVENTS = ('ontouchstart' in window);\n\n  // dont use mouseevents on mobile devices\n  ionic.Gestures.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;\n  ionic.Gestures.NO_MOUSEEVENTS = ionic.Gestures.HAS_TOUCHEVENTS && window.navigator.userAgent.match(ionic.Gestures.MOBILE_REGEX);\n\n  // eventtypes per touchevent (start, move, end)\n  // are filled by ionic.Gestures.event.determineEventTypes on setup\n  ionic.Gestures.EVENT_TYPES = {};\n\n  // direction defines\n  ionic.Gestures.DIRECTION_DOWN = 'down';\n  ionic.Gestures.DIRECTION_LEFT = 'left';\n  ionic.Gestures.DIRECTION_UP = 'up';\n  ionic.Gestures.DIRECTION_RIGHT = 'right';\n\n  // pointer type\n  ionic.Gestures.POINTER_MOUSE = 'mouse';\n  ionic.Gestures.POINTER_TOUCH = 'touch';\n  ionic.Gestures.POINTER_PEN = 'pen';\n\n  // touch event defines\n  ionic.Gestures.EVENT_START = 'start';\n  ionic.Gestures.EVENT_MOVE = 'move';\n  ionic.Gestures.EVENT_END = 'end';\n\n  // hammer document where the base events are added at\n  ionic.Gestures.DOCUMENT = window.document;\n\n  // plugins namespace\n  ionic.Gestures.plugins = {};\n\n  // if the window events are set...\n  ionic.Gestures.READY = false;\n\n  /**\n   * setup events to detect gestures on the document\n   */\n  function setup() {\n    if(ionic.Gestures.READY) {\n      return;\n    }\n\n    // find what eventtypes we add listeners to\n    ionic.Gestures.event.determineEventTypes();\n\n    // Register all gestures inside ionic.Gestures.gestures\n    for(var name in ionic.Gestures.gestures) {\n      if(ionic.Gestures.gestures.hasOwnProperty(name)) {\n        ionic.Gestures.detection.register(ionic.Gestures.gestures[name]);\n      }\n    }\n\n    // Add touch events on the document\n    ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_MOVE, ionic.Gestures.detection.detect);\n    ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_END, ionic.Gestures.detection.detect);\n\n    // ionic.Gestures is ready...!\n    ionic.Gestures.READY = true;\n  }\n\n  /**\n   * create new hammer instance\n   * all methods should return the instance itself, so it is chainable.\n   * @param   {HTMLElement}       element\n   * @param   {Object}            [options={}]\n   * @returns {ionic.Gestures.Instance}\n   * @name Gesture.Instance\n   * @constructor\n   */\n  ionic.Gestures.Instance = function(element, options) {\n    var self = this;\n\n    // A null element was passed into the instance, which means\n    // whatever lookup was done to find this element failed to find it\n    // so we can't listen for events on it.\n    if(element === null) {\n      void 0;\n      return;\n    }\n\n    // setup ionic.GesturesJS window events and register all gestures\n    // this also sets up the default options\n    setup();\n\n    this.element = element;\n\n    // start/stop detection option\n    this.enabled = true;\n\n    // merge options\n    this.options = ionic.Gestures.utils.extend(\n        ionic.Gestures.utils.extend({}, ionic.Gestures.defaults),\n        options || {});\n\n    // add some css to the element to prevent the browser from doing its native behavoir\n    if(this.options.stop_browser_behavior) {\n      ionic.Gestures.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);\n    }\n\n    // start detection on touchstart\n    ionic.Gestures.event.onTouch(element, ionic.Gestures.EVENT_START, function(ev) {\n      if(self.enabled) {\n        ionic.Gestures.detection.startDetect(self, ev);\n      }\n    });\n\n    // return instance\n    return this;\n  };\n\n\n  ionic.Gestures.Instance.prototype = {\n    /**\n     * bind events to the instance\n     * @param   {String}      gesture\n     * @param   {Function}    handler\n     * @returns {ionic.Gestures.Instance}\n     */\n    on: function onEvent(gesture, handler){\n      var gestures = gesture.split(' ');\n      for(var t=0; t<gestures.length; t++) {\n        this.element.addEventListener(gestures[t], handler, false);\n      }\n      return this;\n    },\n\n\n    /**\n     * unbind events to the instance\n     * @param   {String}      gesture\n     * @param   {Function}    handler\n     * @returns {ionic.Gestures.Instance}\n     */\n    off: function offEvent(gesture, handler){\n      var gestures = gesture.split(' ');\n      for(var t=0; t<gestures.length; t++) {\n        this.element.removeEventListener(gestures[t], handler, false);\n      }\n      return this;\n    },\n\n\n    /**\n     * trigger gesture event\n     * @param   {String}      gesture\n     * @param   {Object}      eventData\n     * @returns {ionic.Gestures.Instance}\n     */\n    trigger: function triggerEvent(gesture, eventData){\n      // create DOM event\n      var event = ionic.Gestures.DOCUMENT.createEvent('Event');\n      event.initEvent(gesture, true, true);\n      event.gesture = eventData;\n\n      // trigger on the target if it is in the instance element,\n      // this is for event delegation tricks\n      var element = this.element;\n      if(ionic.Gestures.utils.hasParent(eventData.target, element)) {\n        element = eventData.target;\n      }\n\n      element.dispatchEvent(event);\n      return this;\n    },\n\n\n    /**\n     * enable of disable hammer.js detection\n     * @param   {Boolean}   state\n     * @returns {ionic.Gestures.Instance}\n     */\n    enable: function enable(state) {\n      this.enabled = state;\n      return this;\n    }\n  };\n\n  /**\n   * this holds the last move event,\n   * used to fix empty touchend issue\n   * see the onTouch event for an explanation\n   * type {Object}\n   */\n  var last_move_event = null;\n\n\n  /**\n   * when the mouse is hold down, this is true\n   * type {Boolean}\n   */\n  var enable_detect = false;\n\n\n  /**\n   * when touch events have been fired, this is true\n   * type {Boolean}\n   */\n  var touch_triggered = false;\n\n\n  ionic.Gestures.event = {\n    /**\n     * simple addEventListener\n     * @param   {HTMLElement}   element\n     * @param   {String}        type\n     * @param   {Function}      handler\n     */\n    bindDom: function(element, type, handler) {\n      var types = type.split(' ');\n      for(var t=0; t<types.length; t++) {\n        element.addEventListener(types[t], handler, false);\n      }\n    },\n\n\n    /**\n     * touch events with mouse fallback\n     * @param   {HTMLElement}   element\n     * @param   {String}        eventType        like ionic.Gestures.EVENT_MOVE\n     * @param   {Function}      handler\n     */\n    onTouch: function onTouch(element, eventType, handler) {\n      var self = this;\n\n      this.bindDom(element, ionic.Gestures.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {\n        var sourceEventType = ev.type.toLowerCase();\n\n        // onmouseup, but when touchend has been fired we do nothing.\n        // this is for touchdevices which also fire a mouseup on touchend\n        if(sourceEventType.match(/mouse/) && touch_triggered) {\n          return;\n        }\n\n        // mousebutton must be down or a touch event\n        else if( sourceEventType.match(/touch/) ||   // touch events are always on screen\n          sourceEventType.match(/pointerdown/) || // pointerevents touch\n          (sourceEventType.match(/mouse/) && ev.which === 1)   // mouse is pressed\n          ){\n            enable_detect = true;\n          }\n\n        // mouse isn't pressed\n        else if(sourceEventType.match(/mouse/) && ev.which !== 1) {\n          enable_detect = false;\n        }\n\n\n        // we are in a touch event, set the touch triggered bool to true,\n        // this for the conflicts that may occur on ios and android\n        if(sourceEventType.match(/touch|pointer/)) {\n          touch_triggered = true;\n        }\n\n        // count the total touches on the screen\n        var count_touches = 0;\n\n        // when touch has been triggered in this detection session\n        // and we are now handling a mouse event, we stop that to prevent conflicts\n        if(enable_detect) {\n          // update pointerevent\n          if(ionic.Gestures.HAS_POINTEREVENTS && eventType != ionic.Gestures.EVENT_END) {\n            count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);\n          }\n          // touch\n          else if(sourceEventType.match(/touch/)) {\n            count_touches = ev.touches.length;\n          }\n          // mouse\n          else if(!touch_triggered) {\n            count_touches = sourceEventType.match(/up/) ? 0 : 1;\n          }\n\n          // if we are in a end event, but when we remove one touch and\n          // we still have enough, set eventType to move\n          if(count_touches > 0 && eventType == ionic.Gestures.EVENT_END) {\n            eventType = ionic.Gestures.EVENT_MOVE;\n          }\n          // no touches, force the end event\n          else if(!count_touches) {\n            eventType = ionic.Gestures.EVENT_END;\n          }\n\n          // store the last move event\n          if(count_touches || last_move_event === null) {\n            last_move_event = ev;\n          }\n\n          // trigger the handler\n          handler.call(ionic.Gestures.detection, self.collectEventData(element, eventType, self.getTouchList(last_move_event, eventType), ev));\n\n          // remove pointerevent from list\n          if(ionic.Gestures.HAS_POINTEREVENTS && eventType == ionic.Gestures.EVENT_END) {\n            count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);\n          }\n        }\n\n        //debug(sourceEventType +\" \"+ eventType);\n\n        // on the end we reset everything\n        if(!count_touches) {\n          last_move_event = null;\n          enable_detect = false;\n          touch_triggered = false;\n          ionic.Gestures.PointerEvent.reset();\n        }\n      });\n    },\n\n\n    /**\n     * we have different events for each device/browser\n     * determine what we need and set them in the ionic.Gestures.EVENT_TYPES constant\n     */\n    determineEventTypes: function determineEventTypes() {\n      // determine the eventtype we want to set\n      var types;\n\n      // pointerEvents magic\n      if(ionic.Gestures.HAS_POINTEREVENTS) {\n        types = ionic.Gestures.PointerEvent.getEvents();\n      }\n      // on Android, iOS, blackberry, windows mobile we dont want any mouseevents\n      else if(ionic.Gestures.NO_MOUSEEVENTS) {\n        types = [\n          'touchstart',\n          'touchmove',\n          'touchend touchcancel'];\n      }\n      // for non pointer events browsers and mixed browsers,\n      // like chrome on windows8 touch laptop\n      else {\n        types = [\n          'touchstart mousedown',\n          'touchmove mousemove',\n          'touchend touchcancel mouseup'];\n      }\n\n      ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_START]  = types[0];\n      ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_MOVE]   = types[1];\n      ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_END]    = types[2];\n    },\n\n\n    /**\n     * create touchlist depending on the event\n     * @param   {Object}    ev\n     * @param   {String}    eventType   used by the fakemultitouch plugin\n     */\n    getTouchList: function getTouchList(ev/*, eventType*/) {\n      // get the fake pointerEvent touchlist\n      if(ionic.Gestures.HAS_POINTEREVENTS) {\n        return ionic.Gestures.PointerEvent.getTouchList();\n      }\n      // get the touchlist\n      else if(ev.touches) {\n        return ev.touches;\n      }\n      // make fake touchlist from mouse position\n      else {\n        ev.indentifier = 1;\n        return [ev];\n      }\n    },\n\n\n    /**\n     * collect event data for ionic.Gestures js\n     * @param   {HTMLElement}   element\n     * @param   {String}        eventType        like ionic.Gestures.EVENT_MOVE\n     * @param   {Object}        eventData\n     */\n    collectEventData: function collectEventData(element, eventType, touches, ev) {\n\n      // find out pointerType\n      var pointerType = ionic.Gestures.POINTER_TOUCH;\n      if(ev.type.match(/mouse/) || ionic.Gestures.PointerEvent.matchType(ionic.Gestures.POINTER_MOUSE, ev)) {\n        pointerType = ionic.Gestures.POINTER_MOUSE;\n      }\n\n      return {\n        center      : ionic.Gestures.utils.getCenter(touches),\n                    timeStamp   : new Date().getTime(),\n                    target      : ev.target,\n                    touches     : touches,\n                    eventType   : eventType,\n                    pointerType : pointerType,\n                    srcEvent    : ev,\n\n                    /**\n                     * prevent the browser default actions\n                     * mostly used to disable scrolling of the browser\n                     */\n                    preventDefault: function() {\n                      if(this.srcEvent.preventManipulation) {\n                        this.srcEvent.preventManipulation();\n                      }\n\n                      if(this.srcEvent.preventDefault) {\n                        //this.srcEvent.preventDefault();\n                      }\n                    },\n\n                    /**\n                     * stop bubbling the event up to its parents\n                     */\n                    stopPropagation: function() {\n                      this.srcEvent.stopPropagation();\n                    },\n\n                    /**\n                     * immediately stop gesture detection\n                     * might be useful after a swipe was detected\n                     * @return {*}\n                     */\n                    stopDetect: function() {\n                      return ionic.Gestures.detection.stopDetect();\n                    }\n      };\n    }\n  };\n\n  ionic.Gestures.PointerEvent = {\n    /**\n     * holds all pointers\n     * type {Object}\n     */\n    pointers: {},\n\n    /**\n     * get a list of pointers\n     * @returns {Array}     touchlist\n     */\n    getTouchList: function() {\n      var self = this;\n      var touchlist = [];\n\n      // we can use forEach since pointerEvents only is in IE10\n      Object.keys(self.pointers).sort().forEach(function(id) {\n        touchlist.push(self.pointers[id]);\n      });\n      return touchlist;\n    },\n\n    /**\n     * update the position of a pointer\n     * @param   {String}   type             ionic.Gestures.EVENT_END\n     * @param   {Object}   pointerEvent\n     */\n    updatePointer: function(type, pointerEvent) {\n      if(type == ionic.Gestures.EVENT_END) {\n        this.pointers = {};\n      }\n      else {\n        pointerEvent.identifier = pointerEvent.pointerId;\n        this.pointers[pointerEvent.pointerId] = pointerEvent;\n      }\n\n      return Object.keys(this.pointers).length;\n    },\n\n    /**\n     * check if ev matches pointertype\n     * @param   {String}        pointerType     ionic.Gestures.POINTER_MOUSE\n     * @param   {PointerEvent}  ev\n     */\n    matchType: function(pointerType, ev) {\n      if(!ev.pointerType) {\n        return false;\n      }\n\n      var types = {};\n      types[ionic.Gestures.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == ionic.Gestures.POINTER_MOUSE);\n      types[ionic.Gestures.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == ionic.Gestures.POINTER_TOUCH);\n      types[ionic.Gestures.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == ionic.Gestures.POINTER_PEN);\n      return types[pointerType];\n    },\n\n\n    /**\n     * get events\n     */\n    getEvents: function() {\n      return [\n        'pointerdown MSPointerDown',\n      'pointermove MSPointerMove',\n      'pointerup pointercancel MSPointerUp MSPointerCancel'\n        ];\n    },\n\n    /**\n     * reset the list\n     */\n    reset: function() {\n      this.pointers = {};\n    }\n  };\n\n\n  ionic.Gestures.utils = {\n    /**\n     * extend method,\n     * also used for cloning when dest is an empty object\n     * @param   {Object}    dest\n     * @param   {Object}    src\n     * @param\t{Boolean}\tmerge\t\tdo a merge\n     * @returns {Object}    dest\n     */\n    extend: function extend(dest, src, merge) {\n      for (var key in src) {\n        if(dest[key] !== undefined && merge) {\n          continue;\n        }\n        dest[key] = src[key];\n      }\n      return dest;\n    },\n\n\n    /**\n     * find if a node is in the given parent\n     * used for event delegation tricks\n     * @param   {HTMLElement}   node\n     * @param   {HTMLElement}   parent\n     * @returns {boolean}       has_parent\n     */\n    hasParent: function(node, parent) {\n      while(node){\n        if(node == parent) {\n          return true;\n        }\n        node = node.parentNode;\n      }\n      return false;\n    },\n\n\n    /**\n     * get the center of all the touches\n     * @param   {Array}     touches\n     * @returns {Object}    center\n     */\n    getCenter: function getCenter(touches) {\n      var valuesX = [], valuesY = [];\n\n      for(var t= 0,len=touches.length; t<len; t++) {\n        valuesX.push(touches[t].pageX);\n        valuesY.push(touches[t].pageY);\n      }\n\n      return {\n        pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),\n          pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)\n      };\n    },\n\n\n    /**\n     * calculate the velocity between two points\n     * @param   {Number}    delta_time\n     * @param   {Number}    delta_x\n     * @param   {Number}    delta_y\n     * @returns {Object}    velocity\n     */\n    getVelocity: function getVelocity(delta_time, delta_x, delta_y) {\n      return {\n        x: Math.abs(delta_x / delta_time) || 0,\n        y: Math.abs(delta_y / delta_time) || 0\n      };\n    },\n\n\n    /**\n     * calculate the angle between two coordinates\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {Number}    angle\n     */\n    getAngle: function getAngle(touch1, touch2) {\n      var y = touch2.pageY - touch1.pageY,\n      x = touch2.pageX - touch1.pageX;\n      return Math.atan2(y, x) * 180 / Math.PI;\n    },\n\n\n    /**\n     * angle to direction define\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {String}    direction constant, like ionic.Gestures.DIRECTION_LEFT\n     */\n    getDirection: function getDirection(touch1, touch2) {\n      var x = Math.abs(touch1.pageX - touch2.pageX),\n      y = Math.abs(touch1.pageY - touch2.pageY);\n\n      if(x >= y) {\n        return touch1.pageX - touch2.pageX > 0 ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;\n      }\n      else {\n        return touch1.pageY - touch2.pageY > 0 ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;\n      }\n    },\n\n\n    /**\n     * calculate the distance between two touches\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {Number}    distance\n     */\n    getDistance: function getDistance(touch1, touch2) {\n      var x = touch2.pageX - touch1.pageX,\n      y = touch2.pageY - touch1.pageY;\n      return Math.sqrt((x*x) + (y*y));\n    },\n\n\n    /**\n     * calculate the scale factor between two touchLists (fingers)\n     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n     * @param   {Array}     start\n     * @param   {Array}     end\n     * @returns {Number}    scale\n     */\n    getScale: function getScale(start, end) {\n      // need two fingers...\n      if(start.length >= 2 && end.length >= 2) {\n        return this.getDistance(end[0], end[1]) /\n          this.getDistance(start[0], start[1]);\n      }\n      return 1;\n    },\n\n\n    /**\n     * calculate the rotation degrees between two touchLists (fingers)\n     * @param   {Array}     start\n     * @param   {Array}     end\n     * @returns {Number}    rotation\n     */\n    getRotation: function getRotation(start, end) {\n      // need two fingers\n      if(start.length >= 2 && end.length >= 2) {\n        return this.getAngle(end[1], end[0]) -\n          this.getAngle(start[1], start[0]);\n      }\n      return 0;\n    },\n\n\n    /**\n     * boolean if the direction is vertical\n     * @param    {String}    direction\n     * @returns  {Boolean}   is_vertical\n     */\n    isVertical: function isVertical(direction) {\n      return (direction == ionic.Gestures.DIRECTION_UP || direction == ionic.Gestures.DIRECTION_DOWN);\n    },\n\n\n    /**\n     * stop browser default behavior with css class\n     * @param   {HtmlElement}   element\n     * @param   {Object}        css_class\n     */\n    stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_class) {\n      // changed from making many style changes to just adding a preset classname\n      // less DOM manipulations, less code, and easier to control in the CSS side of things\n      // hammer.js doesn't come with CSS, but ionic does, which is why we prefer this method\n      if(element && element.classList) {\n        element.classList.add(css_class);\n        element.onselectstart = function() {\n          return false;\n        };\n      }\n    }\n  };\n\n\n  ionic.Gestures.detection = {\n    // contains all registred ionic.Gestures.gestures in the correct order\n    gestures: [],\n\n    // data of the current ionic.Gestures.gesture detection session\n    current: null,\n\n    // the previous ionic.Gestures.gesture session data\n    // is a full clone of the previous gesture.current object\n    previous: null,\n\n    // when this becomes true, no gestures are fired\n    stopped: false,\n\n\n    /**\n     * start ionic.Gestures.gesture detection\n     * @param   {ionic.Gestures.Instance}   inst\n     * @param   {Object}            eventData\n     */\n    startDetect: function startDetect(inst, eventData) {\n      // already busy with a ionic.Gestures.gesture detection on an element\n      if(this.current) {\n        return;\n      }\n\n      this.stopped = false;\n\n      this.current = {\n        inst        : inst, // reference to ionic.GesturesInstance we're working for\n        startEvent  : ionic.Gestures.utils.extend({}, eventData), // start eventData for distances, timing etc\n        lastEvent   : false, // last eventData\n        name        : '' // current gesture we're in/detected, can be 'tap', 'hold' etc\n      };\n\n      this.detect(eventData);\n    },\n\n\n    /**\n     * ionic.Gestures.gesture detection\n     * @param   {Object}    eventData\n     */\n    detect: function detect(eventData) {\n      if(!this.current || this.stopped) {\n        return;\n      }\n\n      // extend event data with calculations about scale, distance etc\n      eventData = this.extendEventData(eventData);\n\n      // instance options\n      var inst_options = this.current.inst.options;\n\n      // call ionic.Gestures.gesture handlers\n      for(var g=0,len=this.gestures.length; g<len; g++) {\n        var gesture = this.gestures[g];\n\n        // only when the instance options have enabled this gesture\n        if(!this.stopped && inst_options[gesture.name] !== false) {\n          // if a handler returns false, we stop with the detection\n          if(gesture.handler.call(gesture, eventData, this.current.inst) === false) {\n            this.stopDetect();\n            break;\n          }\n        }\n      }\n\n      // store as previous event event\n      if(this.current) {\n        this.current.lastEvent = eventData;\n      }\n\n      // endevent, but not the last touch, so dont stop\n      if(eventData.eventType == ionic.Gestures.EVENT_END && !eventData.touches.length-1) {\n        this.stopDetect();\n      }\n\n      return eventData;\n    },\n\n\n    /**\n     * clear the ionic.Gestures.gesture vars\n     * this is called on endDetect, but can also be used when a final ionic.Gestures.gesture has been detected\n     * to stop other ionic.Gestures.gestures from being fired\n     */\n    stopDetect: function stopDetect() {\n      // clone current data to the store as the previous gesture\n      // used for the double tap gesture, since this is an other gesture detect session\n      this.previous = ionic.Gestures.utils.extend({}, this.current);\n\n      // reset the current\n      this.current = null;\n\n      // stopped!\n      this.stopped = true;\n    },\n\n\n    /**\n     * extend eventData for ionic.Gestures.gestures\n     * @param   {Object}   ev\n     * @returns {Object}   ev\n     */\n    extendEventData: function extendEventData(ev) {\n      var startEv = this.current.startEvent;\n\n      // if the touches change, set the new touches over the startEvent touches\n      // this because touchevents don't have all the touches on touchstart, or the\n      // user must place his fingers at the EXACT same time on the screen, which is not realistic\n      // but, sometimes it happens that both fingers are touching at the EXACT same time\n      if(startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {\n        // extend 1 level deep to get the touchlist with the touch objects\n        startEv.touches = [];\n        for(var i=0,len=ev.touches.length; i<len; i++) {\n          startEv.touches.push(ionic.Gestures.utils.extend({}, ev.touches[i]));\n        }\n      }\n\n      var delta_time = ev.timeStamp - startEv.timeStamp,\n          delta_x = ev.center.pageX - startEv.center.pageX,\n          delta_y = ev.center.pageY - startEv.center.pageY,\n          velocity = ionic.Gestures.utils.getVelocity(delta_time, delta_x, delta_y);\n\n      ionic.Gestures.utils.extend(ev, {\n        deltaTime   : delta_time,\n\n        deltaX      : delta_x,\n        deltaY      : delta_y,\n\n        velocityX   : velocity.x,\n        velocityY   : velocity.y,\n\n        distance    : ionic.Gestures.utils.getDistance(startEv.center, ev.center),\n        angle       : ionic.Gestures.utils.getAngle(startEv.center, ev.center),\n        direction   : ionic.Gestures.utils.getDirection(startEv.center, ev.center),\n\n        scale       : ionic.Gestures.utils.getScale(startEv.touches, ev.touches),\n        rotation    : ionic.Gestures.utils.getRotation(startEv.touches, ev.touches),\n\n        startEvent  : startEv\n      });\n\n      return ev;\n    },\n\n\n    /**\n     * register new gesture\n     * @param   {Object}    gesture object, see gestures.js for documentation\n     * @returns {Array}     gestures\n     */\n    register: function register(gesture) {\n      // add an enable gesture options if there is no given\n      var options = gesture.defaults || {};\n      if(options[gesture.name] === undefined) {\n        options[gesture.name] = true;\n      }\n\n      // extend ionic.Gestures default options with the ionic.Gestures.gesture options\n      ionic.Gestures.utils.extend(ionic.Gestures.defaults, options, true);\n\n      // set its index\n      gesture.index = gesture.index || 1000;\n\n      // add ionic.Gestures.gesture to the list\n      this.gestures.push(gesture);\n\n      // sort the list by index\n      this.gestures.sort(function(a, b) {\n        if (a.index < b.index) {\n          return -1;\n        }\n        if (a.index > b.index) {\n          return 1;\n        }\n        return 0;\n      });\n\n      return this.gestures;\n    }\n  };\n\n\n  ionic.Gestures.gestures = ionic.Gestures.gestures || {};\n\n  /**\n   * Custom gestures\n   * ==============================\n   *\n   * Gesture object\n   * --------------------\n   * The object structure of a gesture:\n   *\n   * { name: 'mygesture',\n   *   index: 1337,\n   *   defaults: {\n   *     mygesture_option: true\n   *   }\n   *   handler: function(type, ev, inst) {\n   *     // trigger gesture event\n   *     inst.trigger(this.name, ev);\n   *   }\n   * }\n\n   * @param   {String}    name\n   * this should be the name of the gesture, lowercase\n   * it is also being used to disable/enable the gesture per instance config.\n   *\n   * @param   {Number}    [index=1000]\n   * the index of the gesture, where it is going to be in the stack of gestures detection\n   * like when you build an gesture that depends on the drag gesture, it is a good\n   * idea to place it after the index of the drag gesture.\n   *\n   * @param   {Object}    [defaults={}]\n   * the default settings of the gesture. these are added to the instance settings,\n   * and can be overruled per instance. you can also add the name of the gesture,\n   * but this is also added by default (and set to true).\n   *\n   * @param   {Function}  handler\n   * this handles the gesture detection of your custom gesture and receives the\n   * following arguments:\n   *\n   *      @param  {Object}    eventData\n   *      event data containing the following properties:\n   *          timeStamp   {Number}        time the event occurred\n   *          target      {HTMLElement}   target element\n   *          touches     {Array}         touches (fingers, pointers, mouse) on the screen\n   *          pointerType {String}        kind of pointer that was used. matches ionic.Gestures.POINTER_MOUSE|TOUCH\n   *          center      {Object}        center position of the touches. contains pageX and pageY\n   *          deltaTime   {Number}        the total time of the touches in the screen\n   *          deltaX      {Number}        the delta on x axis we haved moved\n   *          deltaY      {Number}        the delta on y axis we haved moved\n   *          velocityX   {Number}        the velocity on the x\n   *          velocityY   {Number}        the velocity on y\n   *          angle       {Number}        the angle we are moving\n   *          direction   {String}        the direction we are moving. matches ionic.Gestures.DIRECTION_UP|DOWN|LEFT|RIGHT\n   *          distance    {Number}        the distance we haved moved\n   *          scale       {Number}        scaling of the touches, needs 2 touches\n   *          rotation    {Number}        rotation of the touches, needs 2 touches *\n   *          eventType   {String}        matches ionic.Gestures.EVENT_START|MOVE|END\n   *          srcEvent    {Object}        the source event, like TouchStart or MouseDown *\n   *          startEvent  {Object}        contains the same properties as above,\n   *                                      but from the first touch. this is used to calculate\n   *                                      distances, deltaTime, scaling etc\n   *\n   *      @param  {ionic.Gestures.Instance}    inst\n   *      the instance we are doing the detection for. you can get the options from\n   *      the inst.options object and trigger the gesture event by calling inst.trigger\n   *\n   *\n   * Handle gestures\n   * --------------------\n   * inside the handler you can get/set ionic.Gestures.detectionic.current. This is the current\n   * detection sessionic. It has the following properties\n   *      @param  {String}    name\n   *      contains the name of the gesture we have detected. it has not a real function,\n   *      only to check in other gestures if something is detected.\n   *      like in the drag gesture we set it to 'drag' and in the swipe gesture we can\n   *      check if the current gesture is 'drag' by accessing ionic.Gestures.detectionic.current.name\n   *\n   *      readonly\n   *      @param  {ionic.Gestures.Instance}    inst\n   *      the instance we do the detection for\n   *\n   *      readonly\n   *      @param  {Object}    startEvent\n   *      contains the properties of the first gesture detection in this sessionic.\n   *      Used for calculations about timing, distance, etc.\n   *\n   *      readonly\n   *      @param  {Object}    lastEvent\n   *      contains all the properties of the last gesture detect in this sessionic.\n   *\n   * after the gesture detection session has been completed (user has released the screen)\n   * the ionic.Gestures.detectionic.current object is copied into ionic.Gestures.detectionic.previous,\n   * this is usefull for gestures like doubletap, where you need to know if the\n   * previous gesture was a tap\n   *\n   * options that have been set by the instance can be received by calling inst.options\n   *\n   * You can trigger a gesture event by calling inst.trigger(\"mygesture\", event).\n   * The first param is the name of your gesture, the second the event argument\n   *\n   *\n   * Register gestures\n   * --------------------\n   * When an gesture is added to the ionic.Gestures.gestures object, it is auto registered\n   * at the setup of the first ionic.Gestures instance. You can also call ionic.Gestures.detectionic.register\n   * manually and pass your gesture object as a param\n   *\n   */\n\n  /**\n   * Hold\n   * Touch stays at the same place for x time\n   * events  hold\n   */\n  ionic.Gestures.gestures.Hold = {\n    name: 'hold',\n    index: 10,\n    defaults: {\n      hold_timeout\t: 500,\n      hold_threshold\t: 1\n    },\n    timer: null,\n    handler: function holdGesture(ev, inst) {\n      switch(ev.eventType) {\n        case ionic.Gestures.EVENT_START:\n          // clear any running timers\n          clearTimeout(this.timer);\n\n          // set the gesture so we can check in the timeout if it still is\n          ionic.Gestures.detection.current.name = this.name;\n\n          // set timer and if after the timeout it still is hold,\n          // we trigger the hold event\n          this.timer = setTimeout(function() {\n            if(ionic.Gestures.detection.current.name == 'hold') {\n              inst.trigger('hold', ev);\n            }\n          }, inst.options.hold_timeout);\n          break;\n\n          // when you move or end we clear the timer\n        case ionic.Gestures.EVENT_MOVE:\n          if(ev.distance > inst.options.hold_threshold) {\n            clearTimeout(this.timer);\n          }\n          break;\n\n        case ionic.Gestures.EVENT_END:\n          clearTimeout(this.timer);\n          break;\n      }\n    }\n  };\n\n\n  /**\n   * Tap/DoubleTap\n   * Quick touch at a place or double at the same place\n   * events  tap, doubletap\n   */\n  ionic.Gestures.gestures.Tap = {\n    name: 'tap',\n    index: 100,\n    defaults: {\n      tap_max_touchtime\t: 250,\n      tap_max_distance\t: 10,\n      tap_always\t\t\t: true,\n      doubletap_distance\t: 20,\n      doubletap_interval\t: 300\n    },\n    handler: function tapGesture(ev, inst) {\n      if(ev.eventType == ionic.Gestures.EVENT_END && ev.srcEvent.type != 'touchcancel') {\n        // previous gesture, for the double tap since these are two different gesture detections\n        var prev = ionic.Gestures.detection.previous,\n        did_doubletap = false;\n\n        // when the touchtime is higher then the max touch time\n        // or when the moving distance is too much\n        if(ev.deltaTime > inst.options.tap_max_touchtime ||\n            ev.distance > inst.options.tap_max_distance) {\n              return;\n            }\n\n        // check if double tap\n        if(prev && prev.name == 'tap' &&\n            (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval &&\n            ev.distance < inst.options.doubletap_distance) {\n              inst.trigger('doubletap', ev);\n              did_doubletap = true;\n            }\n\n        // do a single tap\n        if(!did_doubletap || inst.options.tap_always) {\n          ionic.Gestures.detection.current.name = 'tap';\n          inst.trigger(ionic.Gestures.detection.current.name, ev);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Swipe\n   * triggers swipe events when the end velocity is above the threshold\n   * events  swipe, swipeleft, swiperight, swipeup, swipedown\n   */\n  ionic.Gestures.gestures.Swipe = {\n    name: 'swipe',\n    index: 40,\n    defaults: {\n      // set 0 for unlimited, but this can conflict with transform\n      swipe_max_touches  : 1,\n      swipe_velocity     : 0.7\n    },\n    handler: function swipeGesture(ev, inst) {\n      if(ev.eventType == ionic.Gestures.EVENT_END) {\n        // max touches\n        if(inst.options.swipe_max_touches > 0 &&\n            ev.touches.length > inst.options.swipe_max_touches) {\n              return;\n            }\n\n        // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n        if(ev.velocityX > inst.options.swipe_velocity ||\n            ev.velocityY > inst.options.swipe_velocity) {\n              // trigger swipe events\n              inst.trigger(this.name, ev);\n              inst.trigger(this.name + ev.direction, ev);\n            }\n      }\n    }\n  };\n\n\n  /**\n   * Drag\n   * Move with x fingers (default 1) around on the page. Blocking the scrolling when\n   * moving left and right is a good practice. When all the drag events are blocking\n   * you disable scrolling on that area.\n   * events  drag, drapleft, dragright, dragup, dragdown\n   */\n  ionic.Gestures.gestures.Drag = {\n    name: 'drag',\n    index: 50,\n    defaults: {\n      drag_min_distance : 10,\n      // Set correct_for_drag_min_distance to true to make the starting point of the drag\n      // be calculated from where the drag was triggered, not from where the touch started.\n      // Useful to avoid a jerk-starting drag, which can make fine-adjustments\n      // through dragging difficult, and be visually unappealing.\n      correct_for_drag_min_distance : true,\n      // set 0 for unlimited, but this can conflict with transform\n      drag_max_touches  : 1,\n      // prevent default browser behavior when dragging occurs\n      // be careful with it, it makes the element a blocking element\n      // when you are using the drag gesture, it is a good practice to set this true\n      drag_block_horizontal   : true,\n      drag_block_vertical     : true,\n      // drag_lock_to_axis keeps the drag gesture on the axis that it started on,\n      // It disallows vertical directions if the initial direction was horizontal, and vice versa.\n      drag_lock_to_axis       : false,\n      // drag lock only kicks in when distance > drag_lock_min_distance\n      // This way, locking occurs only when the distance has become large enough to reliably determine the direction\n      drag_lock_min_distance : 25\n    },\n    triggered: false,\n    handler: function dragGesture(ev, inst) {\n      // current gesture isnt drag, but dragged is true\n      // this means an other gesture is busy. now call dragend\n      if(ionic.Gestures.detection.current.name != this.name && this.triggered) {\n        inst.trigger(this.name +'end', ev);\n        this.triggered = false;\n        return;\n      }\n\n      // max touches\n      if(inst.options.drag_max_touches > 0 &&\n          ev.touches.length > inst.options.drag_max_touches) {\n            return;\n          }\n\n      switch(ev.eventType) {\n        case ionic.Gestures.EVENT_START:\n          this.triggered = false;\n          break;\n\n        case ionic.Gestures.EVENT_MOVE:\n          // when the distance we moved is too small we skip this gesture\n          // or we can be already in dragging\n          if(ev.distance < inst.options.drag_min_distance &&\n              ionic.Gestures.detection.current.name != this.name) {\n                return;\n              }\n\n          // we are dragging!\n          if(ionic.Gestures.detection.current.name != this.name) {\n            ionic.Gestures.detection.current.name = this.name;\n            if (inst.options.correct_for_drag_min_distance) {\n              // When a drag is triggered, set the event center to drag_min_distance pixels from the original event center.\n              // Without this correction, the dragged distance would jumpstart at drag_min_distance pixels instead of at 0.\n              // It might be useful to save the original start point somewhere\n              var factor = Math.abs(inst.options.drag_min_distance/ev.distance);\n              ionic.Gestures.detection.current.startEvent.center.pageX += ev.deltaX * factor;\n              ionic.Gestures.detection.current.startEvent.center.pageY += ev.deltaY * factor;\n\n              // recalculate event data using new start point\n              ev = ionic.Gestures.detection.extendEventData(ev);\n            }\n          }\n\n          // lock drag to axis?\n          if(ionic.Gestures.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance<=ev.distance)) {\n            ev.drag_locked_to_axis = true;\n          }\n          var last_direction = ionic.Gestures.detection.current.lastEvent.direction;\n          if(ev.drag_locked_to_axis && last_direction !== ev.direction) {\n            // keep direction on the axis that the drag gesture started on\n            if(ionic.Gestures.utils.isVertical(last_direction)) {\n              ev.direction = (ev.deltaY < 0) ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;\n            }\n            else {\n              ev.direction = (ev.deltaX < 0) ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;\n            }\n          }\n\n          // first time, trigger dragstart event\n          if(!this.triggered) {\n            inst.trigger(this.name +'start', ev);\n            this.triggered = true;\n          }\n\n          // trigger normal event\n          inst.trigger(this.name, ev);\n\n          // direction event, like dragdown\n          inst.trigger(this.name + ev.direction, ev);\n\n          // block the browser events\n          if( (inst.options.drag_block_vertical && ionic.Gestures.utils.isVertical(ev.direction)) ||\n              (inst.options.drag_block_horizontal && !ionic.Gestures.utils.isVertical(ev.direction))) {\n                ev.preventDefault();\n              }\n          break;\n\n        case ionic.Gestures.EVENT_END:\n          // trigger dragend\n          if(this.triggered) {\n            inst.trigger(this.name +'end', ev);\n          }\n\n          this.triggered = false;\n          break;\n      }\n    }\n  };\n\n\n  /**\n   * Transform\n   * User want to scale or rotate with 2 fingers\n   * events  transform, pinch, pinchin, pinchout, rotate\n   */\n  ionic.Gestures.gestures.Transform = {\n    name: 'transform',\n    index: 45,\n    defaults: {\n      // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1\n      transform_min_scale     : 0.01,\n      // rotation in degrees\n      transform_min_rotation  : 1,\n      // prevent default browser behavior when two touches are on the screen\n      // but it makes the element a blocking element\n      // when you are using the transform gesture, it is a good practice to set this true\n      transform_always_block  : false\n    },\n    triggered: false,\n    handler: function transformGesture(ev, inst) {\n      // current gesture isnt drag, but dragged is true\n      // this means an other gesture is busy. now call dragend\n      if(ionic.Gestures.detection.current.name != this.name && this.triggered) {\n        inst.trigger(this.name +'end', ev);\n        this.triggered = false;\n        return;\n      }\n\n      // atleast multitouch\n      if(ev.touches.length < 2) {\n        return;\n      }\n\n      // prevent default when two fingers are on the screen\n      if(inst.options.transform_always_block) {\n        ev.preventDefault();\n      }\n\n      switch(ev.eventType) {\n        case ionic.Gestures.EVENT_START:\n          this.triggered = false;\n          break;\n\n        case ionic.Gestures.EVENT_MOVE:\n          var scale_threshold = Math.abs(1-ev.scale);\n          var rotation_threshold = Math.abs(ev.rotation);\n\n          // when the distance we moved is too small we skip this gesture\n          // or we can be already in dragging\n          if(scale_threshold < inst.options.transform_min_scale &&\n              rotation_threshold < inst.options.transform_min_rotation) {\n                return;\n              }\n\n          // we are transforming!\n          ionic.Gestures.detection.current.name = this.name;\n\n          // first time, trigger dragstart event\n          if(!this.triggered) {\n            inst.trigger(this.name +'start', ev);\n            this.triggered = true;\n          }\n\n          inst.trigger(this.name, ev); // basic transform event\n\n          // trigger rotate event\n          if(rotation_threshold > inst.options.transform_min_rotation) {\n            inst.trigger('rotate', ev);\n          }\n\n          // trigger pinch event\n          if(scale_threshold > inst.options.transform_min_scale) {\n            inst.trigger('pinch', ev);\n            inst.trigger('pinch'+ ((ev.scale < 1) ? 'in' : 'out'), ev);\n          }\n          break;\n\n        case ionic.Gestures.EVENT_END:\n          // trigger dragend\n          if(this.triggered) {\n            inst.trigger(this.name +'end', ev);\n          }\n\n          this.triggered = false;\n          break;\n      }\n    }\n  };\n\n\n  /**\n   * Touch\n   * Called as first, tells the user has touched the screen\n   * events  touch\n   */\n  ionic.Gestures.gestures.Touch = {\n    name: 'touch',\n    index: -Infinity,\n    defaults: {\n      // call preventDefault at touchstart, and makes the element blocking by\n      // disabling the scrolling of the page, but it improves gestures like\n      // transforming and dragging.\n      // be careful with using this, it can be very annoying for users to be stuck\n      // on the page\n      prevent_default: false,\n\n      // disable mouse events, so only touch (or pen!) input triggers events\n      prevent_mouseevents: false\n    },\n    handler: function touchGesture(ev, inst) {\n      if(inst.options.prevent_mouseevents && ev.pointerType == ionic.Gestures.POINTER_MOUSE) {\n        ev.stopDetect();\n        return;\n      }\n\n      if(inst.options.prevent_default) {\n        ev.preventDefault();\n      }\n\n      if(ev.eventType ==  ionic.Gestures.EVENT_START) {\n        inst.trigger(this.name, ev);\n      }\n    }\n  };\n\n\n  /**\n   * Release\n   * Called as last, tells the user has released the screen\n   * events  release\n   */\n  ionic.Gestures.gestures.Release = {\n    name: 'release',\n    index: Infinity,\n    handler: function releaseGesture(ev, inst) {\n      if(ev.eventType ==  ionic.Gestures.EVENT_END) {\n        inst.trigger(this.name, ev);\n      }\n    }\n  };\n})(window.ionic);\n\n(function(window, document, ionic) {\n\n  /**\n   * @ngdoc utility\n   * @name ionic.Platform\n   * @module ionic\n   */\n  ionic.Platform = {\n\n    /**\n     * @ngdoc property\n     * @name ionic.Platform#isReady\n     * @returns {boolean} Whether the device is ready.\n     */\n    isReady: false,\n    /**\n     * @ngdoc property\n     * @name ionic.Platform#isFullScreen\n     * @returns {boolean} Whether the device is fullscreen.\n     */\n    isFullScreen: false,\n    /**\n     * @ngdoc property\n     * @name ionic.Platform#platforms\n     * @returns {Array(string)} An array of all platforms found.\n     */\n    platforms: null,\n    /**\n     * @ngdoc property\n     * @name ionic.Platform#grade\n     * @returns {string} What grade the current platform is.\n     */\n    grade: null,\n    ua: navigator.userAgent,\n\n    /**\n     * @ngdoc method\n     * @name ionic.Platform#ready\n     * @description\n     * Trigger a callback once the device is ready, or immediately\n     * if the device is already ready. This method can be run from\n     * anywhere and does not need to be wrapped by any additonal methods.\n     * When the app is within a WebView (Cordova), it'll fire\n     * the callback once the device is ready. If the app is within\n     * a web browser, it'll fire the callback after `window.load`.\n     * @param {function} callback The function to call.\n     */\n    ready: function(cb) {\n      // run through tasks to complete now that the device is ready\n      if(this.isReady) {\n        cb();\n      } else {\n        // the platform isn't ready yet, add it to this array\n        // which will be called once the platform is ready\n        readyCallbacks.push(cb);\n      }\n    },\n\n    /**\n     * @private\n     */\n    detect: function() {\n      ionic.Platform._checkPlatforms();\n\n      ionic.requestAnimationFrame(function(){\n        // only add to the body class if we got platform info\n        for(var i = 0; i < ionic.Platform.platforms.length; i++) {\n          document.body.classList.add('platform-' + ionic.Platform.platforms[i]);\n        }\n        document.body.classList.add('grade-' + ionic.Platform.grade);\n      });\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.Platform#device\n     * @description Return the current device (given by cordova).\n     * @returns {object} The device object.\n     */\n    device: function() {\n      if(window.device) return window.device;\n      if(this.isWebView()) void 0;\n      return {};\n    },\n\n    _checkPlatforms: function(platforms) {\n      this.platforms = [];\n      this.grade = 'a';\n\n      if(this.isWebView()) {\n        this.platforms.push('webview');\n        this.platforms.push('cordova');\n      }\n      if(this.isIPad()) this.platforms.push('ipad');\n\n      var platform = this.platform();\n      if(platform) {\n        this.platforms.push(platform);\n\n        var version = this.version();\n        if(version) {\n          var v = version.toString();\n          if(v.indexOf('.') > 0) {\n            v = v.replace('.', '_');\n          } else {\n            v += '_0';\n          }\n          this.platforms.push(platform + v.split('_')[0]);\n          this.platforms.push(platform + v);\n\n          if(this.isAndroid() && version < 4.4) {\n            this.grade = (version < 4 ? 'c' : 'b');\n          }\n        }\n      }\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.Platform#isWebView\n     * @returns {boolean} Check if we are running within a WebView (such as Cordova).\n     */\n    isWebView: function() {\n      return !(!window.cordova && !window.PhoneGap && !window.phonegap);\n    },\n    /**\n     * @ngdoc method\n     * @name ionic.Platform#isIPad\n     * @returns {boolean} Whether we are running on iPad.\n     */\n    isIPad: function() {\n      return this.ua.toLowerCase().indexOf('ipad') >= 0;\n    },\n    /**\n     * @ngdoc method\n     * @name ionic.Platform#isIOS\n     * @returns {boolean} Whether we are running on iOS.\n     */\n    isIOS: function() {\n      return this.is('ios');\n    },\n    /**\n     * @ngdoc method\n     * @name ionic.Platform#isAndroid\n     * @returns {boolean} Whether we are running on Android.\n     */\n    isAndroid: function() {\n      return this.is('android');\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.Platform#platform\n     * @returns {string} The name of the current platform.\n     */\n    platform: function() {\n      // singleton to get the platform name\n      if(platformName === null) this.setPlatform(this.device().platform);\n      return platformName;\n    },\n\n    /**\n     * @private\n     */\n    setPlatform: function(n) {\n      if(typeof n != 'undefined' && n !== null && n.length) {\n        platformName = n.toLowerCase();\n      } else if(this.ua.indexOf('Android') > 0) {\n        platformName = 'android';\n      } else if(this.ua.indexOf('iPhone') > -1 || this.ua.indexOf('iPad') > -1 || this.ua.indexOf('iPod') > -1) {\n        platformName = 'ios';\n      } else {\n        platformName = '';\n      }\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.Platform#version\n     * @returns {string} The version of the current device platform.\n     */\n    version: function() {\n      // singleton to get the platform version\n      if(platformVersion === null) this.setVersion(this.device().version);\n      return platformVersion;\n    },\n\n    /**\n     * @private\n     */\n    setVersion: function(v) {\n      if(typeof v != 'undefined' && v !== null) {\n        v = v.split('.');\n        v = parseFloat(v[0] + '.' + (v.length > 1 ? v[1] : 0));\n        if(!isNaN(v)) {\n          platformVersion = v;\n          return;\n        }\n      }\n\n      platformVersion = 0;\n\n      // fallback to user-agent checking\n      var pName = this.platform();\n      var versionMatch = {\n        'android': /Android (\\d+).(\\d+)?/,\n        'ios': /OS (\\d+)_(\\d+)?/\n      };\n      if(versionMatch[pName]) {\n        v = this.ua.match( versionMatch[pName] );\n        if(v.length > 2) {\n          platformVersion = parseFloat( v[1] + '.' + v[2] );\n        }\n      }\n    },\n\n    // Check if the platform is the one detected by cordova\n    is: function(type) {\n      type = type.toLowerCase();\n      // check if it has an array of platforms\n      if(this.platforms) {\n        for(var x = 0; x < this.platforms.length; x++) {\n          if(this.platforms[x] === type) return true;\n        }\n      }\n      // exact match\n      var pName = this.platform();\n      if(pName) {\n        return pName === type.toLowerCase();\n      }\n\n      // A quick hack for to check userAgent\n      return this.ua.toLowerCase().indexOf(type) >= 0;\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.Platform#exitApp\n     * @description Exit the app.\n     */\n    exitApp: function() {\n      this.ready(function(){\n        navigator.app && navigator.app.exitApp && navigator.app.exitApp();\n      });\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.Platform#showStatusBar\n     * @description Shows or hides the device status bar (in Cordova).\n     * @param {boolean} shouldShow Whether or not to show the status bar.\n     */\n    showStatusBar: function(val) {\n      // Only useful when run within cordova\n      this._showStatusBar = val;\n      this.ready(function(){\n        // run this only when or if the platform (cordova) is ready\n        ionic.requestAnimationFrame(function(){\n          if(ionic.Platform._showStatusBar) {\n            // they do not want it to be full screen\n            window.StatusBar && window.StatusBar.show();\n            document.body.classList.remove('status-bar-hide');\n          } else {\n            // it should be full screen\n            window.StatusBar && window.StatusBar.hide();\n            document.body.classList.add('status-bar-hide');\n          }\n        });\n      });\n    },\n\n    /**\n     * @ngdoc method\n     * @name ionic.Platform#fullScreen\n     * @description\n     * Sets whether the app is fullscreen or not (in Cordova).\n     * @param {boolean=} showFullScreen Whether or not to set the app to fullscreen. Defaults to true.\n     * @param {boolean=} showStatusBar Whether or not to show the device's status bar. Defaults to false.\n     */\n    fullScreen: function(showFullScreen, showStatusBar) {\n      // showFullScreen: default is true if no param provided\n      this.isFullScreen = (showFullScreen !== false);\n\n      // add/remove the fullscreen classname to the body\n      ionic.DomUtil.ready(function(){\n        // run this only when or if the DOM is ready\n        ionic.requestAnimationFrame(function(){\n          if(ionic.Platform.isFullScreen) {\n            document.body.classList.add('fullscreen');\n          } else {\n            document.body.classList.remove('fullscreen');\n          }\n        });\n        // showStatusBar: default is false if no param provided\n        ionic.Platform.showStatusBar( (showStatusBar === true) );\n      });\n    }\n\n  };\n\n  var platformName = null, // just the name, like iOS or Android\n  platformVersion = null, // a float of the major and minor, like 7.1\n  readyCallbacks = [];\n\n  // setup listeners to know when the device is ready to go\n  function onWindowLoad() {\n    if(ionic.Platform.isWebView()) {\n      // the window and scripts are fully loaded, and a cordova/phonegap\n      // object exists then let's listen for the deviceready\n      document.addEventListener(\"deviceready\", onPlatformReady, false);\n    } else {\n      // the window and scripts are fully loaded, but the window object doesn't have the\n      // cordova/phonegap object, so its just a browser, not a webview wrapped w/ cordova\n      onPlatformReady();\n    }\n    window.removeEventListener(\"load\", onWindowLoad, false);\n  }\n  window.addEventListener(\"load\", onWindowLoad, false);\n\n  function onPlatformReady() {\n    // the device is all set to go, init our own stuff then fire off our event\n    ionic.Platform.isReady = true;\n    ionic.Platform.detect();\n    for(var x=0; x<readyCallbacks.length; x++) {\n      // fire off all the callbacks that were added before the platform was ready\n      readyCallbacks[x]();\n    }\n    readyCallbacks = [];\n    ionic.trigger('platformready', { target: document });\n\n    ionic.requestAnimationFrame(function(){\n      document.body.classList.add('platform-ready');\n    });\n  }\n\n})(this, document, ionic);\n\n(function(document, ionic) {\n  'use strict';\n\n  // Ionic CSS polyfills\n  ionic.CSS = {};\n\n  (function() {\n\n    // transform\n    var i, keys = ['webkitTransform', 'transform', '-webkit-transform', 'webkit-transform',\n                '-moz-transform', 'moz-transform', 'MozTransform', 'mozTransform'];\n\n    for(i = 0; i < keys.length; i++) {\n      if(document.documentElement.style[keys[i]] !== undefined) {\n        ionic.CSS.TRANSFORM = keys[i];\n        break;\n      }\n    }\n\n    // transition\n    keys = ['webkitTransition', 'mozTransition', 'transition'];\n    for(i = 0; i < keys.length; i++) {\n      if(document.documentElement.style[keys[i]] !== undefined) {\n        ionic.CSS.TRANSITION = keys[i];\n        break;\n      }\n    }\n\n  })();\n\n  // classList polyfill for them older Androids\n  // https://gist.github.com/devongovett/1381839\n  if (!(\"classList\" in document.documentElement) && Object.defineProperty && typeof HTMLElement !== 'undefined') {\n    Object.defineProperty(HTMLElement.prototype, 'classList', {\n      get: function() {\n        var self = this;\n        function update(fn) {\n          return function() {\n            var x, classes = self.className.split(/\\s+/);\n\n            for(x=0; x<arguments.length; x++) {\n              fn(classes, classes.indexOf(arguments[x]), arguments[x]);\n            }\n\n            self.className = classes.join(\" \");\n          };\n        }\n\n        return {\n          add: update(function(classes, index, value) {\n            ~index || classes.push(value);\n          }),\n\n          remove: update(function(classes, index) {\n            ~index && classes.splice(index, 1);\n          }),\n\n          toggle: update(function(classes, index, value) {\n            ~index ? classes.splice(index, 1) : classes.push(value);\n          }),\n\n          contains: function(value) {\n            return !!~self.className.split(/\\s+/).indexOf(value);\n          },\n\n          item: function(i) {\n            return self.className.split(/\\s+/)[i] || null;\n          }\n        };\n\n      }\n    });\n  }\n\n})(document, ionic);\n\n\n/*\n\n IONIC TAP\n ---------------\n - Both touch and mouse events are added to the document.body on DOM ready\n - If a touch event happens, it removes the mouse event listeners (temporarily)\n - Remembers the last touchstart event\n - On touchend, if the distance between start and end was small, trigger a click\n - In the triggered click event, add a 'isIonicTap' property\n - The triggered click receives the same x,y coordinates as as the end event\n - On document.body click listener (with useCapture=true), only allow clicks with 'isIonicTap'\n - After XXms, bring back the mouse event listeners incase they switch from touch and mouse\n - If no touch events and only mouse, then touch events never fire, only mouse\n - Triggering clicks with mouse events work the same as touch, except with mousedown/mouseup\n - Tapping inputs is disabled during scrolling\n\n - Does not require other libraries to hook into ionic.tap, it just works\n - Elements can come and go from the DOM and it doesn't have to keep adding and removing listeners\n - No \"tap delay\" after the first \"tap\" (you can tap as fast as you want, they all click)\n - Minimal events listeners, only being added to document.body\n - Correct focus in/out on each input type on each platform/device\n - Shows and hides virtual keyboard correctly for each platform/device\n - No user-agent sniffing\n - Works with labels surrounding inputs\n - Does not fire off a click if the user moves the pointer too far\n - Adds and removes an 'activated' css class\n - Multiple unit tests for each scenario\n\n*/\n\nvar tapDoc; // the element which the listeners are on (document.body)\nvar tapActiveEle; // the element which is active (probably has focus)\nvar tapEnabledTouchEvents;\nvar tapMouseResetTimer;\nvar tapPointerMoved;\nvar tapPointerStart;\nvar tapTouchFocusedInput;\n\nvar TAP_RELEASE_TOLERANCE = 6; // how much the coordinates can be off between start/end, but still a click\n\nvar tapEventListeners = {\n  'click': tapClickGateKeeper,\n\n  'mousedown': tapMouseDown,\n  'mouseup': tapMouseUp,\n  'mousemove': tapMouseMove,\n\n  'touchstart': tapTouchStart,\n  'touchend': tapTouchEnd,\n  'touchcancel': tapTouchCancel,\n  'touchmove': tapTouchMove,\n\n  'focusin': tapFocusIn,\n  'focusout': tapFocusOut\n};\n\nionic.tap = {\n\n  register: function(ele) {\n    tapDoc = ele;\n\n    tapEventListener('click', true, true);\n    tapEventListener('mouseup');\n    tapEventListener('mousedown');\n    tapEventListener('touchstart');\n    tapEventListener('touchend');\n    tapEventListener('touchcancel');\n    tapEventListener('focusin');\n    tapEventListener('focusout');\n\n    return function() {\n      for(var type in tapEventListeners) {\n        tapEventListener(type, false);\n      }\n      tapDoc = null;\n      tapActiveEle = null;\n      tapEnabledTouchEvents = false;\n      tapPointerMoved = false;\n      tapPointerStart = null;\n    };\n  },\n\n  ignoreScrollStart: function(e) {\n    return (e.defaultPrevented) ||  // defaultPrevented has been assigned by another component handling the event\n           (e.target.isContentEditable) ||\n           (e.target.type === 'range') ||\n           (e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute('data-prevent-default')) == 'true' || // manually set within an elements attributes\n           (!!(/object|embed/i).test(e.target.tagName));  // flash/movie/object touches should not try to scroll\n  },\n\n  isTextInput: function(ele) {\n    return !!ele &&\n           (ele.tagName == 'TEXTAREA' ||\n            ele.contentEditable === 'true' ||\n            (ele.tagName == 'INPUT' && !(/radio|checkbox|range|file|submit|reset/i).test(ele.type)) );\n  },\n\n  isLabelWithTextInput: function(ele) {\n    var container = tapContainingElement(ele, false);\n\n    return !!container &&\n           ionic.tap.isTextInput( tapTargetElement( container ) );\n  },\n\n  containsOrIsTextInput: function(ele) {\n    return ionic.tap.isTextInput(ele) || ionic.tap.isLabelWithTextInput(ele);\n  },\n\n  cloneFocusedInput: function(container, scrollIntance) {\n    if(ionic.tap.hasCheckedClone) return;\n    ionic.tap.hasCheckedClone = true;\n\n    ionic.requestAnimationFrame(function(){\n      var focusInput = container.querySelector(':focus');\n      if( ionic.tap.isTextInput(focusInput) ) {\n        var clonedInput = focusInput.parentElement.querySelector('.cloned-text-input');\n        if(!clonedInput) {\n          clonedInput = document.createElement(focusInput.tagName);\n          clonedInput.type = focusInput.type;\n          clonedInput.value = focusInput.value;\n          clonedInput.className = 'cloned-text-input';\n          clonedInput.readOnly = true;\n          focusInput.parentElement.insertBefore(clonedInput, focusInput);\n          focusInput.style.top = focusInput.offsetTop;\n          focusInput.classList.add('previous-input-focus');\n        }\n      }\n    });\n  },\n\n  hasCheckedClone: false,\n\n  removeClonedInputs: function(container, scrollIntance) {\n    ionic.tap.hasCheckedClone = false;\n\n    ionic.requestAnimationFrame(function(){\n      var clonedInputs = container.querySelectorAll('.cloned-text-input');\n      var previousInputFocus = container.querySelectorAll('.previous-input-focus');\n      var x;\n\n      for(x=0; x<clonedInputs.length; x++) {\n        clonedInputs[x].parentElement.removeChild( clonedInputs[x] );\n      }\n\n      for(x=0; x<previousInputFocus.length; x++) {\n        previousInputFocus[x].classList.remove('previous-input-focus');\n        previousInputFocus[x].style.top = '';\n        previousInputFocus[x].focus();\n      }\n    });\n  }\n\n};\n\nfunction tapEventListener(type, enable, useCapture) {\n  if(enable !== false) {\n    tapDoc.addEventListener(type, tapEventListeners[type], useCapture);\n  } else {\n    tapDoc.removeEventListener(type, tapEventListeners[type]);\n  }\n}\n\nfunction tapClick(e) {\n  // simulate a normal click by running the element's click method then focus on it\n  var container = tapContainingElement(e.target);\n  var ele = tapTargetElement(container);\n\n  if( tapRequiresNativeClick(ele) || tapPointerMoved ) return false;\n\n  var c = getPointerCoordinates(e);\n\n  void 0;\n  triggerMouseEvent('click', ele, c.x, c.y);\n\n  // if it's an input, focus in on the target, otherwise blur\n  tapHandleFocus(ele);\n}\n\nfunction triggerMouseEvent(type, ele, x, y) {\n  // using initMouseEvent instead of MouseEvent for our Android friends\n  var clickEvent = document.createEvent(\"MouseEvents\");\n  clickEvent.initMouseEvent(type, true, true, window, 1, 0, 0, x, y, false, false, false, false, 0, null);\n  clickEvent.isIonicTap = true;\n  ele.dispatchEvent(clickEvent);\n}\n\nfunction tapClickGateKeeper(e) {\n  if(e.target.type == 'submit' && e.detail === 0) {\n    // do not prevent click if it came from an \"Enter\" or \"Go\" keypress submit\n    return;\n  }\n\n  // do not allow through any click events that were not created by ionic.tap\n  if( (ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target) ) ||\n      (!e.isIonicTap && !tapRequiresNativeClick(e.target)) ) {\n    void 0;\n    e.stopPropagation();\n\n    if( !ionic.tap.isLabelWithTextInput(e.target) ) {\n      // labels clicks from native should not preventDefault othersize keyboard will not show on input focus\n      e.preventDefault();\n    }\n    return false;\n  }\n}\n\nfunction tapRequiresNativeClick(ele) {\n  if(!ele || ele.disabled || (/file|range/i).test(ele.type) || (/object|video/i).test(ele.tagName) ) {\n    return true;\n  }\n  if(ele.nodeType === 1) {\n    var element = ele;\n    while(element) {\n      if( (element.dataset ? element.dataset.tapDisabled : element.getAttribute('data-tap-disabled')) == 'true' ) {\n        return true;\n      }\n      element = element.parentElement;\n    }\n  }\n  return false;\n}\n\n// MOUSE\nfunction tapMouseDown(e) {\n  if(e.isIonicTap || tapIgnoreEvent(e)) return;\n\n  if(tapEnabledTouchEvents) {\n    void 0;\n    e.stopPropagation();\n\n    if( !ionic.tap.isTextInput(e.target) ) {\n      // If you preventDefault on a text input then you cannot move its text caret/cursor.\n      // Allow through only the text input default. However, without preventDefault on an\n      // input the 300ms delay can change focus on inputs after the keyboard shows up.\n      // The focusin event handles the chance of focus changing after the keyboard shows.\n      e.preventDefault();\n    }\n\n    return false;\n  }\n\n  tapPointerMoved = false;\n  tapPointerStart = getPointerCoordinates(e);\n\n  tapEventListener('mousemove');\n  ionic.activator.start(e);\n}\n\nfunction tapMouseUp(e) {\n  if(tapEnabledTouchEvents) {\n    e.stopPropagation();\n    e.preventDefault();\n    return false;\n  }\n\n  if( tapIgnoreEvent(e) ) return;\n\n  if( !tapHasPointerMoved(e) ) {\n    tapClick(e);\n  }\n  tapEventListener('mousemove', false);\n  ionic.activator.end();\n  tapPointerMoved = false;\n}\n\nfunction tapMouseMove(e) {\n  if( tapHasPointerMoved(e) ) {\n    tapEventListener('mousemove', false);\n    ionic.activator.end();\n    tapPointerMoved = true;\n    return false;\n  }\n}\n\n\n// TOUCH\nfunction tapTouchStart(e) {\n  if( tapIgnoreEvent(e) ) return;\n\n  tapPointerMoved = false;\n\n  tapEnableTouchEvents();\n  tapPointerStart = getPointerCoordinates(e);\n\n  tapEventListener('touchmove');\n  ionic.activator.start(e);\n\n  if( ionic.Platform.isIOS() && ionic.tap.isLabelWithTextInput(e.target) ) {\n    // if the tapped element is a label, which has a child input\n    // then preventDefault so iOS doesn't ugly auto scroll to the input\n    // but do not prevent default on Android or else you cannot move the text caret\n    // and do not prevent default on Android or else no virtual keyboard shows up\n\n    var textInput = tapTargetElement( tapContainingElement(e.target) );\n    if( textInput !== tapActiveEle ) {\n      // don't preventDefault on an already focused input or else iOS's text caret isn't usable\n      e.preventDefault();\n    }\n  }\n}\n\nfunction tapTouchEnd(e) {\n  if( tapIgnoreEvent(e) ) return;\n\n  tapEnableTouchEvents();\n  if( !tapHasPointerMoved(e) ) {\n    tapClick(e);\n  }\n\n  tapTouchCancel();\n}\n\nfunction tapTouchMove(e) {\n  if( tapHasPointerMoved(e) ) {\n    tapPointerMoved = true;\n    tapEventListener('touchmove', false);\n    ionic.activator.end();\n    return false;\n  }\n}\n\nfunction tapTouchCancel(e) {\n  tapEventListener('touchmove', false);\n  ionic.activator.end();\n  tapPointerMoved = false;\n}\n\nfunction tapEnableTouchEvents() {\n  tapEnabledTouchEvents = true;\n  clearTimeout(tapMouseResetTimer);\n  tapMouseResetTimer = setTimeout(function(){\n    tapEnabledTouchEvents = false;\n  }, 2000);\n}\n\nfunction tapIgnoreEvent(e) {\n  if(e.isTapHandled) return true;\n  e.isTapHandled = true;\n\n  if( ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target) ) {\n    e.preventDefault();\n    return true;\n  }\n}\n\nfunction tapHandleFocus(ele) {\n  tapTouchFocusedInput = null;\n\n  var triggerFocusIn = false;\n\n  if(ele.tagName == 'SELECT') {\n    // trick to force Android options to show up\n    triggerMouseEvent('mousedown', ele, 0, 0);\n    ele.focus && ele.focus();\n    triggerFocusIn = true;\n\n  } else if(tapActiveElement() === ele) {\n    // already is the active element and has focus\n    triggerFocusIn = true;\n\n  } else if( (/input|textarea/i).test(ele.tagName) ) {\n    triggerFocusIn = true;\n    ele.focus && ele.focus();\n    ele.value = ele.value;\n    if( tapEnabledTouchEvents ) {\n      tapTouchFocusedInput = ele;\n    }\n\n  } else {\n    tapFocusOutActive();\n  }\n\n  if(triggerFocusIn) {\n    tapActiveElement(ele);\n    ionic.trigger('ionic.focusin', {\n      target: ele\n    }, true);\n  }\n}\n\nfunction tapFocusOutActive() {\n  var ele = tapActiveElement();\n  if(ele && (/input|textarea|select/i).test(ele.tagName) ) {\n    void 0;\n    ele.blur();\n  }\n  tapActiveElement(null);\n}\n\nfunction tapFocusIn(e) {\n  // Because a text input doesn't preventDefault (so the caret still works) there's a chance\n  // that it's mousedown event 300ms later will change the focus to another element after\n  // the keyboard shows up.\n\n  if( tapEnabledTouchEvents &&\n      ionic.tap.isTextInput( tapActiveElement() ) &&\n      ionic.tap.isTextInput(tapTouchFocusedInput) &&\n      tapTouchFocusedInput !== e.target ) {\n\n    // 1) The pointer is from touch events\n    // 2) There is an active element which is a text input\n    // 3) A text input was just set to be focused on by a touch event\n    // 4) A new focus has been set, however the target isn't the one the touch event wanted\n    void 0;\n    tapTouchFocusedInput.focus();\n    tapTouchFocusedInput = null;\n  }\n  ionic.scroll.isScrolling = false;\n}\n\nfunction tapFocusOut() {\n  tapActiveElement(null);\n}\n\nfunction tapActiveElement(ele) {\n  if(arguments.length) {\n    tapActiveEle = ele;\n  }\n  return tapActiveEle || document.activeElement;\n}\n\nfunction tapHasPointerMoved(endEvent) {\n  if(!endEvent || !tapPointerStart || ( tapPointerStart.x === 0 && tapPointerStart.y === 0 )) {\n    return false;\n  }\n  var endCoordinates = getPointerCoordinates(endEvent);\n\n  return Math.abs(tapPointerStart.x - endCoordinates.x) > TAP_RELEASE_TOLERANCE ||\n         Math.abs(tapPointerStart.y - endCoordinates.y) > TAP_RELEASE_TOLERANCE;\n}\n\nfunction getPointerCoordinates(event) {\n  // This method can get coordinates for both a mouse click\n  // or a touch depending on the given event\n  var c = { x:0, y:0 };\n  if(event) {\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var e = (event.changedTouches && event.changedTouches[0]) || touches[0];\n    if(e) {\n      c.x = e.clientX || e.pageX || 0;\n      c.y = e.clientY || e.pageY || 0;\n    }\n  }\n  return c;\n}\n\nfunction tapContainingElement(ele, allowSelf) {\n  var climbEle = ele;\n  for(var x=0; x<6; x++) {\n    if(!climbEle) break;\n    if(climbEle.tagName === 'LABEL') return climbEle;\n    climbEle = ele.parentElement;\n  }\n  if(allowSelf !== false) return ele;\n}\n\nfunction tapTargetElement(ele) {\n  if(ele && ele.tagName === 'LABEL') {\n    if(ele.control) return ele.control;\n\n    // older devices do not support the \"control\" property\n    if(ele.querySelector) {\n      var control = ele.querySelector('input,textarea,select');\n      if(control) return control;\n    }\n  }\n  return ele;\n}\n\nionic.DomUtil.ready(function(){\n  ionic.tap.register(document);\n});\n\n(function(document, ionic) {\n  'use strict';\n\n  var queueElements = {};   // elements that should get an active state in XX milliseconds\n  var activeElements = {};  // elements that are currently active\n  var keyId = 0;            // a counter for unique keys for the above ojects\n  var ACTIVATED_CLASS = 'activated';\n\n  ionic.activator = {\n\n    start: function(e) {\n      var self = this;\n\n      // when an element is touched/clicked, it climbs up a few\n      // parents to see if it is an .item or .button element\n      ionic.requestAnimationFrame(function(){\n        if (tapRequiresNativeClick(e.target)) return;\n        var ele = e.target;\n        var eleToActivate;\n\n        for(var x=0; x<4; x++) {\n          if(!ele || ele.nodeType !== 1) break;\n          if(eleToActivate && ele.classList.contains('item')) {\n            eleToActivate = ele;\n            break;\n          }\n          if( ele.tagName == 'A' || ele.tagName == 'BUTTON' || ele.hasAttribute('ng-click') ) {\n            eleToActivate = ele;\n          }\n          if( ele.classList.contains('button') ) {\n            eleToActivate = ele;\n            break;\n          }\n          ele = ele.parentElement;\n        }\n\n        if(eleToActivate) {\n          // queue that this element should be set to active\n          queueElements[keyId] = eleToActivate;\n\n          // in XX milliseconds, set the queued elements to active\n          if(e.type === 'touchstart') {\n            self._activateTimeout = setTimeout(activateElements, 80);\n          } else {\n            ionic.requestAnimationFrame(activateElements);\n          }\n\n          keyId = (keyId > 19 ? 0 : keyId + 1);\n        }\n\n      });\n    },\n\n    end: function() {\n      // clear out any active/queued elements after XX milliseconds\n      clearTimeout(this._activateTimeout)\n      setTimeout(clear, 200);\n    }\n\n  };\n\n  function clear() {\n    // clear out any elements that are queued to be set to active\n    queueElements = {};\n\n    // in the next frame, remove the active class from all active elements\n    ionic.requestAnimationFrame(deactivateElements);\n  }\n\n  function activateElements() {\n    // console.log('ACTIVATING');\n    // activate all elements in the queue\n    for(var key in queueElements) {\n      if(queueElements[key]) {\n        queueElements[key].classList.add(ACTIVATED_CLASS);\n        activeElements[key] = queueElements[key];\n      }\n    }\n    queueElements = {};\n  }\n\n  function deactivateElements() {\n    for(var key in activeElements) {\n      if(activeElements[key]) {\n        activeElements[key].classList.remove(ACTIVATED_CLASS);\n        delete activeElements[key];\n      }\n    }\n  }\n\n})(document, ionic);\n\n(function(ionic) {\n\n  /* for nextUid() function below */\n  var uid = ['0','0','0'];\n\n  /**\n   * Various utilities used throughout Ionic\n   *\n   * Some of these are adopted from underscore.js and backbone.js, both also MIT licensed.\n   */\n  ionic.Utils = {\n\n    arrayMove: function (arr, old_index, new_index) {\n      if (new_index >= arr.length) {\n        var k = new_index - arr.length;\n        while ((k--) + 1) {\n          arr.push(undefined);\n        }\n      }\n      arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);\n      return arr;\n    },\n\n    /**\n     * Return a function that will be called with the given context\n     */\n    proxy: function(func, context) {\n      var args = Array.prototype.slice.call(arguments, 2);\n      return function() {\n        return func.apply(context, args.concat(Array.prototype.slice.call(arguments)));\n      };\n    },\n\n    /**\n     * Only call a function once in the given interval.\n     *\n     * @param func {Function} the function to call\n     * @param wait {int} how long to wait before/after to allow function calls\n     * @param immediate {boolean} whether to call immediately or after the wait interval\n     */\n     debounce: function(func, wait, immediate) {\n      var timeout, args, context, timestamp, result;\n      return function() {\n        context = this;\n        args = arguments;\n        timestamp = new Date();\n        var later = function() {\n          var last = (new Date()) - timestamp;\n          if (last < wait) {\n            timeout = setTimeout(later, wait - last);\n          } else {\n            timeout = null;\n            if (!immediate) result = func.apply(context, args);\n          }\n        };\n        var callNow = immediate && !timeout;\n        if (!timeout) {\n          timeout = setTimeout(later, wait);\n        }\n        if (callNow) result = func.apply(context, args);\n        return result;\n      };\n    },\n\n    /**\n     * Throttle the given fun, only allowing it to be\n     * called at most every `wait` ms.\n     */\n    throttle: function(func, wait, options) {\n      var context, args, result;\n      var timeout = null;\n      var previous = 0;\n      options || (options = {});\n      var later = function() {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n      };\n      return function() {\n        var now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        var remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0) {\n          clearTimeout(timeout);\n          timeout = null;\n          previous = now;\n          result = func.apply(context, args);\n        } else if (!timeout && options.trailing !== false) {\n          timeout = setTimeout(later, remaining);\n        }\n        return result;\n      };\n    },\n     // Borrowed from Backbone.js's extend\n     // Helper function to correctly set up the prototype chain, for subclasses.\n     // Similar to `goog.inherits`, but uses a hash of prototype properties and\n     // class properties to be extended.\n    inherit: function(protoProps, staticProps) {\n      var parent = this;\n      var child;\n\n      // The constructor function for the new subclass is either defined by you\n      // (the \"constructor\" property in your `extend` definition), or defaulted\n      // by us to simply call the parent's constructor.\n      if (protoProps && protoProps.hasOwnProperty('constructor')) {\n        child = protoProps.constructor;\n      } else {\n        child = function(){ return parent.apply(this, arguments); };\n      }\n\n      // Add static properties to the constructor function, if supplied.\n      ionic.extend(child, parent, staticProps);\n\n      // Set the prototype chain to inherit from `parent`, without calling\n      // `parent`'s constructor function.\n      var Surrogate = function(){ this.constructor = child; };\n      Surrogate.prototype = parent.prototype;\n      child.prototype = new Surrogate;\n\n      // Add prototype properties (instance properties) to the subclass,\n      // if supplied.\n      if (protoProps) ionic.extend(child.prototype, protoProps);\n\n      // Set a convenience property in case the parent's prototype is needed\n      // later.\n      child.__super__ = parent.prototype;\n\n      return child;\n    },\n\n    // Extend adapted from Underscore.js\n    extend: function(obj) {\n       var args = Array.prototype.slice.call(arguments, 1);\n       for(var i = 0; i < args.length; i++) {\n         var source = args[i];\n         if (source) {\n           for (var prop in source) {\n             obj[prop] = source[prop];\n           }\n         }\n       }\n       return obj;\n    },\n\n    /**\n     * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric\n     * characters such as '012ABC'. The reason why we are not using simply a number counter is that\n     * the number string gets longer over time, and it can also overflow, where as the nextId\n     * will grow much slower, it is a string, and it will never overflow.\n     *\n     * @returns an unique alpha-numeric string\n     */\n    nextUid: function() {\n      var index = uid.length;\n      var digit;\n\n      while(index) {\n        index--;\n        digit = uid[index].charCodeAt(0);\n        if (digit == 57 /*'9'*/) {\n          uid[index] = 'A';\n          return uid.join('');\n        }\n        if (digit == 90  /*'Z'*/) {\n          uid[index] = '0';\n        } else {\n          uid[index] = String.fromCharCode(digit + 1);\n          return uid.join('');\n        }\n      }\n      uid.unshift('0');\n      return uid.join('');\n    }\n  };\n\n  // Bind a few of the most useful functions to the ionic scope\n  ionic.inherit = ionic.Utils.inherit;\n  ionic.extend = ionic.Utils.extend;\n  ionic.throttle = ionic.Utils.throttle;\n  ionic.proxy = ionic.Utils.proxy;\n  ionic.debounce = ionic.Utils.debounce;\n\n})(window.ionic);\n\n\n/*\nIONIC KEYBOARD\n---------------\n\n*/\n\nvar keyboardViewportHeight = window.innerHeight;\nvar keyboardIsOpen;\nvar keyboardActiveElement;\nvar keyboardFocusOutTimer;\nvar keyboardFocusInTimer;\n\nvar KEYBOARD_OPEN_CSS = 'keyboard-open';\nvar SCROLL_CONTAINER_CSS = 'scroll';\n\nionic.keyboard = {\n  isOpen: false,\n  height: null\n};\n\nfunction keyboardInit() {\n  if( keyboardHasPlugin() ) {\n    window.addEventListener('native.showkeyboard', keyboardNativeShow);\n  }\n\n  document.body.addEventListener('ionic.focusin', keyboardBrowserFocusIn);\n  document.body.addEventListener('focusin', keyboardBrowserFocusIn);\n\n  document.body.addEventListener('focusout', keyboardFocusOut);\n  document.body.addEventListener('orientationchange', keyboardOrientationChange);\n\n  document.removeEventListener('touchstart', keyboardInit);\n}\n\nfunction keyboardNativeShow(e) {\n  ionic.keyboard.height = e.keyboardHeight;\n}\n\nfunction keyboardBrowserFocusIn(e) {\n  if( !e.target || !ionic.tap.isTextInput(e.target) || !keyboardIsWithinScroll(e.target) ) return;\n\n  document.addEventListener('keydown', keyboardOnKeyDown, false);\n\n  document.body.scrollTop = 0;\n  document.body.querySelector('.scroll-content').scrollTop = 0;\n\n  keyboardActiveElement = e.target;\n\n  keyboardSetShow(e);\n}\n\nfunction keyboardSetShow(e) {\n  clearTimeout(keyboardFocusInTimer);\n  clearTimeout(keyboardFocusOutTimer);\n\n  keyboardFocusInTimer = setTimeout(function(){\n    var keyboardHeight = keyboardGetHeight();\n    var elementBounds = keyboardActiveElement.getBoundingClientRect();\n\n    keyboardShow(e.target, elementBounds.top, elementBounds.bottom, keyboardViewportHeight, keyboardHeight);\n  }, 32);\n}\n\nfunction keyboardShow(element, elementTop, elementBottom, viewportHeight, keyboardHeight) {\n  var details = {\n    target: element,\n    elementTop: Math.round(elementTop),\n    elementBottom: Math.round(elementBottom),\n    keyboardHeight: keyboardHeight\n  };\n\n  if( keyboardIsOverWebView() ) {\n    // keyboard sits on top of the view, but doesn't adjust the view's height\n    // lower the content height by subtracting the keyboard height from the view height\n    details.contentHeight = viewportHeight - keyboardHeight;\n  } else {\n    // view's height was shrunk down and the keyboard takes up the space the view doesn't fill\n    // do not add extra padding at the bottom of the scroll view, native already did that\n    details.contentHeight = viewportHeight;\n  }\n\n  void 0;\n\n  // distance from top of input to the top of the keyboard\n  details.keyboardTopOffset = details.elementTop - details.contentHeight;\n\n  void 0;\n\n  // figure out if the element is under the keyboard\n  details.isElementUnderKeyboard = (details.elementBottom > details.contentHeight);\n\n  ionic.keyboard.isOpen = true;\n\n  // send event so the scroll view adjusts\n  keyboardActiveElement = element;\n  ionic.trigger('scrollChildIntoView', details, true);\n\n  ionic.requestAnimationFrame(function(){\n    document.body.classList.add(KEYBOARD_OPEN_CSS);\n  });\n\n  // any showing part of the document that isn't within the scroll the user\n  // could touchmove and cause some ugly changes to the app, so disable\n  // any touchmove events while the keyboard is open using e.preventDefault()\n  document.addEventListener('touchmove', keyboardPreventDefault, false);\n\n  return details;\n}\n\nfunction keyboardFocusOut(e) {\n  clearTimeout(keyboardFocusInTimer);\n  clearTimeout(keyboardFocusOutTimer);\n\n  keyboardFocusOutTimer = setTimeout(keyboardHide, 350);\n}\n\nfunction keyboardHide() {\n  void 0;\n  ionic.keyboard.isOpen = false;\n\n  ionic.trigger('resetScrollView', {\n    target: keyboardActiveElement\n  }, true);\n\n  ionic.requestAnimationFrame(function(){\n    document.body.classList.remove(KEYBOARD_OPEN_CSS);\n  });\n\n  // the keyboard is gone now, remove the touchmove that disables native scroll\n  document.removeEventListener('touchmove', keyboardPreventDefault);\n  document.removeEventListener('keydown', keyboardOnKeyDown);\n}\n\nfunction keyboardUpdateViewportHeight() {\n  if( window.innerHeight > keyboardViewportHeight ) {\n    keyboardViewportHeight = window.innerHeight;\n  }\n}\n\nfunction keyboardOnKeyDown(e) {\n  if( ionic.scroll.isScrolling ) {\n    keyboardPreventDefault(e);\n  }\n}\n\nfunction keyboardPreventDefault(e) {\n  e.preventDefault();\n}\n\nfunction keyboardOrientationChange() {\n  keyboardViewportHeight = window.innerHeight;\n  setTimeout(function(){\n    keyboardViewportHeight = window.innerHeight;\n  }, 999);\n}\n\nfunction keyboardGetHeight() {\n  // check if we are already have a keyboard height from the plugin\n  if (ionic.keyboard.height ) {\n    return ionic.keyboard.height;\n  }\n\n  // fallback for when its the webview without the plugin\n  // or for just the standard web browser\n  if( ionic.Platform.isIOS() ) {\n    if( ionic.Platform.isWebView() ) {\n      return 260;\n    }\n    return 216;\n  } else if( ionic.Platform.isAndroid() ) {\n    if( ionic.Platform.isWebView() ) {\n      return 220;\n    }\n    if( ionic.Platform.version() <= 4.3) {\n      return 230;\n    }\n  }\n\n  // safe guess\n  return 275;\n}\n\nfunction keyboardIsWithinScroll(ele) {\n  while(ele) {\n    if(ele.classList.contains(SCROLL_CONTAINER_CSS)) {\n      return true;\n    }\n    ele = ele.parentElement;\n  }\n  return false;\n}\n\nfunction keyboardIsOverWebView() {\n  return ( ionic.Platform.isIOS() ) ||\n         ( ionic.Platform.isAndroid() && !ionic.Platform.isWebView() );\n}\n\nfunction keyboardHasPlugin() {\n  return !!(window.cordova && cordova.plugins && cordova.plugins.Keyboard);\n}\n\nionic.Platform.ready(function() {\n  keyboardUpdateViewportHeight();\n\n  // Android sometimes reports bad innerHeight on window.load\n  // try it again in a lil bit to play it safe\n  setTimeout(keyboardUpdateViewportHeight, 999);\n\n  // only initialize the adjustments for the virtual keyboard\n  // if a touchstart event happens\n  document.addEventListener('touchstart', keyboardInit, false);\n});\n\n\n\nvar viewportTag;\nvar viewportProperties = {};\n\n\nfunction viewportLoadTag() {\n  var x;\n\n  for(x=0; x<document.head.children.length; x++) {\n    if(document.head.children[x].name == 'viewport') {\n      viewportTag = document.head.children[x];\n      break;\n    }\n  }\n\n  if(viewportTag) {\n    var props = viewportTag.content.toLowerCase().replace(/\\s+/g, '').split(',');\n    var keyValue;\n    for(x=0; x<props.length; x++) {\n      keyValue = props[x].split('=');\n      if(keyValue.length == 2) viewportProperties[ keyValue[0] ] = keyValue[1];\n    }\n    viewportInitWebView();\n  }\n}\n\nfunction viewportInitWebView() {\n  var hasViewportChange = false;\n\n  if( ionic.Platform.isWebView() ) {\n    if( viewportProperties.height != 'device-height' ) {\n      viewportProperties.height = 'device-height';\n      hasViewportChange = true;\n    }\n  } else if( viewportProperties.height ) {\n    delete viewportProperties.height;\n    hasViewportChange = true;\n  }\n  if(hasViewportChange) viewportUpdate();\n}\n\nfunction viewportUpdate(updates) {\n  if(!viewportTag) return;\n\n  ionic.Utils.extend(viewportProperties, updates);\n\n  var key, props = [];\n  for(key in viewportProperties) {\n    if(viewportProperties[key]) props.push(key + '=' + viewportProperties[key]);\n  }\n\n  viewportTag.content = props.join(',');\n}\n\nionic.DomUtil.ready(function() {\n  viewportLoadTag();\n});\n\n(function(ionic) {\n'use strict';\n  ionic.views.View = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  ionic.views.View.inherit = ionic.inherit;\n\n  ionic.extend(ionic.views.View.prototype, {\n    initialize: function() {}\n  });\n\n})(window.ionic);\n\n/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\n\n/**\n * Generic animation class with support for dropped frames both optional easing and duration.\n *\n * Optional duration is useful when the lifetime is defined by another condition than time\n * e.g. speed of an animating object, etc.\n *\n * Dropped frame logic allows to keep using the same updater logic independent from the actual\n * rendering. This eases a lot of cases where it might be pretty complex to break down a state\n * based on the pure time difference.\n */\nvar zyngaCore = { effect: {} };\n(function(global) {\n  var time = Date.now || function() {\n    return +new Date();\n  };\n  var desiredFrames = 60;\n  var millisecondsPerSecond = 1000;\n  var running = {};\n  var counter = 1;\n\n  zyngaCore.effect.Animate = {\n\n    /**\n     * A requestAnimationFrame wrapper / polyfill.\n     *\n     * @param callback {Function} The callback to be invoked before the next repaint.\n     * @param root {HTMLElement} The root element for the repaint\n     */\n    requestAnimationFrame: (function() {\n\n      // Check for request animation Frame support\n      var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;\n      var isNative = !!requestFrame;\n\n      if (requestFrame && !/requestAnimationFrame\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}/i.test(requestFrame.toString())) {\n        isNative = false;\n      }\n\n      if (isNative) {\n        return function(callback, root) {\n          requestFrame(callback, root)\n        };\n      }\n\n      var TARGET_FPS = 60;\n      var requests = {};\n      var requestCount = 0;\n      var rafHandle = 1;\n      var intervalHandle = null;\n      var lastActive = +new Date();\n\n      return function(callback, root) {\n        var callbackHandle = rafHandle++;\n\n        // Store callback\n        requests[callbackHandle] = callback;\n        requestCount++;\n\n        // Create timeout at first request\n        if (intervalHandle === null) {\n\n          intervalHandle = setInterval(function() {\n\n            var time = +new Date();\n            var currentRequests = requests;\n\n            // Reset data structure before executing callbacks\n            requests = {};\n            requestCount = 0;\n\n            for(var key in currentRequests) {\n              if (currentRequests.hasOwnProperty(key)) {\n                currentRequests[key](time);\n                lastActive = time;\n              }\n            }\n\n            // Disable the timeout when nothing happens for a certain\n            // period of time\n            if (time - lastActive > 2500) {\n              clearInterval(intervalHandle);\n              intervalHandle = null;\n            }\n\n          }, 1000 / TARGET_FPS);\n        }\n\n        return callbackHandle;\n      };\n\n    })(),\n\n\n    /**\n     * Stops the given animation.\n     *\n     * @param id {Integer} Unique animation ID\n     * @return {Boolean} Whether the animation was stopped (aka, was running before)\n     */\n    stop: function(id) {\n      var cleared = running[id] != null;\n      if (cleared) {\n        running[id] = null;\n      }\n\n      return cleared;\n    },\n\n\n    /**\n     * Whether the given animation is still running.\n     *\n     * @param id {Integer} Unique animation ID\n     * @return {Boolean} Whether the animation is still running\n     */\n    isRunning: function(id) {\n      return running[id] != null;\n    },\n\n\n    /**\n     * Start the animation.\n     *\n     * @param stepCallback {Function} Pointer to function which is executed on every step.\n     *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\n     * @param verifyCallback {Function} Executed before every animation step.\n     *   Signature of the method should be `function() { return continueWithAnimation; }`\n     * @param completedCallback {Function}\n     *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\n     * @param duration {Integer} Milliseconds to run the animation\n     * @param easingMethod {Function} Pointer to easing function\n     *   Signature of the method should be `function(percent) { return modifiedValue; }`\n     * @param root {Element} Render root, when available. Used for internal\n     *   usage of requestAnimationFrame.\n     * @return {Integer} Identifier of animation. Can be used to stop it any time.\n     */\n    start: function(stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {\n\n      var start = time();\n      var lastFrame = start;\n      var percent = 0;\n      var dropCounter = 0;\n      var id = counter++;\n\n      if (!root) {\n        root = document.body;\n      }\n\n      // Compacting running db automatically every few new animations\n      if (id % 20 === 0) {\n        var newRunning = {};\n        for (var usedId in running) {\n          newRunning[usedId] = true;\n        }\n        running = newRunning;\n      }\n\n      // This is the internal step method which is called every few milliseconds\n      var step = function(virtual) {\n\n        // Normalize virtual value\n        var render = virtual !== true;\n\n        // Get current time\n        var now = time();\n\n        // Verification is executed before next animation step\n        if (!running[id] || (verifyCallback && !verifyCallback(id))) {\n\n          running[id] = null;\n          completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, false);\n          return;\n\n        }\n\n        // For the current rendering to apply let's update omitted steps in memory.\n        // This is important to bring internal state variables up-to-date with progress in time.\n        if (render) {\n\n          var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;\n          for (var j = 0; j < Math.min(droppedFrames, 4); j++) {\n            step(true);\n            dropCounter++;\n          }\n\n        }\n\n        // Compute percent value\n        if (duration) {\n          percent = (now - start) / duration;\n          if (percent > 1) {\n            percent = 1;\n          }\n        }\n\n        // Execute step callback, then...\n        var value = easingMethod ? easingMethod(percent) : percent;\n        if ((stepCallback(value, now, render) === false || percent === 1) && render) {\n          running[id] = null;\n          completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, percent === 1 || duration == null);\n        } else if (render) {\n          lastFrame = now;\n          zyngaCore.effect.Animate.requestAnimationFrame(step, root);\n        }\n      };\n\n      // Mark as running\n      running[id] = true;\n\n      // Init first step\n      zyngaCore.effect.Animate.requestAnimationFrame(step, root);\n\n      // Return unique animation ID\n      return id;\n    }\n  };\n})(this);\n\n/*\n * Scrollbarer\n * http://github.com/zynga/scroller\n *\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\n\nvar Scroller;\n\n(function(ionic) {\n  var NOOP = function(){};\n\n  // Easing Equations (c) 2003 Robert Penner, all rights reserved.\n  // Open source under the BSD License.\n\n  /**\n   * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n  **/\n  var easeOutCubic = function(pos) {\n    return (Math.pow((pos - 1), 3) + 1);\n  };\n\n  /**\n   * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n  **/\n  var easeInOutCubic = function(pos) {\n    if ((pos /= 0.5) < 1) {\n      return 0.5 * Math.pow(pos, 3);\n    }\n\n    return 0.5 * (Math.pow((pos - 2), 3) + 2);\n  };\n\n\n/**\n * ionic.views.Scroll\n * A powerful scroll view with support for bouncing, pull to refresh, and paging.\n * @param   {Object}        options options for the scroll view\n * @class A scroll view system\n * @memberof ionic.views\n */\nionic.views.Scroll = ionic.views.View.inherit({\n  initialize: function(options) {\n    var self = this;\n\n    this.__container = options.el;\n    this.__content = options.el.firstElementChild;\n\n    //Remove any scrollTop attached to these elements; they are virtual scroll now\n    //This also stops on-load-scroll-to-window.location.hash that the browser does\n    setTimeout(function() {\n      if (self.__container && self.__content) {\n        self.__container.scrollTop = 0;\n        self.__content.scrollTop = 0;\n      }\n    });\n\n    this.options = {\n\n      /** Disable scrolling on x-axis by default */\n      scrollingX: false,\n      scrollbarX: true,\n\n      /** Enable scrolling on y-axis */\n      scrollingY: true,\n      scrollbarY: true,\n\n      startX: 0,\n      startY: 0,\n\n      /** The amount to dampen mousewheel events */\n      wheelDampen: 6,\n\n      /** The minimum size the scrollbars scale to while scrolling */\n      minScrollbarSizeX: 5,\n      minScrollbarSizeY: 5,\n\n      /** Scrollbar fading after scrolling */\n      scrollbarsFade: true,\n      scrollbarFadeDelay: 300,\n      /** The initial fade delay when the pane is resized or initialized */\n      scrollbarResizeFadeDelay: 1000,\n\n      /** Enable animations for deceleration, snap back, zooming and scrolling */\n      animating: true,\n\n      /** duration for animations triggered by scrollTo/zoomTo */\n      animationDuration: 250,\n\n      /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n      bouncing: true,\n\n      /** Enable locking to the main axis if user moves only slightly on one of them at start */\n      locking: true,\n\n      /** Enable pagination mode (switching between full page content panes) */\n      paging: false,\n\n      /** Enable snapping of content to a configured pixel grid */\n      snapping: false,\n\n      /** Enable zooming of content via API, fingers and mouse wheel */\n      zooming: false,\n\n      /** Minimum zoom level */\n      minZoom: 0.5,\n\n      /** Maximum zoom level */\n      maxZoom: 3,\n\n      /** Multiply or decrease scrolling speed **/\n      speedMultiplier: 1,\n\n      /** Callback that is fired on the later of touch end or deceleration end,\n        provided that another scrolling action has not begun. Used to know\n        when to fade out a scrollbar. */\n      scrollingComplete: NOOP,\n\n      /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n      penetrationDeceleration : 0.03,\n\n      /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n      penetrationAcceleration : 0.08,\n\n      // The ms interval for triggering scroll events\n      scrollEventInterval: 10,\n\n      getContentWidth: function() {\n        return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);\n      },\n      getContentHeight: function() {\n        return Math.max(self.__content.scrollHeight, self.__content.offsetHeight);\n      }\n\t\t};\n\n    for (var key in options) {\n      this.options[key] = options[key];\n    }\n\n    this.hintResize = ionic.debounce(function() {\n      self.resize();\n    }, 1000, true);\n\n    this.onScroll = function(scrollTop) {\n\n      if(!ionic.scroll.isScrolling) {\n        setTimeout(self.setScrollStart, 50);\n      } else {\n        clearTimeout(self.scrollTimer);\n        self.scrollTimer = setTimeout(self.setScrollStop, 80);\n      }\n\n    };\n\n    this.setScrollStart = function() {\n      ionic.scroll.isScrolling = Math.abs(ionic.scroll.lastTop - self.__scrollTop) > 1;\n      clearTimeout(self.scrollTimer);\n      self.scrollTimer = setTimeout(self.setScrollStop, 80);\n    };\n\n    this.setScrollStop = function() {\n      ionic.scroll.isScrolling = false;\n      ionic.scroll.lastTop = self.__scrollTop;\n    };\n\n    this.triggerScrollEvent = ionic.throttle(function() {\n      ionic.trigger('scroll', {\n        scrollTop: self.__scrollTop,\n        scrollLeft: self.__scrollLeft,\n        target: self.__container\n      });\n    }, this.options.scrollEventInterval);\n\n    this.triggerScrollEndEvent = function() {\n      ionic.trigger('scrollend', {\n        scrollTop: self.__scrollTop,\n        scrollLeft: self.__scrollLeft,\n        target: self.__container\n      });\n    };\n\n    this.__scrollLeft = this.options.startX;\n    this.__scrollTop = this.options.startY;\n\n    // Get the render update function, initialize event handlers,\n    // and calculate the size of the scroll container\n    this.__callback = this.getRenderFn();\n    this.__initEventHandlers();\n    this.__createScrollbars();\n\n  },\n\n  run: function() {\n    this.resize();\n\n    // Fade them out\n    this.__fadeScrollbars('out', this.options.scrollbarResizeFadeDelay);\n  },\n\n\n\n  /*\n  ---------------------------------------------------------------------------\n    INTERNAL FIELDS :: STATUS\n  ---------------------------------------------------------------------------\n  */\n\n  /** Whether only a single finger is used in touch handling */\n  __isSingleTouch: false,\n\n  /** Whether a touch event sequence is in progress */\n  __isTracking: false,\n\n  /** Whether a deceleration animation went to completion. */\n  __didDecelerationComplete: false,\n\n  /**\n   * Whether a gesture zoom/rotate event is in progress. Activates when\n   * a gesturestart event happens. This has higher priority than dragging.\n   */\n  __isGesturing: false,\n\n  /**\n   * Whether the user has moved by such a distance that we have enabled\n   * dragging mode. Hint: It's only enabled after some pixels of movement to\n   * not interrupt with clicks etc.\n   */\n  __isDragging: false,\n\n  /**\n   * Not touching and dragging anymore, and smoothly animating the\n   * touch sequence using deceleration.\n   */\n  __isDecelerating: false,\n\n  /**\n   * Smoothly animating the currently configured change\n   */\n  __isAnimating: false,\n\n\n\n  /*\n  ---------------------------------------------------------------------------\n    INTERNAL FIELDS :: DIMENSIONS\n  ---------------------------------------------------------------------------\n  */\n\n  /** Available outer left position (from document perspective) */\n  __clientLeft: 0,\n\n  /** Available outer top position (from document perspective) */\n  __clientTop: 0,\n\n  /** Available outer width */\n  __clientWidth: 0,\n\n  /** Available outer height */\n  __clientHeight: 0,\n\n  /** Outer width of content */\n  __contentWidth: 0,\n\n  /** Outer height of content */\n  __contentHeight: 0,\n\n  /** Snapping width for content */\n  __snapWidth: 100,\n\n  /** Snapping height for content */\n  __snapHeight: 100,\n\n  /** Height to assign to refresh area */\n  __refreshHeight: null,\n\n  /** Whether the refresh process is enabled when the event is released now */\n  __refreshActive: false,\n\n  /** Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\n  __refreshActivate: null,\n\n  /** Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\n  __refreshDeactivate: null,\n\n  /** Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\n  __refreshStart: null,\n\n  /** Zoom level */\n  __zoomLevel: 1,\n\n  /** Scroll position on x-axis */\n  __scrollLeft: 0,\n\n  /** Scroll position on y-axis */\n  __scrollTop: 0,\n\n  /** Maximum allowed scroll position on x-axis */\n  __maxScrollLeft: 0,\n\n  /** Maximum allowed scroll position on y-axis */\n  __maxScrollTop: 0,\n\n  /* Scheduled left position (final position when animating) */\n  __scheduledLeft: 0,\n\n  /* Scheduled top position (final position when animating) */\n  __scheduledTop: 0,\n\n  /* Scheduled zoom level (final scale when animating) */\n  __scheduledZoom: 0,\n\n\n\n  /*\n  ---------------------------------------------------------------------------\n    INTERNAL FIELDS :: LAST POSITIONS\n  ---------------------------------------------------------------------------\n  */\n\n  /** Left position of finger at start */\n  __lastTouchLeft: null,\n\n  /** Top position of finger at start */\n  __lastTouchTop: null,\n\n  /** Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\n  __lastTouchMove: null,\n\n  /** List of positions, uses three indexes for each state: left, top, timestamp */\n  __positions: null,\n\n\n\n  /*\n  ---------------------------------------------------------------------------\n    INTERNAL FIELDS :: DECELERATION SUPPORT\n  ---------------------------------------------------------------------------\n  */\n\n  /** Minimum left scroll position during deceleration */\n  __minDecelerationScrollLeft: null,\n\n  /** Minimum top scroll position during deceleration */\n  __minDecelerationScrollTop: null,\n\n  /** Maximum left scroll position during deceleration */\n  __maxDecelerationScrollLeft: null,\n\n  /** Maximum top scroll position during deceleration */\n  __maxDecelerationScrollTop: null,\n\n  /** Current factor to modify horizontal scroll position with on every step */\n  __decelerationVelocityX: null,\n\n  /** Current factor to modify vertical scroll position with on every step */\n  __decelerationVelocityY: null,\n\n\n  /** the browser-specific property to use for transforms */\n  __transformProperty: null,\n  __perspectiveProperty: null,\n\n  /** scrollbar indicators */\n  __indicatorX: null,\n  __indicatorY: null,\n\n  /** Timeout for scrollbar fading */\n  __scrollbarFadeTimeout: null,\n\n  /** whether we've tried to wait for size already */\n  __didWaitForSize: null,\n  __sizerTimeout: null,\n\n  __initEventHandlers: function() {\n    var self = this;\n\n    // Event Handler\n    var container = this.__container;\n\n    //Broadcasted when keyboard is shown on some platforms.\n    //See js/utils/keyboard.js\n    container.addEventListener('scrollChildIntoView', function(e) {\n      if( !self.isScrolledIntoView ) {\n        // shrink scrollview so we can actually scroll if the input is hidden\n        // if it isn't shrink so we can scroll to inputs under the keyboard\n        container.style.height = (container.clientHeight - e.detail.keyboardHeight) + \"px\";\n        container.style.overflow = \"visible\";\n        self.isScrolledIntoView = true;\n        //update scroll view\n        self.resize();\n      }\n\n      //If the element is positioned under the keyboard...\n      if( e.detail.isElementUnderKeyboard ) {\n        //Put element in middle of visible screen\n        //Wait for resize() to reset scroll position\n        ionic.scroll.isScrolling = true;\n        setTimeout(function(){\n          //middle of the scrollview, where we want to scroll to\n          var scrollViewMidpointOffset = container.clientHeight * 0.5;\n          var scrollTop = e.detail.keyboardTopOffset + scrollViewMidpointOffset;\n          void 0;\n          ionic.tap.cloneFocusedInput(container, self);\n          self.scrollBy(0, scrollTop, true);\n          self.onScroll();\n        },\n          (ionic.Platform.isIOS() ? 80 : 350)\n        );\n      }\n\n      //Only the first scrollView parent of the element that broadcasted this event\n      //(the active element that needs to be shown) should receive this event\n      e.stopPropagation();\n    });\n\n    container.addEventListener('resetScrollView', function(e) {\n      //return scrollview to original height once keyboard has hidden\n      self.isScrolledIntoView = false;\n      container.style.height = \"\";\n      container.style.overflow = \"\";\n      self.resize();\n      ionic.scroll.isScrolling = false;\n    });\n\n\n    self.touchStart = function(e) {\n      self.startCoordinates = getPointerCoordinates(e);\n\n      if ( ionic.tap.ignoreScrollStart(e) ) {\n        return;\n      }\n\n      if( ionic.tap.containsOrIsTextInput(e.target) ) {\n        // do not start if the target is a text input\n        // if there is a touchmove on this input, then we can start the scroll\n        self.__hasStarted = false;\n        return;\n      }\n\n      self.__isSelectable = true;\n      self.__enableScrollY = true;\n      self.__hasStarted = true;\n      self.doTouchStart(e.touches, e.timeStamp);\n      e.preventDefault();\n    };\n\n    self.touchMove = function(e) {\n      if(e.defaultPrevented) {\n        return;\n      }\n\n      if( !self.__hasStarted && ionic.tap.containsOrIsTextInput(e.target) ) {\n        // the target is a text input and scroll has started\n        // since the text input doesn't start on touchStart, do it here\n        self.__hasStarted = true;\n        self.doTouchStart(e.touches, e.timeStamp);\n        e.preventDefault();\n        return;\n      }\n\n      if(self.startCoordinates) {\n        // we have start coordinates, so get this touch move's current coordinates\n        var currentCoordinates = getPointerCoordinates(e);\n\n        if( self.__isSelectable &&\n            ionic.tap.isTextInput(e.target) &&\n            Math.abs(self.startCoordinates.x - currentCoordinates.x) > 20 ) {\n          // user slid the text input's caret on its x axis, disable any future y scrolling\n          self.__enableScrollY = false;\n          self.__isSelectable = true;\n        }\n\n        if( self.__enableScrollY && Math.abs(self.startCoordinates.y - currentCoordinates.y) > 10 ) {\n          // user scrolled the entire view on the y axis\n          // disabled being able to select text on an input\n          // hide the input which has focus, and show a cloned one that doesn't have focus\n          self.__isSelectable = false;\n          ionic.tap.cloneFocusedInput(container, self);\n        }\n      }\n\n      self.doTouchMove(e.touches, e.timeStamp, e.scale);\n    };\n\n    self.touchEnd = function(e) {\n      self.doTouchEnd(e.timeStamp);\n      self.__hasStarted = false;\n      self.__isSelectable = true;\n      self.__enableScrollY = true;\n\n      if( !self.__isDragging && !self.__isDecelerating && !self.__isAnimating ) {\n        ionic.tap.removeClonedInputs(container, self);\n      }\n    };\n\n    self.options.orgScrollingComplete = self.options.scrollingComplete;\n    self.options.scrollingComplete = function() {\n      ionic.tap.removeClonedInputs(container, self);\n      self.options.orgScrollingComplete();\n    };\n\n\n    if ('ontouchstart' in window) {\n      container.addEventListener(\"touchstart\", self.touchStart, false);\n      document.addEventListener(\"touchmove\", self.touchMove, false);\n      document.addEventListener(\"touchend\", self.touchEnd, false);\n      document.addEventListener(\"touchcancel\", self.touchEnd, false);\n\n    } else {\n\n      var mousedown = false;\n\n      container.addEventListener(\"mousedown\", function(e) {\n        if ( ionic.tap.ignoreScrollStart(e) || e.target.tagName === 'SELECT' ) {\n          return;\n        }\n        self.doTouchStart([{\n          pageX: e.pageX,\n          pageY: e.pageY\n        }], e.timeStamp);\n\n        e.preventDefault();\n        mousedown = true;\n      }, false);\n\n      document.addEventListener(\"mousemove\", function(e) {\n        if (!mousedown || e.defaultPrevented) {\n          return;\n        }\n\n        self.doTouchMove([{\n          pageX: e.pageX,\n          pageY: e.pageY\n        }], e.timeStamp);\n\n        mousedown = true;\n      }, false);\n\n      document.addEventListener(\"mouseup\", function(e) {\n        if (!mousedown) {\n          return;\n        }\n\n        self.doTouchEnd(e.timeStamp);\n\n        mousedown = false;\n      }, false);\n\n      var wheelShowBarFn = ionic.debounce(function() {\n        self.__fadeScrollbars('in');\n      }, 500, true);\n\n      var wheelHideBarFn = ionic.debounce(function() {\n        self.__fadeScrollbars('out');\n      }, 100, false);\n\n      document.addEventListener(\"mousewheel\", function(e) {\n        wheelShowBarFn();\n        self.scrollBy(e.wheelDeltaX/self.options.wheelDampen, -e.wheelDeltaY/self.options.wheelDampen);\n        wheelHideBarFn();\n      });\n    }\n  },\n\n  /** Create a scroll bar div with the given direction **/\n  __createScrollbar: function(direction) {\n    var bar = document.createElement('div'),\n      indicator = document.createElement('div');\n\n    indicator.className = 'scroll-bar-indicator';\n\n    if(direction == 'h') {\n      bar.className = 'scroll-bar scroll-bar-h';\n    } else {\n      bar.className = 'scroll-bar scroll-bar-v';\n    }\n\n    bar.appendChild(indicator);\n    return bar;\n  },\n\n  __createScrollbars: function() {\n    var indicatorX, indicatorY;\n\n    if(this.options.scrollingX) {\n      indicatorX = {\n        el: this.__createScrollbar('h'),\n        sizeRatio: 1\n      };\n      indicatorX.indicator = indicatorX.el.children[0];\n\n      if(this.options.scrollbarX) {\n        this.__container.appendChild(indicatorX.el);\n      }\n      this.__indicatorX = indicatorX;\n    }\n\n    if(this.options.scrollingY) {\n      indicatorY = {\n        el: this.__createScrollbar('v'),\n        sizeRatio: 1\n      };\n      indicatorY.indicator = indicatorY.el.children[0];\n\n      if(this.options.scrollbarY) {\n        this.__container.appendChild(indicatorY.el);\n      }\n      this.__indicatorY = indicatorY;\n    }\n  },\n\n  __resizeScrollbars: function() {\n    var self = this;\n\n    // Update horiz bar\n    if(self.__indicatorX) {\n      var width = Math.max(Math.round(self.__clientWidth * self.__clientWidth / (self.__contentWidth)), 20);\n      if(width > self.__contentWidth) {\n        width = 0;\n      }\n      self.__indicatorX.size = width;\n      self.__indicatorX.minScale = this.options.minScrollbarSizeX / width;\n      self.__indicatorX.indicator.style.width = width + 'px';\n      self.__indicatorX.maxPos = self.__clientWidth - width;\n      self.__indicatorX.sizeRatio = self.__maxScrollLeft ? self.__indicatorX.maxPos / self.__maxScrollLeft : 1;\n    }\n\n    // Update vert bar\n    if(self.__indicatorY) {\n      var height = Math.max(Math.round(self.__clientHeight * self.__clientHeight / (self.__contentHeight)), 20);\n      if(height > self.__contentHeight) {\n        height = 0;\n      }\n      self.__indicatorY.size = height;\n      self.__indicatorY.minScale = this.options.minScrollbarSizeY / height;\n      self.__indicatorY.maxPos = self.__clientHeight - height;\n      self.__indicatorY.indicator.style.height = height + 'px';\n      self.__indicatorY.sizeRatio = self.__maxScrollTop ? self.__indicatorY.maxPos / self.__maxScrollTop : 1;\n    }\n  },\n\n  /**\n   * Move and scale the scrollbars as the page scrolls.\n   */\n  __repositionScrollbars: function() {\n    var self = this, width, heightScale,\n        widthDiff, heightDiff,\n        x, y,\n        xstop = 0, ystop = 0;\n\n    if(self.__indicatorX) {\n      // Handle the X scrollbar\n\n      // Don't go all the way to the right if we have a vertical scrollbar as well\n      if(self.__indicatorY) xstop = 10;\n\n      x = Math.round(self.__indicatorX.sizeRatio * self.__scrollLeft) || 0,\n\n      // The the difference between the last content X position, and our overscrolled one\n      widthDiff = self.__scrollLeft - (self.__maxScrollLeft - xstop);\n\n      if(self.__scrollLeft < 0) {\n\n        widthScale = Math.max(self.__indicatorX.minScale,\n            (self.__indicatorX.size - Math.abs(self.__scrollLeft)) / self.__indicatorX.size);\n\n        // Stay at left\n        x = 0;\n\n        // Make sure scale is transformed from the left/center origin point\n        self.__indicatorX.indicator.style[self.__transformOriginProperty] = 'left center';\n      } else if(widthDiff > 0) {\n\n        widthScale = Math.max(self.__indicatorX.minScale,\n            (self.__indicatorX.size - widthDiff) / self.__indicatorX.size);\n\n        // Stay at the furthest x for the scrollable viewport\n        x = self.__indicatorX.maxPos - xstop;\n\n        // Make sure scale is transformed from the right/center origin point\n        self.__indicatorX.indicator.style[self.__transformOriginProperty] = 'right center';\n\n      } else {\n\n        // Normal motion\n        x = Math.min(self.__maxScrollLeft, Math.max(0, x));\n        widthScale = 1;\n\n      }\n\n      self.__indicatorX.indicator.style[self.__transformProperty] = 'translate3d(' + x + 'px, 0, 0) scaleX(' + widthScale + ')';\n    }\n\n    if(self.__indicatorY) {\n\n      y = Math.round(self.__indicatorY.sizeRatio * self.__scrollTop) || 0;\n\n      // Don't go all the way to the right if we have a vertical scrollbar as well\n      if(self.__indicatorX) ystop = 10;\n\n      heightDiff = self.__scrollTop - (self.__maxScrollTop - ystop);\n\n      if(self.__scrollTop < 0) {\n\n        heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - Math.abs(self.__scrollTop)) / self.__indicatorY.size);\n\n        // Stay at top\n        y = 0;\n\n        // Make sure scale is transformed from the center/top origin point\n        self.__indicatorY.indicator.style[self.__transformOriginProperty] = 'center top';\n\n      } else if(heightDiff > 0) {\n\n        heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - heightDiff) / self.__indicatorY.size);\n\n        // Stay at bottom of scrollable viewport\n        y = self.__indicatorY.maxPos - ystop;\n\n        // Make sure scale is transformed from the center/bottom origin point\n        self.__indicatorY.indicator.style[self.__transformOriginProperty] = 'center bottom';\n\n      } else {\n\n        // Normal motion\n        y = Math.min(self.__maxScrollTop, Math.max(0, y));\n        heightScale = 1;\n\n      }\n\n      self.__indicatorY.indicator.style[self.__transformProperty] = 'translate3d(0,' + y + 'px, 0) scaleY(' + heightScale + ')';\n    }\n  },\n\n  __fadeScrollbars: function(direction, delay) {\n    var self = this;\n\n    if(!this.options.scrollbarsFade) {\n      return;\n    }\n\n    var className = 'scroll-bar-fade-out';\n\n    if(self.options.scrollbarsFade === true) {\n      clearTimeout(self.__scrollbarFadeTimeout);\n\n      if(direction == 'in') {\n        if(self.__indicatorX) { self.__indicatorX.indicator.classList.remove(className); }\n        if(self.__indicatorY) { self.__indicatorY.indicator.classList.remove(className); }\n      } else {\n        self.__scrollbarFadeTimeout = setTimeout(function() {\n          if(self.__indicatorX) { self.__indicatorX.indicator.classList.add(className); }\n          if(self.__indicatorY) { self.__indicatorY.indicator.classList.add(className); }\n        }, delay || self.options.scrollbarFadeDelay);\n      }\n    }\n  },\n\n  __scrollingComplete: function() {\n    var self = this;\n    self.options.scrollingComplete();\n\n    self.__fadeScrollbars('out');\n  },\n\n  resize: function() {\n    // Update Scroller dimensions for changed content\n    // Add padding to bottom of content\n    this.setDimensions(\n    \tthis.__container.clientWidth,\n    \tthis.__container.clientHeight,\n      this.options.getContentWidth(),\n      this.options.getContentHeight()\n    );\n  },\n  /*\n  ---------------------------------------------------------------------------\n    PUBLIC API\n  ---------------------------------------------------------------------------\n  */\n\n  getRenderFn: function() {\n    var self = this;\n\n    var content = this.__content;\n\n    var docStyle = document.documentElement.style;\n\n    var engine;\n    if ('MozAppearance' in docStyle) {\n      engine = 'gecko';\n    } else if ('WebkitAppearance' in docStyle) {\n      engine = 'webkit';\n    } else if (typeof navigator.cpuClass === 'string') {\n      engine = 'trident';\n    }\n\n    var vendorPrefix = {\n      trident: 'ms',\n      gecko: 'Moz',\n      webkit: 'Webkit',\n      presto: 'O'\n    }[engine];\n\n    var helperElem = document.createElement(\"div\");\n    var undef;\n\n    var perspectiveProperty = vendorPrefix + \"Perspective\";\n    var transformProperty = vendorPrefix + \"Transform\";\n    var transformOriginProperty = vendorPrefix + 'TransformOrigin';\n\n    self.__perspectiveProperty = transformProperty;\n    self.__transformProperty = transformProperty;\n    self.__transformOriginProperty = transformOriginProperty;\n\n    if (helperElem.style[perspectiveProperty] !== undef) {\n\n      return function(left, top, zoom, wasResize) {\n        content.style[transformProperty] = 'translate3d(' + (-left) + 'px,' + (-top) + 'px,0) scale(' + zoom + ')';\n        self.__repositionScrollbars();\n        if(!wasResize) {\n          self.triggerScrollEvent();\n        }\n      };\n\n    } else if (helperElem.style[transformProperty] !== undef) {\n\n      return function(left, top, zoom, wasResize) {\n        content.style[transformProperty] = 'translate(' + (-left) + 'px,' + (-top) + 'px) scale(' + zoom + ')';\n        self.__repositionScrollbars();\n        if(!wasResize) {\n          self.triggerScrollEvent();\n        }\n      };\n\n    } else {\n\n      return function(left, top, zoom, wasResize) {\n        content.style.marginLeft = left ? (-left/zoom) + 'px' : '';\n        content.style.marginTop = top ? (-top/zoom) + 'px' : '';\n        content.style.zoom = zoom || '';\n        self.__repositionScrollbars();\n        if(!wasResize) {\n          self.triggerScrollEvent();\n        }\n      };\n\n    }\n  },\n\n\n  /**\n   * Configures the dimensions of the client (outer) and content (inner) elements.\n   * Requires the available space for the outer element and the outer size of the inner element.\n   * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\n   *\n   * @param clientWidth {Integer} Inner width of outer element\n   * @param clientHeight {Integer} Inner height of outer element\n   * @param contentWidth {Integer} Outer width of inner element\n   * @param contentHeight {Integer} Outer height of inner element\n   */\n  setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight) {\n    var self = this;\n\n    // Only update values which are defined\n    if (clientWidth === +clientWidth) {\n      self.__clientWidth = clientWidth;\n    }\n\n    if (clientHeight === +clientHeight) {\n      self.__clientHeight = clientHeight;\n    }\n\n    if (contentWidth === +contentWidth) {\n      self.__contentWidth = contentWidth;\n    }\n\n    if (contentHeight === +contentHeight) {\n      self.__contentHeight = contentHeight;\n    }\n\n    // Refresh maximums\n    self.__computeScrollMax();\n    self.__resizeScrollbars();\n\n    // Refresh scroll position\n    self.scrollTo(self.__scrollLeft, self.__scrollTop, true, null, true);\n\n  },\n\n\n  /**\n   * Sets the client coordinates in relation to the document.\n   *\n   * @param left {Integer} Left position of outer element\n   * @param top {Integer} Top position of outer element\n   */\n  setPosition: function(left, top) {\n\n    var self = this;\n\n    self.__clientLeft = left || 0;\n    self.__clientTop = top || 0;\n\n  },\n\n\n  /**\n   * Configures the snapping (when snapping is active)\n   *\n   * @param width {Integer} Snapping width\n   * @param height {Integer} Snapping height\n   */\n  setSnapSize: function(width, height) {\n\n    var self = this;\n\n    self.__snapWidth = width;\n    self.__snapHeight = height;\n\n  },\n\n\n  /**\n   * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\n   * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\n   * the official Twitter client.\n   *\n   * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\n   * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\n   * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\n   * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\n   */\n  activatePullToRefresh: function(height, activateCallback, deactivateCallback, startCallback) {\n\n    var self = this;\n\n    self.__refreshHeight = height;\n    self.__refreshActivate = activateCallback;\n    self.__refreshDeactivate = deactivateCallback;\n    self.__refreshStart = startCallback;\n\n  },\n\n\n  /**\n   * Starts pull-to-refresh manually.\n   */\n  triggerPullToRefresh: function() {\n    // Use publish instead of scrollTo to allow scrolling to out of boundary position\n    // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n    this.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);\n\n    if (this.__refreshStart) {\n      this.__refreshStart();\n    }\n  },\n\n\n  /**\n   * Signalizes that pull-to-refresh is finished.\n   */\n  finishPullToRefresh: function() {\n\n    var self = this;\n\n    self.__refreshActive = false;\n    if (self.__refreshDeactivate) {\n      self.__refreshDeactivate();\n    }\n\n    self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n\n  },\n\n\n  /**\n   * Returns the scroll position and zooming values\n   *\n   * @return {Map} `left` and `top` scroll position and `zoom` level\n   */\n  getValues: function() {\n\n    var self = this;\n\n    return {\n      left: self.__scrollLeft,\n      top: self.__scrollTop,\n      zoom: self.__zoomLevel\n    };\n\n  },\n\n\n  /**\n   * Returns the maximum scroll values\n   *\n   * @return {Map} `left` and `top` maximum scroll values\n   */\n  getScrollMax: function() {\n\n    var self = this;\n\n    return {\n      left: self.__maxScrollLeft,\n      top: self.__maxScrollTop\n    };\n\n  },\n\n\n  /**\n   * Zooms to the given level. Supports optional animation. Zooms\n   * the center when no coordinates are given.\n   *\n   * @param level {Number} Level to zoom to\n   * @param animate {Boolean} Whether to use animation\n   * @param originLeft {Number} Zoom in at given left coordinate\n   * @param originTop {Number} Zoom in at given top coordinate\n   */\n  zoomTo: function(level, animate, originLeft, originTop) {\n\n    var self = this;\n\n    if (!self.options.zooming) {\n      throw new Error(\"Zooming is not enabled!\");\n    }\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      zyngaCore.effect.Animate.stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n    }\n\n    var oldLevel = self.__zoomLevel;\n\n    // Normalize input origin to center of viewport if not defined\n    if (originLeft == null) {\n      originLeft = self.__clientWidth / 2;\n    }\n\n    if (originTop == null) {\n      originTop = self.__clientHeight / 2;\n    }\n\n    // Limit level according to configuration\n    level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);\n\n    // Recompute maximum values while temporary tweaking maximum scroll ranges\n    self.__computeScrollMax(level);\n\n    // Recompute left and top coordinates based on new zoom level\n    var left = ((originLeft + self.__scrollLeft) * level / oldLevel) - originLeft;\n    var top = ((originTop + self.__scrollTop) * level / oldLevel) - originTop;\n\n    // Limit x-axis\n    if (left > self.__maxScrollLeft) {\n      left = self.__maxScrollLeft;\n    } else if (left < 0) {\n      left = 0;\n    }\n\n    // Limit y-axis\n    if (top > self.__maxScrollTop) {\n      top = self.__maxScrollTop;\n    } else if (top < 0) {\n      top = 0;\n    }\n\n    // Push values out\n    self.__publish(left, top, level, animate);\n\n  },\n\n\n  /**\n   * Zooms the content by the given factor.\n   *\n   * @param factor {Number} Zoom by given factor\n   * @param animate {Boolean} Whether to use animation\n   * @param originLeft {Number} Zoom in at given left coordinate\n   * @param originTop {Number} Zoom in at given top coordinate\n   */\n  zoomBy: function(factor, animate, originLeft, originTop) {\n\n    var self = this;\n\n    self.zoomTo(self.__zoomLevel * factor, animate, originLeft, originTop);\n\n  },\n\n\n  /**\n   * Scrolls to the given position. Respect limitations and snapping automatically.\n   *\n   * @param left {Number} Horizontal scroll position, keeps current if value is <code>null</code>\n   * @param top {Number} Vertical scroll position, keeps current if value is <code>null</code>\n   * @param animate {Boolean} Whether the scrolling should happen using an animation\n   * @param zoom {Number} Zoom level to go to\n   */\n  scrollTo: function(left, top, animate, zoom, wasResize) {\n    var self = this;\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      zyngaCore.effect.Animate.stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n    }\n\n    // Correct coordinates based on new zoom level\n    if (zoom != null && zoom !== self.__zoomLevel) {\n\n      if (!self.options.zooming) {\n        throw new Error(\"Zooming is not enabled!\");\n      }\n\n      left *= zoom;\n      top *= zoom;\n\n      // Recompute maximum values while temporary tweaking maximum scroll ranges\n      self.__computeScrollMax(zoom);\n\n    } else {\n\n      // Keep zoom when not defined\n      zoom = self.__zoomLevel;\n\n    }\n\n    if (!self.options.scrollingX) {\n\n      left = self.__scrollLeft;\n\n    } else {\n\n      if (self.options.paging) {\n        left = Math.round(left / self.__clientWidth) * self.__clientWidth;\n      } else if (self.options.snapping) {\n        left = Math.round(left / self.__snapWidth) * self.__snapWidth;\n      }\n\n    }\n\n    if (!self.options.scrollingY) {\n\n      top = self.__scrollTop;\n\n    } else {\n\n      if (self.options.paging) {\n        top = Math.round(top / self.__clientHeight) * self.__clientHeight;\n      } else if (self.options.snapping) {\n        top = Math.round(top / self.__snapHeight) * self.__snapHeight;\n      }\n\n    }\n\n    // Limit for allowed ranges\n    left = Math.max(Math.min(self.__maxScrollLeft, left), 0);\n    top = Math.max(Math.min(self.__maxScrollTop, top), 0);\n\n    // Don't animate when no change detected, still call publish to make sure\n    // that rendered position is really in-sync with internal data\n    if (left === self.__scrollLeft && top === self.__scrollTop) {\n      animate = false;\n    }\n\n    // Publish new values\n    self.__publish(left, top, zoom, animate, wasResize);\n\n  },\n\n\n  /**\n   * Scroll by the given offset\n   *\n   * @param left {Number} Scroll x-axis by given offset\n   * @param top {Number} Scroll y-axis by given offset\n   * @param animate {Boolean} Whether to animate the given change\n   */\n  scrollBy: function(left, top, animate) {\n\n    var self = this;\n\n    var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;\n    var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\n\n    self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\n\n  },\n\n\n\n  /*\n  ---------------------------------------------------------------------------\n    EVENT CALLBACKS\n  ---------------------------------------------------------------------------\n  */\n\n  /**\n   * Mouse wheel handler for zooming support\n   */\n  doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {\n\n    var self = this;\n    var change = wheelDelta > 0 ? 0.97 : 1.03;\n\n    return self.zoomTo(self.__zoomLevel * change, false, pageX - self.__clientLeft, pageY - self.__clientTop);\n\n  },\n\n\n  /**\n   * Touch start handler for scrolling support\n   */\n  doTouchStart: function(touches, timeStamp) {\n    this.hintResize();\n\n    // Array-like check is enough here\n    if (touches.length == null) {\n      throw new Error(\"Invalid touch list: \" + touches);\n    }\n\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== \"number\") {\n      throw new Error(\"Invalid timestamp value: \" + timeStamp);\n    }\n\n    var self = this;\n\n    // Reset interruptedAnimation flag\n    self.__interruptedAnimation = true;\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      zyngaCore.effect.Animate.stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n      self.__interruptedAnimation = true;\n    }\n\n    // Stop animation\n    if (self.__isAnimating) {\n      zyngaCore.effect.Animate.stop(self.__isAnimating);\n      self.__isAnimating = false;\n      self.__interruptedAnimation = true;\n    }\n\n    // Use center point when dealing with two fingers\n    var currentTouchLeft, currentTouchTop;\n    var isSingleTouch = touches.length === 1;\n    if (isSingleTouch) {\n      currentTouchLeft = touches[0].pageX;\n      currentTouchTop = touches[0].pageY;\n    } else {\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n    }\n\n    // Store initial positions\n    self.__initialTouchLeft = currentTouchLeft;\n    self.__initialTouchTop = currentTouchTop;\n\n    // Store current zoom level\n    self.__zoomLevelStart = self.__zoomLevel;\n\n    // Store initial touch positions\n    self.__lastTouchLeft = currentTouchLeft;\n    self.__lastTouchTop = currentTouchTop;\n\n    // Store initial move time stamp\n    self.__lastTouchMove = timeStamp;\n\n    // Reset initial scale\n    self.__lastScale = 1;\n\n    // Reset locking flags\n    self.__enableScrollX = !isSingleTouch && self.options.scrollingX;\n    self.__enableScrollY = !isSingleTouch && self.options.scrollingY;\n\n    // Reset tracking flag\n    self.__isTracking = true;\n\n    // Reset deceleration complete flag\n    self.__didDecelerationComplete = false;\n\n    // Dragging starts directly with two fingers, otherwise lazy with an offset\n    self.__isDragging = !isSingleTouch;\n\n    // Some features are disabled in multi touch scenarios\n    self.__isSingleTouch = isSingleTouch;\n\n    // Clearing data structure\n    self.__positions = [];\n\n  },\n\n\n  /**\n   * Touch move handler for scrolling support\n   */\n  doTouchMove: function(touches, timeStamp, scale) {\n\n    // Array-like check is enough here\n    if (touches.length == null) {\n      throw new Error(\"Invalid touch list: \" + touches);\n    }\n\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== \"number\") {\n      throw new Error(\"Invalid timestamp value: \" + timeStamp);\n    }\n\n    var self = this;\n\n    // Ignore event when tracking is not enabled (event might be outside of element)\n    if (!self.__isTracking) {\n      return;\n    }\n\n\n    var currentTouchLeft, currentTouchTop;\n\n    // Compute move based around of center of fingers\n    if (touches.length === 2) {\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n    } else {\n      currentTouchLeft = touches[0].pageX;\n      currentTouchTop = touches[0].pageY;\n    }\n\n    var positions = self.__positions;\n\n    // Are we already is dragging mode?\n    if (self.__isDragging) {\n\n      // Compute move distance\n      var moveX = currentTouchLeft - self.__lastTouchLeft;\n      var moveY = currentTouchTop - self.__lastTouchTop;\n\n      // Read previous scroll position and zooming\n      var scrollLeft = self.__scrollLeft;\n      var scrollTop = self.__scrollTop;\n      var level = self.__zoomLevel;\n\n      // Work with scaling\n      if (scale != null && self.options.zooming) {\n\n        var oldLevel = level;\n\n        // Recompute level based on previous scale and new scale\n        level = level / self.__lastScale * scale;\n\n        // Limit level according to configuration\n        level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);\n\n        // Only do further compution when change happened\n        if (oldLevel !== level) {\n\n          // Compute relative event position to container\n          var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\n          var currentTouchTopRel = currentTouchTop - self.__clientTop;\n\n          // Recompute left and top coordinates based on new zoom level\n          scrollLeft = ((currentTouchLeftRel + scrollLeft) * level / oldLevel) - currentTouchLeftRel;\n          scrollTop = ((currentTouchTopRel + scrollTop) * level / oldLevel) - currentTouchTopRel;\n\n          // Recompute max scroll values\n          self.__computeScrollMax(level);\n\n        }\n      }\n\n      if (self.__enableScrollX) {\n\n        scrollLeft -= moveX * this.options.speedMultiplier;\n        var maxScrollLeft = self.__maxScrollLeft;\n\n        if (scrollLeft > maxScrollLeft || scrollLeft < 0) {\n\n          // Slow down on the edges\n          if (self.options.bouncing) {\n\n            scrollLeft += (moveX / 2  * this.options.speedMultiplier);\n\n          } else if (scrollLeft > maxScrollLeft) {\n\n            scrollLeft = maxScrollLeft;\n\n          } else {\n\n            scrollLeft = 0;\n\n          }\n        }\n      }\n\n      // Compute new vertical scroll position\n      if (self.__enableScrollY) {\n\n        scrollTop -= moveY * this.options.speedMultiplier;\n        var maxScrollTop = self.__maxScrollTop;\n\n        if (scrollTop > maxScrollTop || scrollTop < 0) {\n\n          // Slow down on the edges\n          if (self.options.bouncing || (self.__refreshHeight && scrollTop < 0)) {\n\n            scrollTop += (moveY / 2 * this.options.speedMultiplier);\n\n            // Support pull-to-refresh (only when only y is scrollable)\n            if (!self.__enableScrollX && self.__refreshHeight != null) {\n\n              if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\n\n                self.__refreshActive = true;\n                if (self.__refreshActivate) {\n                  self.__refreshActivate();\n                }\n\n              } else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {\n\n                self.__refreshActive = false;\n                if (self.__refreshDeactivate) {\n                  self.__refreshDeactivate();\n                }\n\n              }\n            }\n\n          } else if (scrollTop > maxScrollTop) {\n\n            scrollTop = maxScrollTop;\n\n          } else {\n\n            scrollTop = 0;\n\n          }\n        }\n      }\n\n      // Keep list from growing infinitely (holding min 10, max 20 measure points)\n      if (positions.length > 60) {\n        positions.splice(0, 30);\n      }\n\n      // Track scroll movement for decleration\n      positions.push(scrollLeft, scrollTop, timeStamp);\n\n      // Sync scroll position\n      self.__publish(scrollLeft, scrollTop, level);\n\n    // Otherwise figure out whether we are switching into dragging mode now.\n    } else {\n\n      var minimumTrackingForScroll = self.options.locking ? 3 : 0;\n      var minimumTrackingForDrag = 5;\n\n      var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\n      var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\n\n      self.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;\n      self.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;\n\n      positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\n\n      self.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);\n      if (self.__isDragging) {\n        self.__interruptedAnimation = false;\n        self.__fadeScrollbars('in');\n      }\n\n    }\n\n    // Update last touch positions and time stamp for next event\n    self.__lastTouchLeft = currentTouchLeft;\n    self.__lastTouchTop = currentTouchTop;\n    self.__lastTouchMove = timeStamp;\n    self.__lastScale = scale;\n\n  },\n\n\n  /**\n   * Touch end handler for scrolling support\n   */\n  doTouchEnd: function(timeStamp) {\n\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== \"number\") {\n      throw new Error(\"Invalid timestamp value: \" + timeStamp);\n    }\n\n    var self = this;\n\n    // Ignore event when tracking is not enabled (no touchstart event on element)\n    // This is required as this listener ('touchmove') sits on the document and not on the element itself.\n    if (!self.__isTracking) {\n      return;\n    }\n\n    // Not touching anymore (when two finger hit the screen there are two touch end events)\n    self.__isTracking = false;\n\n    // Be sure to reset the dragging flag now. Here we also detect whether\n    // the finger has moved fast enough to switch into a deceleration animation.\n    if (self.__isDragging) {\n\n      // Reset dragging flag\n      self.__isDragging = false;\n\n      // Start deceleration\n      // Verify that the last move detected was in some relevant time frame\n      if (self.__isSingleTouch && self.options.animating && (timeStamp - self.__lastTouchMove) <= 100) {\n\n        // Then figure out what the scroll position was about 100ms ago\n        var positions = self.__positions;\n        var endPos = positions.length - 1;\n        var startPos = endPos;\n\n        // Move pointer to position measured 100ms ago\n        for (var i = endPos; i > 0 && positions[i] > (self.__lastTouchMove - 100); i -= 3) {\n          startPos = i;\n        }\n\n        // If start and stop position is identical in a 100ms timeframe,\n        // we cannot compute any useful deceleration.\n        if (startPos !== endPos) {\n\n          // Compute relative movement between these two points\n          var timeOffset = positions[endPos] - positions[startPos];\n          var movedLeft = self.__scrollLeft - positions[startPos - 2];\n          var movedTop = self.__scrollTop - positions[startPos - 1];\n\n          // Based on 50ms compute the movement to apply for each render step\n          self.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);\n          self.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);\n\n          // How much velocity is required to start the deceleration\n          var minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? 4 : 1;\n\n          // Verify that we have enough velocity to start deceleration\n          if (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {\n\n            // Deactivate pull-to-refresh when decelerating\n            if (!self.__refreshActive) {\n              self.__startDeceleration(timeStamp);\n            }\n          }\n        } else {\n          self.__scrollingComplete();\n        }\n      } else if ((timeStamp - self.__lastTouchMove) > 100) {\n        self.__scrollingComplete();\n      }\n    }\n\n    // If this was a slower move it is per default non decelerated, but this\n    // still means that we want snap back to the bounds which is done here.\n    // This is placed outside the condition above to improve edge case stability\n    // e.g. touchend fired without enabled dragging. This should normally do not\n    // have modified the scroll positions or even showed the scrollbars though.\n    if (!self.__isDecelerating) {\n\n      if (self.__refreshActive && self.__refreshStart) {\n\n        // Use publish instead of scrollTo to allow scrolling to out of boundary position\n        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n        self.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);\n\n        if (self.__refreshStart) {\n          self.__refreshStart();\n        }\n\n      } else {\n\n        if (self.__interruptedAnimation || self.__isDragging) {\n          self.__scrollingComplete();\n        }\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel);\n\n        // Directly signalize deactivation (nothing todo on refresh?)\n        if (self.__refreshActive) {\n\n          self.__refreshActive = false;\n          if (self.__refreshDeactivate) {\n            self.__refreshDeactivate();\n          }\n\n        }\n      }\n    }\n\n    // Fully cleanup list\n    self.__positions.length = 0;\n\n  },\n\n\n\n  /*\n  ---------------------------------------------------------------------------\n    PRIVATE API\n  ---------------------------------------------------------------------------\n  */\n\n  /**\n   * Applies the scroll position to the content element\n   *\n   * @param left {Number} Left scroll position\n   * @param top {Number} Top scroll position\n   * @param animate {Boolean} Whether animation should be used to move to the new coordinates\n   */\n  __publish: function(left, top, zoom, animate, wasResize) {\n\n    var self = this;\n\n    // Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\n    var wasAnimating = self.__isAnimating;\n    if (wasAnimating) {\n      zyngaCore.effect.Animate.stop(wasAnimating);\n      self.__isAnimating = false;\n    }\n\n    if (animate && self.options.animating) {\n\n      // Keep scheduled positions for scrollBy/zoomBy functionality\n      self.__scheduledLeft = left;\n      self.__scheduledTop = top;\n      self.__scheduledZoom = zoom;\n\n      var oldLeft = self.__scrollLeft;\n      var oldTop = self.__scrollTop;\n      var oldZoom = self.__zoomLevel;\n\n      var diffLeft = left - oldLeft;\n      var diffTop = top - oldTop;\n      var diffZoom = zoom - oldZoom;\n\n      var step = function(percent, now, render) {\n\n        if (render) {\n\n          self.__scrollLeft = oldLeft + (diffLeft * percent);\n          self.__scrollTop = oldTop + (diffTop * percent);\n          self.__zoomLevel = oldZoom + (diffZoom * percent);\n\n          // Push values out\n          if (self.__callback) {\n            self.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel, wasResize);\n          }\n\n        }\n      };\n\n      var verify = function(id) {\n        return self.__isAnimating === id;\n      };\n\n      var completed = function(renderedFramesPerSecond, animationId, wasFinished) {\n        if (animationId === self.__isAnimating) {\n          self.__isAnimating = false;\n        }\n        if (self.__didDecelerationComplete || wasFinished) {\n          self.__scrollingComplete();\n        }\n\n        if (self.options.zooming) {\n          self.__computeScrollMax();\n        }\n      };\n\n      // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\n      self.__isAnimating = zyngaCore.effect.Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);\n\n    } else {\n\n      self.__scheduledLeft = self.__scrollLeft = left;\n      self.__scheduledTop = self.__scrollTop = top;\n      self.__scheduledZoom = self.__zoomLevel = zoom;\n\n      // Push values out\n      if (self.__callback) {\n        self.__callback(left, top, zoom, wasResize);\n      }\n\n      // Fix max scroll ranges\n      if (self.options.zooming) {\n        self.__computeScrollMax();\n      }\n    }\n  },\n\n\n  /**\n   * Recomputes scroll minimum values based on client dimensions and content dimensions.\n   */\n  __computeScrollMax: function(zoomLevel) {\n\n    var self = this;\n\n    if (zoomLevel == null) {\n      zoomLevel = self.__zoomLevel;\n    }\n\n    self.__maxScrollLeft = Math.max((self.__contentWidth * zoomLevel) - self.__clientWidth, 0);\n    self.__maxScrollTop = Math.max((self.__contentHeight * zoomLevel) - self.__clientHeight, 0);\n\n    if(!self.__didWaitForSize && self.__maxScrollLeft == 0 && self.__maxScrollTop == 0) {\n      self.__didWaitForSize = true;\n      self.__waitForSize();\n    }\n  },\n\n\n  /**\n   * If the scroll view isn't sized correctly on start, wait until we have at least some size\n   */\n  __waitForSize: function() {\n\n    var self = this;\n\n    clearTimeout(self.__sizerTimeout);\n\n    var sizer = function() {\n      self.resize();\n\n      if((self.options.scrollingX && self.__maxScrollLeft == 0) || (self.options.scrollingY && self.__maxScrollTop == 0)) {\n        //self.__sizerTimeout = setTimeout(sizer, 1000);\n      }\n    };\n\n    sizer();\n    self.__sizerTimeout = setTimeout(sizer, 1000);\n  },\n\n  /*\n  ---------------------------------------------------------------------------\n    ANIMATION (DECELERATION) SUPPORT\n  ---------------------------------------------------------------------------\n  */\n\n  /**\n   * Called when a touch sequence end and the speed of the finger was high enough\n   * to switch into deceleration mode.\n   */\n  __startDeceleration: function(timeStamp) {\n\n    var self = this;\n\n    if (self.options.paging) {\n\n      var scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);\n      var scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);\n      var clientWidth = self.__clientWidth;\n      var clientHeight = self.__clientHeight;\n\n      // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\n      // Each page should have exactly the size of the client area.\n      self.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;\n      self.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;\n      self.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;\n      self.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;\n\n    } else {\n\n      self.__minDecelerationScrollLeft = 0;\n      self.__minDecelerationScrollTop = 0;\n      self.__maxDecelerationScrollLeft = self.__maxScrollLeft;\n      self.__maxDecelerationScrollTop = self.__maxScrollTop;\n\n    }\n\n    // Wrap class method\n    var step = function(percent, now, render) {\n      self.__stepThroughDeceleration(render);\n    };\n\n    // How much velocity is required to keep the deceleration running\n    self.__minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.1;\n\n    // Detect whether it's still worth to continue animating steps\n    // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\n    var verify = function() {\n      var shouldContinue = Math.abs(self.__decelerationVelocityX) >= self.__minVelocityToKeepDecelerating ||\n        Math.abs(self.__decelerationVelocityY) >= self.__minVelocityToKeepDecelerating;\n      if (!shouldContinue) {\n        self.__didDecelerationComplete = true;\n      }\n      return shouldContinue;\n    };\n\n    var completed = function(renderedFramesPerSecond, animationId, wasFinished) {\n      self.__isDecelerating = false;\n      if (self.__didDecelerationComplete) {\n        self.__scrollingComplete();\n      }\n\n      // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\n      if(self.options.paging) {\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\n      }\n    };\n\n    // Start animation and switch on flag\n    self.__isDecelerating = zyngaCore.effect.Animate.start(step, verify, completed);\n\n  },\n\n\n  /**\n   * Called on every step of the animation\n   *\n   * @param inMemory {Boolean} Whether to not render the current step, but keep it in memory only. Used internally only!\n   */\n  __stepThroughDeceleration: function(render) {\n\n    var self = this;\n\n\n    //\n    // COMPUTE NEXT SCROLL POSITION\n    //\n\n    // Add deceleration to scroll position\n    var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\n    var scrollTop = self.__scrollTop + self.__decelerationVelocityY;\n\n\n    //\n    // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\n    //\n\n    if (!self.options.bouncing) {\n\n      var scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);\n      if (scrollLeftFixed !== scrollLeft) {\n        scrollLeft = scrollLeftFixed;\n        self.__decelerationVelocityX = 0;\n      }\n\n      var scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);\n      if (scrollTopFixed !== scrollTop) {\n        scrollTop = scrollTopFixed;\n        self.__decelerationVelocityY = 0;\n      }\n\n    }\n\n\n    //\n    // UPDATE SCROLL POSITION\n    //\n\n    if (render) {\n\n      self.__publish(scrollLeft, scrollTop, self.__zoomLevel);\n\n    } else {\n\n      self.__scrollLeft = scrollLeft;\n      self.__scrollTop = scrollTop;\n\n    }\n\n\n    //\n    // SLOW DOWN\n    //\n\n    // Slow down velocity on every iteration\n    if (!self.options.paging) {\n\n      // This is the factor applied to every iteration of the animation\n      // to slow down the process. This should emulate natural behavior where\n      // objects slow down when the initiator of the movement is removed\n      var frictionFactor = 0.95;\n\n      self.__decelerationVelocityX *= frictionFactor;\n      self.__decelerationVelocityY *= frictionFactor;\n\n    }\n\n\n    //\n    // BOUNCING SUPPORT\n    //\n\n    if (self.options.bouncing) {\n\n      var scrollOutsideX = 0;\n      var scrollOutsideY = 0;\n\n      // This configures the amount of change applied to deceleration/acceleration when reaching boundaries\n      var penetrationDeceleration = self.options.penetrationDeceleration;\n      var penetrationAcceleration = self.options.penetrationAcceleration;\n\n      // Check limits\n      if (scrollLeft < self.__minDecelerationScrollLeft) {\n        scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\n      } else if (scrollLeft > self.__maxDecelerationScrollLeft) {\n        scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\n      }\n\n      if (scrollTop < self.__minDecelerationScrollTop) {\n        scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\n      } else if (scrollTop > self.__maxDecelerationScrollTop) {\n        scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\n      }\n\n      // Slow down until slow enough, then flip back to snap position\n      if (scrollOutsideX !== 0) {\n        var isHeadingOutwardsX = scrollOutsideX * self.__decelerationVelocityX <= self.__minDecelerationScrollLeft;\n        if (isHeadingOutwardsX) {\n          self.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;\n        }\n        var isStoppedX = Math.abs(self.__decelerationVelocityX) <= self.__minVelocityToKeepDecelerating;\n        //If we're not heading outwards, or if the above statement got us below minDeceleration, go back towards bounds\n        if (!isHeadingOutwardsX || isStoppedX) {\n          self.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;\n        }\n      }\n\n      if (scrollOutsideY !== 0) {\n        var isHeadingOutwardsY = scrollOutsideY * self.__decelerationVelocityY <= self.__minDecelerationScrollTop;\n        if (isHeadingOutwardsY) {\n          self.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;\n        }\n        var isStoppedY = Math.abs(self.__decelerationVelocityY) <= self.__minVelocityToKeepDecelerating;\n        //If we're not heading outwards, or if the above statement got us below minDeceleration, go back towards bounds\n        if (!isHeadingOutwardsY || isStoppedY) {\n          self.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;\n        }\n      }\n    }\n  }\n});\n\nionic.scroll = {\n  isScrolling: false,\n  lastTop: 0\n};\n\n})(ionic);\n\n(function(ionic) {\n'use strict';\n  /**\n   * An ActionSheet is the slide up menu popularized on iOS.\n   *\n   * You see it all over iOS apps, where it offers a set of options\n   * triggered after an action.\n   */\n  ionic.views.ActionSheet = ionic.views.View.inherit({\n    initialize: function(opts) {\n      this.el = opts.el;\n    },\n    show: function() {\n      // Force a reflow so the animation will actually run\n      this.el.offsetWidth;\n\n      this.el.classList.add('active');\n    },\n    hide: function() {\n      // Force a reflow so the animation will actually run\n      this.el.offsetWidth;\n      this.el.classList.remove('active');\n    }\n  });\n\n})(ionic);\n\n(function(ionic) {\n'use strict';\n\n  ionic.views.HeaderBar = ionic.views.View.inherit({\n    initialize: function(opts) {\n      this.el = opts.el;\n\n      ionic.extend(this, {\n        alignTitle: 'center'\n      }, opts);\n\n      this.align();\n    },\n\n    align: function(align) {\n\n      align || (align = this.alignTitle);\n\n      // Find the titleEl element\n      var titleEl = this.el.querySelector('.title');\n      if(!titleEl) {\n        return;\n      }\n\n      var self = this;\n      //We have to rAF here so all of the elements have time to initialize\n      ionic.requestAnimationFrame(function() {\n        var i, c, childSize;\n        var childNodes = self.el.childNodes;\n        var leftWidth = 0;\n        var rightWidth = 0;\n        var isCountingRightWidth = false;\n\n        // Compute how wide the left children are\n        // Skip all titles (there may still be two titles, one leaving the dom)\n        // Once we encounter a titleEl, realize we are now counting the right-buttons, not left\n        for(i = 0; i < childNodes.length; i++) {\n          c = childNodes[i];\n          if (c.tagName && c.tagName.toLowerCase() == 'h1') {\n            isCountingRightWidth = true;\n            continue;\n          }\n\n          childSize = null;\n          if(c.nodeType == 3) {\n            childSize = ionic.DomUtil.getTextBounds(c).width;\n          } else if(c.nodeType == 1) {\n            childSize = c.offsetWidth;\n          }\n          if(childSize) {\n            if (isCountingRightWidth) {\n              rightWidth += childSize;\n            } else {\n              leftWidth += childSize;\n            }\n          }\n        }\n\n        var margin = Math.max(leftWidth, rightWidth) + 10;\n\n        // Size and align the header titleEl based on the sizes of the left and\n        // right children, and the desired alignment mode\n        if(align == 'center') {\n          if(margin > 10) {\n            titleEl.style.left = margin + 'px';\n            titleEl.style.right = margin + 'px';\n          }\n          if(titleEl.offsetWidth < titleEl.scrollWidth) {\n            if(rightWidth > 0) {\n              titleEl.style.right = (rightWidth + 5) + 'px';\n            }\n          }\n        } else if(align == 'left') {\n          titleEl.classList.add('title-left');\n          if(leftWidth > 0) {\n            titleEl.style.left = (leftWidth + 15) + 'px';\n          }\n        } else if(align == 'right') {\n          titleEl.classList.add('title-right');\n          if(rightWidth > 0) {\n            titleEl.style.right = (rightWidth + 15) + 'px';\n          }\n        }\n      });\n    }\n  });\n\n})(ionic);\n\n(function(ionic) {\n'use strict';\n\n  var ITEM_CLASS = 'item';\n  var ITEM_CONTENT_CLASS = 'item-content';\n  var ITEM_SLIDING_CLASS = 'item-sliding';\n  var ITEM_OPTIONS_CLASS = 'item-options';\n  var ITEM_PLACEHOLDER_CLASS = 'item-placeholder';\n  var ITEM_REORDERING_CLASS = 'item-reordering';\n  var ITEM_REORDER_BTN_CLASS = 'item-reorder';\n\n  var DragOp = function() {};\n  DragOp.prototype = {\n    start: function(e) {\n    },\n    drag: function(e) {\n    },\n    end: function(e) {\n    },\n    isSameItem: function(item) {\n      return false;\n    }\n  };\n  // ROMAIN EDIT : EXPOSE SlideDrag\n  var SlideDrag = ionic.SlideDrag = function(opts) {\n    this.dragThresholdX = opts.dragThresholdX || 10;\n    this.el = opts.el;\n    this.canSwipe = opts.canSwipe;\n  };\n\n  SlideDrag.prototype = new DragOp();\n\n  SlideDrag.prototype.start = function(e) {\n    var content, buttons, offsetX, buttonsWidth;\n\n    if (!this.canSwipe()) {\n      return;\n    }\n\n    if(e.target.classList.contains(ITEM_CONTENT_CLASS)) {\n      content = e.target;\n    } else if(e.target.classList.contains(ITEM_CLASS)) {\n      content = e.target.querySelector('.' + ITEM_CONTENT_CLASS);\n    } else {\n      content = ionic.DomUtil.getParentWithClass(e.target, ITEM_CONTENT_CLASS);\n    }\n\n    // If we don't have a content area as one of our children (or ourselves), skip\n    if(!content) {\n      return;\n    }\n\n    // Make sure we aren't animating as we slide\n    content.classList.remove(ITEM_SLIDING_CLASS);\n\n    // Grab the starting X point for the item (for example, so we can tell whether it is open or closed to start)\n    offsetX = parseFloat(content.style[ionic.CSS.TRANSFORM].replace('translate3d(', '').split(',')[0]) || 0;\n\n    // Grab the buttons\n    buttons = content.parentNode.querySelector('.' + ITEM_OPTIONS_CLASS);\n    if(!buttons) {\n      return;\n    }\n    buttons.classList.remove('invisible');\n\n    buttonsWidth = buttons.offsetWidth;\n\n    this._currentDrag = {\n      buttons: buttons,\n      buttonsWidth: buttonsWidth,\n      content: content,\n      startOffsetX: offsetX\n    };\n  };\n\n  /**\n   * Check if this is the same item that was previously dragged.\n   */\n  SlideDrag.prototype.isSameItem = function(op) {\n    if(op._lastDrag && this._currentDrag) {\n      return this._currentDrag.content == op._lastDrag.content;\n    }\n    return false;\n  };\n\n  SlideDrag.prototype.clean = function(e) {\n    var lastDrag = this._lastDrag;\n\n    if(!lastDrag) return;\n\n    ionic.requestAnimationFrame(function() {\n      lastDrag.content.style[ionic.CSS.TRANSITION] = '';\n      lastDrag.content.style[ionic.CSS.TRANSFORM] = '';\n      setTimeout(function() {\n        lastDrag.buttons && lastDrag.buttons.classList.add('invisible');\n      }, 250);\n    });\n  };\n\n  SlideDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {\n    var buttonsWidth;\n\n    // We really aren't dragging\n    if(!this._currentDrag) {\n      return;\n    }\n\n    // Check if we should start dragging. Check if we've dragged past the threshold,\n    // or we are starting from the open state.\n    if(!this._isDragging &&\n        ((Math.abs(e.gesture.deltaX) > this.dragThresholdX) ||\n        (Math.abs(this._currentDrag.startOffsetX) > 0)))\n    {\n      this._isDragging = true;\n    }\n\n    if(this._isDragging) {\n      buttonsWidth = this._currentDrag.buttonsWidth;\n\n      // Grab the new X point, capping it at zero\n      var newX = Math.min(0, this._currentDrag.startOffsetX + e.gesture.deltaX);\n\n      // If the new X position is past the buttons, we need to slow down the drag (rubber band style)\n      if(newX < -buttonsWidth) {\n        // Calculate the new X position, capped at the top of the buttons\n        newX = Math.min(-buttonsWidth, -buttonsWidth + (((e.gesture.deltaX + buttonsWidth) * 0.4)));\n      }\n\n      this._currentDrag.content.style[ionic.CSS.TRANSFORM] = 'translate3d(' + newX + 'px, 0, 0)';\n      this._currentDrag.content.style[ionic.CSS.TRANSITION] = 'none';\n    }\n  });\n\n  SlideDrag.prototype.end = function(e, doneCallback) {\n    var _this = this;\n\n    // There is no drag, just end immediately\n    if(!this._currentDrag) {\n      doneCallback && doneCallback();\n      return;\n    }\n\n    // If we are currently dragging, we want to snap back into place\n    // The final resting point X will be the width of the exposed buttons\n    var restingPoint = -this._currentDrag.buttonsWidth;\n\n    // Check if the drag didn't clear the buttons mid-point\n    // and we aren't moving fast enough to swipe open\n    if(e.gesture.deltaX > -(this._currentDrag.buttonsWidth/2)) {\n\n      // If we are going left but too slow, or going right, go back to resting\n      if(e.gesture.direction == \"left\" && Math.abs(e.gesture.velocityX) < 0.3) {\n        restingPoint = 0;\n      } else if(e.gesture.direction == \"right\") {\n        restingPoint = 0;\n      }\n\n    }\n\n    ionic.requestAnimationFrame(function() {\n      if(restingPoint === 0) {\n        _this._currentDrag.content.style[ionic.CSS.TRANSFORM] = '';\n        var buttons = _this._currentDrag.buttons;\n        setTimeout(function() {\n          buttons && buttons.classList.add('invisible');\n        }, 250);\n      } else {\n        _this._currentDrag.content.style[ionic.CSS.TRANSFORM] = 'translate3d(' + restingPoint + 'px, 0, 0)';\n      }\n      _this._currentDrag.content.style[ionic.CSS.TRANSITION] = '';\n\n\n      // Kill the current drag\n      _this._lastDrag = _this._currentDrag;\n      _this._currentDrag = null;\n\n      // We are done, notify caller\n      doneCallback && doneCallback();\n    });\n  };\n\n  var ReorderDrag = function(opts) {\n    this.dragThresholdY = opts.dragThresholdY || 0;\n    this.onReorder = opts.onReorder;\n    this.listEl = opts.listEl;\n    this.el = opts.el;\n    this.scrollEl = opts.scrollEl;\n    this.scrollView = opts.scrollView;\n  };\n\n  ReorderDrag.prototype = new DragOp();\n\n  ReorderDrag.prototype._moveElement = function(e) {\n    var y = e.gesture.center.pageY -\n      this._currentDrag.elementHeight +\n      this.scrollView.getValues().top -\n      this.listEl.offsetTop;\n    this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(0, '+y+'px, 0)';\n  };\n\n  ReorderDrag.prototype.start = function(e) {\n    var content;\n\n    var startIndex = ionic.DomUtil.getChildIndex(this.el, this.el.nodeName.toLowerCase());\n    var elementHeight = this.el.scrollHeight;\n    var placeholder = this.el.cloneNode(true);\n\n    placeholder.classList.add(ITEM_PLACEHOLDER_CLASS);\n\n    this.el.parentNode.insertBefore(placeholder, this.el);\n    this.el.classList.add(ITEM_REORDERING_CLASS);\n\n    this._currentDrag = {\n      elementHeight: elementHeight,\n      startIndex: startIndex,\n      placeholder: placeholder,\n      scrollHeight: scroll,\n      list: placeholder.parentNode\n    };\n\n    this._moveElement(e);\n  };\n\n  ReorderDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {\n    // We really aren't dragging\n    if(!this._currentDrag) {\n      return;\n    }\n\n    var scrollY = 0;\n    var pageY = e.gesture.center.pageY;\n\n    //If we have a scrollView, check scroll boundaries for dragged element and scroll if necessary\n    if (this.scrollView) {\n      var container = this.scrollEl;\n\n      scrollY = this.scrollView.getValues().top;\n\n      var containerTop = container.offsetTop;\n      var pixelsPastTop = containerTop - pageY + this._currentDrag.elementHeight/2;\n      var pixelsPastBottom = pageY + this._currentDrag.elementHeight/2 - containerTop - container.offsetHeight;\n\n      if (e.gesture.deltaY < 0 && pixelsPastTop > 0 && scrollY > 0) {\n        this.scrollView.scrollBy(null, -pixelsPastTop);\n      }\n      if (e.gesture.deltaY > 0 && pixelsPastBottom > 0) {\n        if (scrollY < this.scrollView.getScrollMax().top) {\n          this.scrollView.scrollBy(null, pixelsPastBottom);\n        }\n      }\n    }\n\n    // Check if we should start dragging. Check if we've dragged past the threshold,\n    // or we are starting from the open state.\n    if(!this._isDragging && Math.abs(e.gesture.deltaY) > this.dragThresholdY) {\n      this._isDragging = true;\n    }\n\n    if(this._isDragging) {\n      this._moveElement(e);\n\n      this._currentDrag.currentY = scrollY + pageY - this._currentDrag.placeholder.parentNode.offsetTop;\n\n      this._reorderItems();\n    }\n  });\n\n  // When an item is dragged, we need to reorder any items for sorting purposes\n  ReorderDrag.prototype._reorderItems = function() {\n    var self = this;\n    var placeholder = this._currentDrag.placeholder;\n    var siblings = Array.prototype.slice.call(this._currentDrag.placeholder.parentNode.children)\n      .filter(function(el) {\n        return el !== self.el;\n      });\n\n    var index = siblings.indexOf(this._currentDrag.placeholder);\n    var topSibling = siblings[Math.max(0, index - 1)];\n    var bottomSibling = siblings[Math.min(siblings.length, index+1)];\n    var thisOffsetTop = this._currentDrag.currentY;// + this._currentDrag.startOffsetTop;\n\n    if(topSibling && (thisOffsetTop < topSibling.offsetTop + topSibling.offsetHeight/2)) {\n      ionic.DomUtil.swapNodes(this._currentDrag.placeholder, topSibling);\n      return index - 1;\n    } else if(bottomSibling && thisOffsetTop > (bottomSibling.offsetTop + bottomSibling.offsetHeight/2)) {\n      ionic.DomUtil.swapNodes(bottomSibling, this._currentDrag.placeholder);\n      return index + 1;\n    }\n  };\n\n  ReorderDrag.prototype.end = function(e, doneCallback) {\n    if(!this._currentDrag) {\n      doneCallback && doneCallback();\n      return;\n    }\n\n    var placeholder = this._currentDrag.placeholder;\n    var finalPosition = ionic.DomUtil.getChildIndex(placeholder, placeholder.nodeName.toLowerCase());\n\n    // Reposition the element\n    this.el.classList.remove(ITEM_REORDERING_CLASS);\n    this.el.style[ionic.CSS.TRANSFORM] = '';\n\n    placeholder.parentNode.insertBefore(this.el, placeholder);\n    placeholder.parentNode.removeChild(placeholder);\n\n    this.onReorder && this.onReorder(this.el, this._currentDrag.startIndex, finalPosition);\n\n    this._currentDrag = null;\n    doneCallback && doneCallback();\n  };\n\n\n\n  /**\n   * The ListView handles a list of items. It will process drag animations, edit mode,\n   * and other operations that are common on mobile lists or table views.\n   */\n  ionic.views.ListView = ionic.views.View.inherit({\n    initialize: function(opts) {\n      var _this = this;\n\n      opts = ionic.extend({\n        onReorder: function(el, oldIndex, newIndex) {},\n        virtualRemoveThreshold: -200,\n        virtualAddThreshold: 200,\n        canSwipe: function() {\n          return true;\n        }\n      }, opts);\n\n      ionic.extend(this, opts);\n\n      if(!this.itemHeight && this.listEl) {\n        this.itemHeight = this.listEl.children[0] && parseInt(this.listEl.children[0].style.height, 10);\n      }\n\n      //ionic.views.ListView.__super__.initialize.call(this, opts);\n\n      this.onRefresh = opts.onRefresh || function() {};\n      this.onRefreshOpening = opts.onRefreshOpening || function() {};\n      this.onRefreshHolding = opts.onRefreshHolding || function() {};\n\n      window.ionic.onGesture('release', function(e) {\n        _this._handleEndDrag(e);\n      }, this.el);\n\n      window.ionic.onGesture('drag', function(e) {\n        _this._handleDrag(e);\n      }, this.el);\n      // Start the drag states\n      this._initDrag();\n    },\n    /**\n     * Called to tell the list to stop refreshing. This is useful\n     * if you are refreshing the list and are done with refreshing.\n     */\n    stopRefreshing: function() {\n      var refresher = this.el.querySelector('.list-refresher');\n      refresher.style.height = '0px';\n    },\n\n    /**\n     * If we scrolled and have virtual mode enabled, compute the window\n     * of active elements in order to figure out the viewport to render.\n     */\n    didScroll: function(e) {\n      if(this.isVirtual) {\n        var itemHeight = this.itemHeight;\n\n        // TODO: This would be inaccurate if we are windowed\n        var totalItems = this.listEl.children.length;\n\n        // Grab the total height of the list\n        var scrollHeight = e.target.scrollHeight;\n\n        // Get the viewport height\n        var viewportHeight = this.el.parentNode.offsetHeight;\n\n        // scrollTop is the current scroll position\n        var scrollTop = e.scrollTop;\n\n        // High water is the pixel position of the first element to include (everything before\n        // that will be removed)\n        var highWater = Math.max(0, e.scrollTop + this.virtualRemoveThreshold);\n\n        // Low water is the pixel position of the last element to include (everything after\n        // that will be removed)\n        var lowWater = Math.min(scrollHeight, Math.abs(e.scrollTop) + viewportHeight + this.virtualAddThreshold);\n\n        // Compute how many items per viewport size can show\n        var itemsPerViewport = Math.floor((lowWater - highWater) / itemHeight);\n\n        // Get the first and last elements in the list based on how many can fit\n        // between the pixel range of lowWater and highWater\n        var first = parseInt(Math.abs(highWater / itemHeight), 10);\n        var last = parseInt(Math.abs(lowWater / itemHeight), 10);\n\n        // Get the items we need to remove\n        this._virtualItemsToRemove = Array.prototype.slice.call(this.listEl.children, 0, first);\n\n        // Grab the nodes we will be showing\n        var nodes = Array.prototype.slice.call(this.listEl.children, first, first + itemsPerViewport);\n\n        this.renderViewport && this.renderViewport(highWater, lowWater, first, last);\n      }\n    },\n\n    didStopScrolling: function(e) {\n      if(this.isVirtual) {\n        for(var i = 0; i < this._virtualItemsToRemove.length; i++) {\n          var el = this._virtualItemsToRemove[i];\n          //el.parentNode.removeChild(el);\n          this.didHideItem && this.didHideItem(i);\n        }\n        // Once scrolling stops, check if we need to remove old items\n\n      }\n    },\n\n    /**\n     * Clear any active drag effects on the list.\n     */\n    clearDragEffects: function() {\n      if(this._lastDragOp) {\n        this._lastDragOp.clean && this._lastDragOp.clean();\n        this._lastDragOp = null;\n      }\n    },\n\n    _initDrag: function() {\n      //ionic.views.ListView.__super__._initDrag.call(this);\n\n      // Store the last one\n      this._lastDragOp = this._dragOp;\n\n      this._dragOp = null;\n    },\n\n    // Return the list item from the given target\n    _getItem: function(target) {\n      while(target) {\n        if(target.classList.contains(ITEM_CLASS)) {\n          return target;\n        }\n        target = target.parentNode;\n      }\n      return null;\n    },\n\n\n    _startDrag: function(e) {\n      var _this = this;\n\n      var didStart = false;\n\n      this._isDragging = false;\n\n      var lastDragOp = this._lastDragOp;\n\n      // Check if this is a reorder drag\n      if(ionic.DomUtil.getParentOrSelfWithClass(e.target, ITEM_REORDER_BTN_CLASS) && (e.gesture.direction == 'up' || e.gesture.direction == 'down')) {\n        var item = this._getItem(e.target);\n\n        if(item) {\n          this._dragOp = new ReorderDrag({\n            listEl: this.el,\n            el: item,\n            scrollEl: this.scrollEl,\n            scrollView: this.scrollView,\n            onReorder: function(el, start, end) {\n              _this.onReorder && _this.onReorder(el, start, end);\n            }\n          });\n          this._dragOp.start(e);\n          e.preventDefault();\n        }\n      }\n\n      // Or check if this is a swipe to the side drag\n      else if(!this._didDragUpOrDown && (e.gesture.direction == 'left' || e.gesture.direction == 'right') && Math.abs(e.gesture.deltaX) > 5) {\n\n        // Make sure this is an item with buttons\n        var item = this._getItem(e.target);\n        if(item && item.querySelector('.item-options')) {\n          this._dragOp = new SlideDrag({ el: this.el, canSwipe: this.canSwipe });\n          this._dragOp.start(e);\n          e.preventDefault();\n        }\n      }\n\n      // If we had a last drag operation and this is a new one on a different item, clean that last one\n      if(lastDragOp && this._dragOp && !this._dragOp.isSameItem(lastDragOp) && e.defaultPrevented) {\n        lastDragOp.clean && lastDragOp.clean();\n      }\n    },\n\n\n    _handleEndDrag: function(e) {\n      var _this = this;\n\n      this._didDragUpOrDown = false;\n\n      if(!this._dragOp) {\n        //ionic.views.ListView.__super__._handleEndDrag.call(this, e);\n        return;\n      }\n\n      this._dragOp.end(e, function() {\n        _this._initDrag();\n      });\n    },\n\n    /**\n     * Process the drag event to move the item to the left or right.\n     */\n    _handleDrag: function(e) {\n      var _this = this, content, buttons;\n\n      if(Math.abs(e.gesture.deltaY) > 5) {\n        this._didDragUpOrDown = true;\n      }\n\n      // If we get a drag event, make sure we aren't in another drag, then check if we should\n      // start one\n      if(!this.isDragging && !this._dragOp) {\n        this._startDrag(e);\n      }\n\n      // No drag still, pass it up\n      if(!this._dragOp) {\n        //ionic.views.ListView.__super__._handleDrag.call(this, e);\n        return;\n      }\n\n      e.gesture.srcEvent.preventDefault();\n      this._dragOp.drag(e);\n    }\n\n  });\n\n})(ionic);\n\n(function(ionic) {\n'use strict';\n\n  ionic.views.Modal = ionic.views.View.inherit({\n    initialize: function(opts) {\n      opts = ionic.extend({\n        focusFirstInput: false,\n        unfocusOnHide: true,\n        focusFirstDelay: 600\n      }, opts);\n\n      ionic.extend(this, opts);\n\n      this.el = opts.el;\n    },\n    show: function() {\n      var self = this;\n\n      if(self.focusFirstInput) {\n        // Let any animations run first\n        window.setTimeout(function() {\n          var input = self.el.querySelector('input, textarea');\n          input && input.focus && input.focus();\n        }, self.focusFirstDelay);\n      }\n    },\n    hide: function() {\n      // Unfocus all elements\n      if(this.unfocusOnHide) {\n        var inputs = this.el.querySelectorAll('input, textarea');\n        // Let any animations run first\n        window.setTimeout(function() {\n          for(var i = 0; i < inputs.length; i++) {\n            inputs[i].blur && inputs[i].blur();\n          }\n        });\n      }\n    }\n  });\n\n})(ionic);\n\n(function(ionic) {\n'use strict';\n\n  /**\n   * The side menu view handles one of the side menu's in a Side Menu Controller\n   * configuration.\n   * It takes a DOM reference to that side menu element.\n   */\n  ionic.views.SideMenu = ionic.views.View.inherit({\n    initialize: function(opts) {\n      this.el = opts.el;\n      this.isEnabled = (typeof opts.isEnabled === 'undefined') ? true : opts.isEnabled;\n      this.setWidth(opts.width);\n    },\n\n    getFullWidth: function() {\n      return this.width;\n    },\n    setWidth: function(width) {\n      this.width = width;\n      this.el.style.width = width + 'px';\n    },\n    setIsEnabled: function(isEnabled) {\n      this.isEnabled = isEnabled;\n    },\n    bringUp: function() {\n      if(this.el.style.zIndex !== '0') {\n        this.el.style.zIndex = '0';\n      }\n    },\n    pushDown: function() {\n      if(this.el.style.zIndex !== '-1') {\n        this.el.style.zIndex = '-1';\n      }\n    }\n  });\n\n  ionic.views.SideMenuContent = ionic.views.View.inherit({\n    initialize: function(opts) {\n      var _this = this;\n\n      ionic.extend(this, {\n        animationClass: 'menu-animated',\n        onDrag: function(e) {},\n        onEndDrag: function(e) {},\n      }, opts);\n\n      ionic.onGesture('drag', ionic.proxy(this._onDrag, this), this.el);\n      ionic.onGesture('release', ionic.proxy(this._onEndDrag, this), this.el);\n    },\n    _onDrag: function(e) {\n      this.onDrag && this.onDrag(e);\n    },\n    _onEndDrag: function(e) {\n      this.onEndDrag && this.onEndDrag(e);\n    },\n    disableAnimation: function() {\n      this.el.classList.remove(this.animationClass);\n    },\n    enableAnimation: function() {\n      this.el.classList.add(this.animationClass);\n    },\n    getTranslateX: function() {\n      return parseFloat(this.el.style[ionic.CSS.TRANSFORM].replace('translate3d(', '').split(',')[0]);\n    },\n    setTranslateX: ionic.animationFrameThrottle(function(x) {\n      this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(' + x + 'px, 0, 0)';\n    })\n  });\n\n})(ionic);\n\n/*\n * Adapted from Swipe.js 2.0\n *\n * Brad Birdsall\n * Copyright 2013, MIT License\n *\n*/\n\n(function(ionic) {\n'use strict';\n\nionic.views.Slider = ionic.views.View.inherit({\n  initialize: function (options) {\n    var slider = this;\n\n    // utilities\n    var noop = function() {}; // simple no operation function\n    var offloadFn = function(fn) { setTimeout(fn || noop, 0) }; // offload a functions execution\n\n    // check browser capabilities\n    var browser = {\n      addEventListener: !!window.addEventListener,\n      touch: ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch,\n      transitions: (function(temp) {\n        var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];\n        for ( var i in props ) if (temp.style[ props[i] ] !== undefined) return true;\n        return false;\n      })(document.createElement('swipe'))\n    };\n\n\n    var container = options.el;\n\n    // quit if no root element\n    if (!container) return;\n    var element = container.children[0];\n    var slides, slidePos, width, length;\n    options = options || {};\n    var index = parseInt(options.startSlide, 10) || 0;\n    var speed = options.speed || 300;\n    options.continuous = options.continuous !== undefined ? options.continuous : true;\n\n    function setup() {\n\n      // cache slides\n      slides = element.children;\n      length = slides.length;\n\n      // set continuous to false if only one slide\n      if (slides.length < 2) options.continuous = false;\n\n      //special case if two slides\n      if (browser.transitions && options.continuous && slides.length < 3) {\n        element.appendChild(slides[0].cloneNode(true));\n        element.appendChild(element.children[1].cloneNode(true));\n        slides = element.children;\n      }\n\n      // create an array to store current positions of each slide\n      slidePos = new Array(slides.length);\n\n      // determine width of each slide\n      width = container.getBoundingClientRect().width || container.offsetWidth;\n\n      element.style.width = (slides.length * width) + 'px';\n\n      // stack elements\n      var pos = slides.length;\n      while(pos--) {\n\n        var slide = slides[pos];\n\n        slide.style.width = width + 'px';\n        slide.setAttribute('data-index', pos);\n\n        if (browser.transitions) {\n          slide.style.left = (pos * -width) + 'px';\n          move(pos, index > pos ? -width : (index < pos ? width : 0), 0);\n        }\n\n      }\n\n      // reposition elements before and after index\n      if (options.continuous && browser.transitions) {\n        move(circle(index-1), -width, 0);\n        move(circle(index+1), width, 0);\n      }\n\n      if (!browser.transitions) element.style.left = (index * -width) + 'px';\n\n      container.style.visibility = 'visible';\n\n      options.slidesChanged && options.slidesChanged();\n    }\n\n    function prev() {\n\n      if (options.continuous) slide(index-1);\n      else if (index) slide(index-1);\n\n    }\n\n    function next() {\n\n      if (options.continuous) slide(index+1);\n      else if (index < slides.length - 1) slide(index+1);\n\n    }\n\n    function circle(index) {\n\n      // a simple positive modulo using slides.length\n      return (slides.length + (index % slides.length)) % slides.length;\n\n    }\n\n    function slide(to, slideSpeed) {\n\n      // do nothing if already on requested slide\n      if (index == to) return;\n\n      if (browser.transitions) {\n\n        var direction = Math.abs(index-to) / (index-to); // 1: backward, -1: forward\n\n        // get the actual position of the slide\n        if (options.continuous) {\n          var natural_direction = direction;\n          direction = -slidePos[circle(to)] / width;\n\n          // if going forward but to < index, use to = slides.length + to\n          // if going backward but to > index, use to = -slides.length + to\n          if (direction !== natural_direction) to =  -direction * slides.length + to;\n\n        }\n\n        var diff = Math.abs(index-to) - 1;\n\n        // move all the slides between index and to in the right direction\n        while (diff--) move( circle((to > index ? to : index) - diff - 1), width * direction, 0);\n\n        to = circle(to);\n\n        move(index, width * direction, slideSpeed || speed);\n        move(to, 0, slideSpeed || speed);\n\n        if (options.continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place\n\n      } else {\n\n        to = circle(to);\n        animate(index * -width, to * -width, slideSpeed || speed);\n        //no fallback for a circular continuous if the browser does not accept transitions\n      }\n\n      index = to;\n      offloadFn(options.callback && options.callback(index, slides[index]));\n    }\n\n    function move(index, dist, speed) {\n\n      translate(index, dist, speed);\n      slidePos[index] = dist;\n\n    }\n\n    function translate(index, dist, speed) {\n\n      var slide = slides[index];\n      var style = slide && slide.style;\n\n      if (!style) return;\n\n      style.webkitTransitionDuration =\n      style.MozTransitionDuration =\n      style.msTransitionDuration =\n      style.OTransitionDuration =\n      style.transitionDuration = speed + 'ms';\n\n      style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';\n      style.msTransform =\n      style.MozTransform =\n      style.OTransform = 'translateX(' + dist + 'px)';\n\n    }\n\n    function animate(from, to, speed) {\n\n      // if not an animation, just reposition\n      if (!speed) {\n\n        element.style.left = to + 'px';\n        return;\n\n      }\n\n      var start = +new Date;\n\n      var timer = setInterval(function() {\n\n        var timeElap = +new Date - start;\n\n        if (timeElap > speed) {\n\n          element.style.left = to + 'px';\n\n          if (delay) begin();\n\n          options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n\n          clearInterval(timer);\n          return;\n\n        }\n\n        element.style.left = (( (to - from) * (Math.floor((timeElap / speed) * 100) / 100) ) + from) + 'px';\n\n      }, 4);\n\n    }\n\n    // setup auto slideshow\n    var delay = options.auto || 0;\n    var interval;\n\n    function begin() {\n\n      interval = setTimeout(next, delay);\n\n    }\n\n    function stop() {\n\n      delay = options.auto || 0;\n      clearTimeout(interval);\n\n    }\n\n\n    // setup initial vars\n    var start = {};\n    var delta = {};\n    var isScrolling;\n\n    // setup event capturing\n    var events = {\n\n      handleEvent: function(event) {\n        if(event.type == 'mousedown' || event.type == 'mouseup' || event.type == 'mousemove') {\n          event.touches = [{\n            pageX: event.pageX,\n            pageY: event.pageY\n          }];\n        }\n\n        switch (event.type) {\n          case 'mousedown': this.start(event); break;\n          case 'touchstart': this.start(event); break;\n          case 'touchmove': this.touchmove(event); break;\n          case 'mousemove': this.touchmove(event); break;\n          case 'touchend': offloadFn(this.end(event)); break;\n          case 'mouseup': offloadFn(this.end(event)); break;\n          case 'webkitTransitionEnd':\n          case 'msTransitionEnd':\n          case 'oTransitionEnd':\n          case 'otransitionend':\n          case 'transitionend': offloadFn(this.transitionEnd(event)); break;\n          case 'resize': offloadFn(setup); break;\n        }\n\n        if (options.stopPropagation) event.stopPropagation();\n\n      },\n      start: function(event) {\n\n        var touches = event.touches[0];\n\n        // measure start values\n        start = {\n\n          // get initial touch coords\n          x: touches.pageX,\n          y: touches.pageY,\n\n          // store time to determine touch duration\n          time: +new Date\n\n        };\n\n        // used for testing first move event\n        isScrolling = undefined;\n\n        // reset delta and end measurements\n        delta = {};\n\n        // attach touchmove and touchend listeners\n        if(browser.touch) {\n          element.addEventListener('touchmove', this, false);\n          element.addEventListener('touchend', this, false);\n        } else {\n          element.addEventListener('mousemove', this, false);\n          element.addEventListener('mouseup', this, false);\n          document.addEventListener('mouseup', this, false);\n        }\n      },\n      touchmove: function(event) {\n\n        // ensure swiping with one touch and not pinching\n        // ensure sliding is enabled\n        if (event.touches.length > 1 ||\n            event.scale && event.scale !== 1 ||\n            slider.slideIsDisabled) {\n          return;\n        }\n\n        if (options.disableScroll) event.preventDefault();\n\n        var touches = event.touches[0];\n\n        // measure change in x and y\n        delta = {\n          x: touches.pageX - start.x,\n          y: touches.pageY - start.y\n        }\n\n        // determine if scrolling test has run - one time test\n        if ( typeof isScrolling == 'undefined') {\n          isScrolling = !!( isScrolling || Math.abs(delta.x) < Math.abs(delta.y) );\n        }\n\n        // if user is not trying to scroll vertically\n        if (!isScrolling) {\n\n          // prevent native scrolling\n          event.preventDefault();\n\n          // stop slideshow\n          stop();\n\n          // increase resistance if first or last slide\n          if (options.continuous) { // we don't add resistance at the end\n\n            translate(circle(index-1), delta.x + slidePos[circle(index-1)], 0);\n            translate(index, delta.x + slidePos[index], 0);\n            translate(circle(index+1), delta.x + slidePos[circle(index+1)], 0);\n\n          } else {\n\n            delta.x =\n              delta.x /\n                ( (!index && delta.x > 0               // if first slide and sliding left\n                  || index == slides.length - 1        // or if last slide and sliding right\n                  && delta.x < 0                       // and if sliding at all\n                ) ?\n                ( Math.abs(delta.x) / width + 1 )      // determine resistance level\n                : 1 );                                 // no resistance if false\n\n            // translate 1:1\n            translate(index-1, delta.x + slidePos[index-1], 0);\n            translate(index, delta.x + slidePos[index], 0);\n            translate(index+1, delta.x + slidePos[index+1], 0);\n          }\n\n        }\n\n      },\n      end: function(event) {\n\n        // measure duration\n        var duration = +new Date - start.time;\n\n        // determine if slide attempt triggers next/prev slide\n        var isValidSlide =\n              Number(duration) < 250               // if slide duration is less than 250ms\n              && Math.abs(delta.x) > 20            // and if slide amt is greater than 20px\n              || Math.abs(delta.x) > width/2;      // or if slide amt is greater than half the width\n\n        // determine if slide attempt is past start and end\n        var isPastBounds =\n              !index && delta.x > 0                            // if first slide and slide amt is greater than 0\n              || index == slides.length - 1 && delta.x < 0;    // or if last slide and slide amt is less than 0\n\n        if (options.continuous) isPastBounds = false;\n\n        // determine direction of swipe (true:right, false:left)\n        var direction = delta.x < 0;\n\n        // if not scrolling vertically\n        if (!isScrolling) {\n\n          if (isValidSlide && !isPastBounds) {\n\n            if (direction) {\n\n              if (options.continuous) { // we need to get the next in this direction in place\n\n                move(circle(index-1), -width, 0);\n                move(circle(index+2), width, 0);\n\n              } else {\n                move(index-1, -width, 0);\n              }\n\n              move(index, slidePos[index]-width, speed);\n              move(circle(index+1), slidePos[circle(index+1)]-width, speed);\n              index = circle(index+1);\n\n            } else {\n              if (options.continuous) { // we need to get the next in this direction in place\n\n                move(circle(index+1), width, 0);\n                move(circle(index-2), -width, 0);\n\n              } else {\n                move(index+1, width, 0);\n              }\n\n              move(index, slidePos[index]+width, speed);\n              move(circle(index-1), slidePos[circle(index-1)]+width, speed);\n              index = circle(index-1);\n\n            }\n\n            options.callback && options.callback(index, slides[index]);\n\n          } else {\n\n            if (options.continuous) {\n\n              move(circle(index-1), -width, speed);\n              move(index, 0, speed);\n              move(circle(index+1), width, speed);\n\n            } else {\n\n              move(index-1, -width, speed);\n              move(index, 0, speed);\n              move(index+1, width, speed);\n            }\n\n          }\n\n        }\n\n        // kill touchmove and touchend event listeners until touchstart called again\n        if(browser.touch) {\n          element.removeEventListener('touchmove', events, false)\n          element.removeEventListener('touchend', events, false)\n        } else {\n          element.removeEventListener('mousemove', events, false)\n          element.removeEventListener('mouseup', events, false)\n          document.removeEventListener('mouseup', events, false);\n        }\n\n      },\n      transitionEnd: function(event) {\n\n        if (parseInt(event.target.getAttribute('data-index'), 10) == index) {\n\n          if (delay) begin();\n\n          options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n\n        }\n\n      }\n\n    }\n\n    // Public API\n    this.update = function() {\n      setTimeout(setup);\n    };\n    this.setup = function() {\n      setup();\n    };\n\n    this.enableSlide = function(shouldEnable) {\n      if (arguments.length) {\n        this.slideIsDisabled = !shouldEnable;\n      }\n      return !this.slideIsDisabled;\n    },\n    this.slide = function(to, speed) {\n      // cancel slideshow\n      stop();\n\n      slide(to, speed);\n    };\n\n    this.prev = this.previous = function() {\n      // cancel slideshow\n      stop();\n\n      prev();\n    };\n\n    this.next = function() {\n      // cancel slideshow\n      stop();\n\n      next();\n    };\n\n    this.stop = function() {\n      // cancel slideshow\n      stop();\n    };\n\n    this.currentIndex = function() {\n      // return current index position\n      return index;\n    };\n\n    this.slidesCount = function() {\n      // return total number of slides\n      return length;\n    };\n\n    this.kill = function() {\n      // cancel slideshow\n      stop();\n\n      // reset element\n      element.style.width = '';\n      element.style.left = '';\n\n      // reset slides\n      var pos = slides.length;\n      while(pos--) {\n\n        var slide = slides[pos];\n        slide.style.width = '';\n        slide.style.left = '';\n\n        if (browser.transitions) translate(pos, 0, 0);\n\n      }\n\n      // removed event listeners\n      if (browser.addEventListener) {\n\n        // remove current event listeners\n        element.removeEventListener('touchstart', events, false);\n        element.removeEventListener('webkitTransitionEnd', events, false);\n        element.removeEventListener('msTransitionEnd', events, false);\n        element.removeEventListener('oTransitionEnd', events, false);\n        element.removeEventListener('otransitionend', events, false);\n        element.removeEventListener('transitionend', events, false);\n        window.removeEventListener('resize', events, false);\n\n      }\n      else {\n\n        window.onresize = null;\n\n      }\n    };\n\n    this.load = function() {\n      // trigger setup\n      setup();\n\n      // start auto slideshow if applicable\n      if (delay) begin();\n\n\n      // add event listeners\n      if (browser.addEventListener) {\n\n        // set touchstart event on element\n        if (browser.touch) {\n          element.addEventListener('touchstart', events, false);\n        } else {\n          element.addEventListener('mousedown', events, false);\n        }\n\n        if (browser.transitions) {\n          element.addEventListener('webkitTransitionEnd', events, false);\n          element.addEventListener('msTransitionEnd', events, false);\n          element.addEventListener('oTransitionEnd', events, false);\n          element.addEventListener('otransitionend', events, false);\n          element.addEventListener('transitionend', events, false);\n        }\n\n        // set resize event on window\n        window.addEventListener('resize', events, false);\n\n      } else {\n\n        window.onresize = function () { setup() }; // to play nice with old IE\n\n      }\n    }\n\n  }\n});\n\n})(ionic);\n\n(function(ionic) {\n'use strict';\n\n  ionic.views.Toggle = ionic.views.View.inherit({\n    initialize: function(opts) {\n      var self = this;\n\n      this.el = opts.el;\n      this.checkbox = opts.checkbox;\n      this.track = opts.track;\n      this.handle = opts.handle;\n      this.openPercent = -1;\n      this.onChange = opts.onChange || function() {};\n\n      this.triggerThreshold = opts.triggerThreshold || 20;\n\n      this.dragStartHandler = function(e) {\n        self.dragStart(e);\n      };\n      this.dragHandler = function(e) {\n        self.drag(e);\n      };\n      this.holdHandler = function(e) {\n        self.hold(e);\n      };\n      this.releaseHandler = function(e) {\n        self.release(e);\n      };\n\n      this.dragStartGesture = ionic.onGesture('dragstart', this.dragStartHandler, this.el);\n      this.dragGesture = ionic.onGesture('drag', this.dragHandler, this.el);\n      this.dragHoldGesture = ionic.onGesture('hold', this.holdHandler, this.el);\n      this.dragReleaseGesture = ionic.onGesture('release', this.releaseHandler, this.el);\n    },\n\n    destroy: function() {\n      ionic.offGesture(this.dragStartGesture, 'dragstart', this.dragStartGesture);\n      ionic.offGesture(this.dragGesture, 'drag', this.dragGesture);\n      ionic.offGesture(this.dragHoldGesture, 'hold', this.holdHandler);\n      ionic.offGesture(this.dragReleaseGesture, 'release', this.releaseHandler);\n    },\n\n    tap: function(e) {\n      if(this.el.getAttribute('disabled') !== 'disabled') {\n        this.val( !this.checkbox.checked );\n      }\n    },\n\n    dragStart: function(e) {\n      if(this.checkbox.disabled) return;\n\n      this._dragInfo = {\n        width: this.el.offsetWidth,\n        left: this.el.offsetLeft,\n        right: this.el.offsetLeft + this.el.offsetWidth,\n        triggerX: this.el.offsetWidth / 2,\n        initialState: this.checkbox.checked\n      };\n\n      // Stop any parent dragging\n      e.gesture.srcEvent.preventDefault();\n\n      // Trigger hold styles\n      this.hold(e);\n    },\n\n    drag: function(e) {\n      var self = this;\n      if(!this._dragInfo) { return; }\n\n      // Stop any parent dragging\n      e.gesture.srcEvent.preventDefault();\n\n      ionic.requestAnimationFrame(function(amount) {\n\n        var slidePageLeft = self.track.offsetLeft + (self.handle.offsetWidth / 2);\n        var slidePageRight = self.track.offsetLeft + self.track.offsetWidth - (self.handle.offsetWidth / 2);\n        var dx = e.gesture.deltaX;\n\n        var px = e.gesture.touches[0].pageX - self._dragInfo.left;\n        var mx = self._dragInfo.width - self.triggerThreshold;\n\n        // The initial state was on, so \"tend towards\" on\n        if(self._dragInfo.initialState) {\n          if(px < self.triggerThreshold) {\n            self.setOpenPercent(0);\n          } else if(px > self._dragInfo.triggerX) {\n            self.setOpenPercent(100);\n          }\n        } else {\n          // The initial state was off, so \"tend towards\" off\n          if(px < self._dragInfo.triggerX) {\n            self.setOpenPercent(0);\n          } else if(px > mx) {\n            self.setOpenPercent(100);\n          }\n        }\n      });\n    },\n\n    endDrag: function(e) {\n      this._dragInfo = null;\n    },\n\n    hold: function(e) {\n      this.el.classList.add('dragging');\n    },\n    release: function(e) {\n      this.el.classList.remove('dragging');\n      this.endDrag(e);\n    },\n\n\n    setOpenPercent: function(openPercent) {\n      // only make a change if the new open percent has changed\n      if(this.openPercent < 0 || (openPercent < (this.openPercent - 3) || openPercent > (this.openPercent + 3) ) ) {\n        this.openPercent = openPercent;\n\n        if(openPercent === 0) {\n          this.val(false);\n        } else if(openPercent === 100) {\n          this.val(true);\n        } else {\n          var openPixel = Math.round( (openPercent / 100) * this.track.offsetWidth - (this.handle.offsetWidth) );\n          openPixel = (openPixel < 1 ? 0 : openPixel);\n          this.handle.style[ionic.CSS.TRANSFORM] = 'translate3d(' + openPixel + 'px,0,0)';\n        }\n      }\n    },\n\n    val: function(value) {\n      if(value === true || value === false) {\n        if(this.handle.style[ionic.CSS.TRANSFORM] !== \"\") {\n          this.handle.style[ionic.CSS.TRANSFORM] = \"\";\n        }\n        this.checkbox.checked = value;\n        this.openPercent = (value ? 100 : 0);\n        this.onChange && this.onChange();\n      }\n      return this.checkbox.checked;\n    }\n\n  });\n\n})(ionic);\n\n(function(ionic) {\n'use strict';\n  ionic.controllers.ViewController = function(options) {\n    this.initialize.apply(this, arguments);\n  };\n\n  ionic.controllers.ViewController.inherit = ionic.inherit;\n\n  ionic.extend(ionic.controllers.ViewController.prototype, {\n    initialize: function() {},\n    // Destroy this view controller, including all child views\n    destroy: function() {\n    }\n  });\n\n})(window.ionic);\n\n(function(ionic) {\n'use strict';\n\n  /**\n   * The SideMenuController is a controller with a left and/or right menu that\n   * can be slid out and toggled. Seen on many an app.\n   *\n   * The right or left menu can be disabled or not used at all, if desired.\n   */\n  ionic.controllers.SideMenuController = ionic.controllers.ViewController.inherit({\n    initialize: function(options) {\n      var self = this;\n\n      this.left = options.left;\n      this.right = options.right;\n      this.content = options.content;\n      this.dragThresholdX = options.dragThresholdX || 10;\n\n      this._rightShowing = false;\n      this._leftShowing = false;\n      this._isDragging = false;\n\n      if(this.content) {\n        this.content.onDrag = function(e) {\n          self._handleDrag(e);\n        };\n\n        this.content.onEndDrag =function(e) {\n          self._endDrag(e);\n        };\n      }\n    },\n    /**\n     * Set the content view controller if not passed in the constructor options.\n     *\n     * @param {object} content\n     */\n    setContent: function(content) {\n      var self = this;\n\n      this.content = content;\n\n      this.content.onDrag = function(e) {\n        self._handleDrag(e);\n      };\n\n      this.content.endDrag = function(e) {\n        self._endDrag(e);\n      };\n    },\n\n    isOpenLeft: function() {\n      return this.getOpenAmount() > 0;\n    },\n\n    isOpenRight: function() {\n      return this.getOpenAmount() < 0;\n    },\n\n    /**\n     * Toggle the left menu to open 100%\n     */\n    toggleLeft: function(shouldOpen) {\n      var openAmount = this.getOpenAmount();\n      if (arguments.length === 0) {\n        shouldOpen = openAmount <= 0;\n      }\n      this.content.enableAnimation();\n      if(!shouldOpen) {\n        this.openPercentage(0);\n      } else {\n        this.openPercentage(100);\n      }\n    },\n\n    /**\n     * Toggle the right menu to open 100%\n     */\n    toggleRight: function(shouldOpen) {\n      var openAmount = this.getOpenAmount();\n      if (arguments.length === 0) {\n        shouldOpen = openAmount >= 0;\n      }\n      this.content.enableAnimation();\n      if(!shouldOpen) {\n        this.openPercentage(0);\n      } else {\n        this.openPercentage(-100);\n      }\n    },\n\n    /**\n     * Close all menus.\n     */\n    close: function() {\n      this.openPercentage(0);\n    },\n\n    /**\n     * @return {float} The amount the side menu is open, either positive or negative for left (positive), or right (negative)\n     */\n    getOpenAmount: function() {\n      return this.content && this.content.getTranslateX() || 0;\n    },\n\n    /**\n     * @return {float} The ratio of open amount over menu width. For example, a\n     * menu of width 100 open 50 pixels would be open 50% or a ratio of 0.5. Value is negative\n     * for right menu.\n     */\n    getOpenRatio: function() {\n      var amount = this.getOpenAmount();\n      if(amount >= 0) {\n        return amount / this.left.width;\n      }\n      return amount / this.right.width;\n    },\n\n    isOpen: function() {\n      return this.getOpenAmount() !== 0;\n    },\n\n    /**\n     * @return {float} The percentage of open amount over menu width. For example, a\n     * menu of width 100 open 50 pixels would be open 50%. Value is negative\n     * for right menu.\n     */\n    getOpenPercentage: function() {\n      return this.getOpenRatio() * 100;\n    },\n\n    /**\n     * Open the menu with a given percentage amount.\n     * @param {float} percentage The percentage (positive or negative for left/right) to open the menu.\n     */\n    openPercentage: function(percentage) {\n      var p = percentage / 100;\n\n      if(this.left && percentage >= 0) {\n        this.openAmount(this.left.width * p);\n      } else if(this.right && percentage < 0) {\n        var maxRight = this.right.width;\n        this.openAmount(this.right.width * p);\n      }\n    },\n\n    /**\n     * Open the menu the given pixel amount.\n     * @param {float} amount the pixel amount to open the menu. Positive value for left menu,\n     * negative value for right menu (only one menu will be visible at a time).\n     */\n    openAmount: function(amount) {\n      var maxLeft = this.left && this.left.width || 0;\n      var maxRight = this.right && this.right.width || 0;\n\n      // Check if we can move to that side, depending if the left/right panel is enabled\n      if(!(this.left && this.left.isEnabled) && amount > 0) {\n        this.content.setTranslateX(0);\n        return;\n      }\n\n      if(!(this.right && this.right.isEnabled) && amount < 0) {\n        this.content.setTranslateX(0);\n        return;\n      }\n\n      if(this._leftShowing && amount > maxLeft) {\n        this.content.setTranslateX(maxLeft);\n        return;\n      }\n\n      if(this._rightShowing && amount < -maxRight) {\n        this.content.setTranslateX(-maxRight);\n        return;\n      }\n\n      this.content.setTranslateX(amount);\n\n      if(amount >= 0) {\n        this._leftShowing = true;\n        this._rightShowing = false;\n\n        if(amount > 0) {\n          // Push the z-index of the right menu down\n          this.right && this.right.pushDown && this.right.pushDown();\n          // Bring the z-index of the left menu up\n          this.left && this.left.bringUp && this.left.bringUp();\n        }\n      } else {\n        this._rightShowing = true;\n        this._leftShowing = false;\n\n        // Bring the z-index of the right menu up\n        this.right && this.right.bringUp && this.right.bringUp();\n        // Push the z-index of the left menu down\n        this.left && this.left.pushDown && this.left.pushDown();\n      }\n    },\n\n    /**\n     * Given an event object, find the final resting position of this side\n     * menu. For example, if the user \"throws\" the content to the right and\n     * releases the touch, the left menu should snap open (animated, of course).\n     *\n     * @param {Event} e the gesture event to use for snapping\n     */\n    snapToRest: function(e) {\n      // We want to animate at the end of this\n      this.content.enableAnimation();\n      this._isDragging = false;\n\n      // Check how much the panel is open after the drag, and\n      // what the drag velocity is\n      var ratio = this.getOpenRatio();\n\n      if(ratio === 0) {\n        // Just to be safe\n        this.openPercentage(0);\n        return;\n      }\n\n      var velocityThreshold = 0.3;\n      var velocityX = e.gesture.velocityX;\n      var direction = e.gesture.direction;\n\n      // Less than half, going left\n      //if(ratio > 0 && ratio < 0.5 && direction == 'left' && velocityX < velocityThreshold) {\n      //this.openPercentage(0);\n      //}\n\n      // Going right, less than half, too slow (snap back)\n      if(ratio > 0 && ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {\n        this.openPercentage(0);\n      }\n\n      // Going left, more than half, too slow (snap back)\n      else if(ratio > 0.5 && direction == 'left' && velocityX < velocityThreshold) {\n        this.openPercentage(100);\n      }\n\n      // Going left, less than half, too slow (snap back)\n      else if(ratio < 0 && ratio > -0.5 && direction == 'left' && velocityX < velocityThreshold) {\n        this.openPercentage(0);\n      }\n\n      // Going right, more than half, too slow (snap back)\n      else if(ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {\n        this.openPercentage(-100);\n      }\n\n      // Going right, more than half, or quickly (snap open)\n      else if(direction == 'right' && ratio >= 0 && (ratio >= 0.5 || velocityX > velocityThreshold)) {\n        this.openPercentage(100);\n      }\n\n      // Going left, more than half, or quickly (span open)\n      else if(direction == 'left' && ratio <= 0 && (ratio <= -0.5 || velocityX > velocityThreshold)) {\n        this.openPercentage(-100);\n      }\n\n      // Snap back for safety\n      else {\n        this.openPercentage(0);\n      }\n    },\n\n    // End a drag with the given event\n    _endDrag: function(e) {\n      if(this._isDragging) {\n        this.snapToRest(e);\n      }\n      this._startX = null;\n      this._lastX = null;\n      this._offsetX = null;\n    },\n\n    // Handle a drag event\n    _handleDrag: function(e) {\n      // If we don't have start coords, grab and store them\n      if(!this._startX) {\n        this._startX = e.gesture.touches[0].pageX;\n        this._lastX = this._startX;\n      } else {\n        // Grab the current tap coords\n        this._lastX = e.gesture.touches[0].pageX;\n      }\n\n      // Calculate difference from the tap points\n      if(!this._isDragging && Math.abs(this._lastX - this._startX) > this.dragThresholdX) {\n        // if the difference is greater than threshold, start dragging using the current\n        // point as the starting point\n        this._startX = this._lastX;\n\n        this._isDragging = true;\n        // Initialize dragging\n        this.content.disableAnimation();\n        this._offsetX = this.getOpenAmount();\n      }\n\n      if(this._isDragging) {\n        this.openAmount(this._offsetX + (this._lastX - this._startX));\n      }\n    }\n  });\n\n})(ionic);\n\n})();","//     (c) 2012 Airbnb, Inc.\r\n//\r\n//     polyglot.js may be freely distributed under the terms of the BSD\r\n//     license. For all licensing information, details, and documention:\r\n//     http://airbnb.github.com/polyglot.js\r\n//\r\n//\r\n// Polyglot.js is an I18n helper library written in JavaScript, made to\r\n// work both in the browser and in Node. It provides a simple solution for\r\n// interpolation and pluralization, based off of Airbnb's\r\n// experience adding I18n functionality to its Backbone.js and Node apps.\r\n//\r\n// Polylglot is agnostic to your translation backend. It doesn't perform any\r\n// translation; it simply gives you a way to manage translated phrases from\r\n// your client- or server-side JavaScript application.\r\n//\r\n\r\n!function(root) {\r\n  'use strict';\r\n\r\n  // ### Polyglot class constructor\r\n  function Polyglot(options) {\r\n    options = options || {};\r\n    this.phrases = options.phrases || {};\r\n    this.currentLocale = options.locale || 'en';\r\n  }\r\n\r\n  // ### Version\r\n  Polyglot.VERSION = '0.2.0';\r\n\r\n  // ### polyglot.locale([locale])\r\n  //\r\n  // Get or set locale. Internally, Polyglot only uses locale for pluralization.\r\n  Polyglot.prototype.locale = function(newLocale) {\r\n    if (newLocale) this.currentLocale = newLocale;\r\n    return this.currentLocale;\r\n  };\r\n\r\n  // ### polyglot.extend(phrases)\r\n  //\r\n  // Use `extend` to tell Polyglot how to translate a given key.\r\n  //\r\n  //     polyglot.extend({\r\n  //       \"hello\": \"Hello\",\r\n  //       \"hello_name\": \"Hello, %{name}\"\r\n  //     });\r\n  //\r\n  // The key can be any string.  Feel free to call `extend` multiple times;\r\n  // it will override any phrases with the same key, but leave existing phrases\r\n  // untouched.\r\n  Polyglot.prototype.extend = function(morePhrases) {\r\n    for (var key in morePhrases) {\r\n      if (morePhrases.hasOwnProperty(key)) {\r\n        this.phrases[key] = morePhrases[key];\r\n      }\r\n    }\r\n  };\r\n\r\n  // ### polyglot.clear()\r\n  //\r\n  // Clears all phrases. Useful for special cases, such as freeing\r\n  // up memory if you have lots of phrases but no longer need to\r\n  // perform any translation. Also used internally by `replace`.\r\n  Polyglot.prototype.clear = function() {\r\n    this.phrases = {};\r\n  };\r\n\r\n  // ### polyglot.replace(phrases)\r\n  //\r\n  // Completely replace the existing phrases with a new set of phrases.\r\n  // Normally, just use `extend` to add more phrases, but under certain\r\n  // circumstances, you may want to make sure no old phrases are lying around.\r\n  Polyglot.prototype.replace = function(newPhrases) {\r\n    this.clear();\r\n    this.extend(newPhrases);\r\n  };\r\n\r\n\r\n  // ### polyglot.t(key, options)\r\n  //\r\n  // The most-used method. Provide a key, and `t` will return the\r\n  // phrase.\r\n  //\r\n  //     polyglot.t(\"hello\");\r\n  //     => \"Hello\"\r\n  //\r\n  // The phrase value is provided first by a call to `polyglot.extend()` or\r\n  // `polyglot.replace()`.\r\n  //\r\n  // Pass in an object as the second argument to perform interpolation.\r\n  //\r\n  //     polyglot.t(\"hello_name\", {name: \"Spike\"});\r\n  //     => \"Hello, Spike\"\r\n  //\r\n  // If you like, you can provide a default value in case the phrase is missing.\r\n  // Use the special option key \"_\" to specify a default.\r\n  //\r\n  //     polyglot.t(\"i_like_to_write_in_language\", {\r\n  //       _: \"I like to write in %{language}.\",\r\n  //       language: \"JavaScript\"\r\n  //     });\r\n  //     => \"I like to write in JavaScript.\"\r\n  //\r\n  Polyglot.prototype.t = function(key, options) {\r\n    var result;\r\n    options = options || {};\r\n    var phrase = this.phrases[key] || options._ || '';\r\n    if (phrase === '') {\r\n      warn('Missing translation for key: \"'+key+'\"');\r\n      result = key;\r\n    } else {\r\n      options = clone(options);\r\n      // This allows you to pass an Array, Backbone.Collection, or anything\r\n      // with a `length` property as the `smart_count` parameter for pluralization.\r\n      if (options.smart_count != null && options.smart_count.length != null) {\r\n        options.smart_count = options.smart_count.length;\r\n      }\r\n      result = choosePluralForm(phrase, this.currentLocale, options.smart_count);\r\n      result = interpolate(result, options);\r\n    }\r\n    return result;\r\n  };\r\n\r\n\r\n  // ### polylglot.pluralize(noun, count)\r\n  //\r\n  // A shortcut for calling `polyglot.t()` with a special `||||`-delimeted phrase.\r\n  // Works well for the simple case, like \"1 car\".\r\n  Polyglot.prototype.pluralize = function(noun, count) {\r\n    if (count != null && count.length != null) {\r\n      count = count.length;\r\n    }\r\n    var key = pluralizeKey(noun);\r\n    return this.t(key, {smart_count: count});\r\n  };\r\n\r\n  function pluralizeKey(noun) {\r\n    return 'shared.pluralize.' + noun;\r\n  }\r\n\r\n  // #### Pluralization methods\r\n  // The string that separates the different phrase possibilities.\r\n  var delimeter = '||||';\r\n\r\n  // Mapping from pluralization group plural logic.\r\n  var pluralTypes = {\r\n    chinese:   function(n) { return 0; },\r\n    german:    function(n) { return n !== 1 ? 1 : 0; },\r\n    french:    function(n) { return n > 1 ? 1 : 0; },\r\n    russian:   function(n) { return n % 10 === 1 && n % 100 !== 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2; },\r\n    czech:     function(n) { return (n === 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2; },\r\n    polish:    function(n) { return (n === 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2); },\r\n    icelandic: function(n) { return (n % 10 !== 1 || n % 100 === 11) ? 1 : 0; }\r\n  };\r\n\r\n  // Mapping from pluralization group to individual locales.\r\n  var pluralTypeToLanguages = {\r\n    chinese:   ['id', 'ja', 'ko', 'ms', 'th', 'tr', 'zh'],\r\n    german:    ['da', 'de', 'en', 'es', 'fi', 'el', 'he', 'hu', 'it', 'nl', 'no', 'pt', 'sv'],\r\n    french:    ['fr', 'tl'],\r\n    russian:   ['hr', 'ru'],\r\n    czech:     ['cs'],\r\n    polish:    ['pl'],\r\n    icelandic: ['is']\r\n  };\r\n\r\n  function langToTypeMap(mapping) {\r\n    var type, langs, l, ret = {};\r\n    for (type in mapping) {\r\n      if (mapping.hasOwnProperty(type)) {\r\n        langs = mapping[type];\r\n        for (l in langs) {\r\n          ret[langs[l]] = type;\r\n        }\r\n      }\r\n    }\r\n    return ret;\r\n  }\r\n\r\n    // Trim a string.\r\n  function trim(str){\r\n    var trimRe = /^\\s+|\\s+$/g;\r\n    return str.replace(trimRe, '');\r\n  }\r\n\r\n  // Based on a phrase text that contains `n` plural forms separated\r\n  // by `delimeter`, a `locale`, and a `count`, choose the correct\r\n  // plural form, or none if `count` is `null`.\r\n  function choosePluralForm(text, locale, count){\r\n    var ret, texts, chosenText;\r\n    if (count != null && text) {\r\n      texts = text.split(delimeter);\r\n      chosenText = texts[pluralTypeIndex(locale, count)] || texts[0];\r\n      ret = trim(chosenText);\r\n    } else {\r\n      ret = text;\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  function pluralTypeName(locale) {\r\n    var langToPluralType = langToTypeMap(pluralTypeToLanguages);\r\n    return langToPluralType[locale] || langToPluralType.en;\r\n  }\r\n\r\n  function pluralTypeIndex(locale, count) {\r\n    return pluralTypes[pluralTypeName(locale)](count);\r\n  }\r\n\r\n  // ### interpolate\r\n  //\r\n  // Does the dirty work. Creates a `RegExp` object for each\r\n  // interpolation placeholder.\r\n  function interpolate(phrase, options) {\r\n    for (var arg in options) {\r\n      if (arg !== '_' && options.hasOwnProperty(arg)) {\r\n        // We create a new `RegExp` each time instead of using a more-efficient\r\n        // string replace so that the same argument can be replaced multiple times\r\n        // in the same phrase.\r\n        phrase = phrase.replace(new RegExp('%\\\\{'+arg+'\\\\}', 'g'), options[arg]);\r\n      }\r\n    }\r\n    return phrase;\r\n  }\r\n\r\n  // ### warn\r\n  //\r\n  // Provides a warning in the console if a phrase key is missing.\r\n  function warn(message) {\r\n    root.console && root.console.warn && root.console.warn('WARNING: ' + message);\r\n  }\r\n\r\n  // ### clone\r\n  //\r\n  // Clone an object.\r\n  function clone(source) {\r\n    var ret = {};\r\n    for (var prop in source) {\r\n      ret[prop] = source[prop];\r\n    }\r\n    return ret;\r\n  }\r\n\r\n\r\n  // Export for Node, attach to `window` for browser.\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = Polyglot;\r\n  } else {\r\n    root.Polyglot = Polyglot;\r\n  }\r\n\r\n}(this);\r\n\r\n","!function(e){if(\"object\"==typeof exports)module.exports=e();else if(\"function\"==typeof define&&define.amd)define(e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.PouchDB=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\r\n\"use strict\";\r\n\r\nvar utils = _dereq_('./utils');\r\nvar merge = _dereq_('./merge');\r\nvar errors = _dereq_('./deps/errors');\r\nvar EventEmitter = _dereq_('events').EventEmitter;\r\n\r\n/*\r\n * A generic pouch adapter\r\n */\r\n\r\n// returns first element of arr satisfying callback predicate\r\nfunction arrayFirst(arr, callback) {\r\n  for (var i = 0; i < arr.length; i++) {\r\n    if (callback(arr[i], i) === true) {\r\n      return arr[i];\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n// Wrapper for functions that call the bulkdocs api with a single doc,\r\n// if the first result is an error, return an error\r\nfunction yankError(callback) {\r\n  return function (err, results) {\r\n    if (err || results[0].error) {\r\n      callback(err || results[0]);\r\n    } else {\r\n      callback(null, results[0]);\r\n    }\r\n  };\r\n}\r\n\r\n// for every node in a revision tree computes its distance from the closest\r\n// leaf\r\nfunction computeHeight(revs) {\r\n  var height = {};\r\n  var edges = [];\r\n  merge.traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\r\n    var rev = pos + \"-\" + id;\r\n    if (isLeaf) {\r\n      height[rev] = 0;\r\n    }\r\n    if (prnt !== undefined) {\r\n      edges.push({from: prnt, to: rev});\r\n    }\r\n    return rev;\r\n  });\r\n\r\n  edges.reverse();\r\n  edges.forEach(function (edge) {\r\n    if (height[edge.from] === undefined) {\r\n      height[edge.from] = 1 + height[edge.to];\r\n    } else {\r\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\r\n    }\r\n  });\r\n  return height;\r\n}\r\n\r\nutils.inherits(AbstractPouchDB, EventEmitter);\r\nmodule.exports = AbstractPouchDB;\r\n\r\nfunction AbstractPouchDB() {\r\n  var self = this;\r\n  EventEmitter.call(this);\r\n  self.autoCompact = function (callback) {\r\n    if (!self.auto_compaction) {\r\n      return callback;\r\n    }\r\n    return function (err, res) {\r\n      if (err) {\r\n        callback(err);\r\n      } else {\r\n        var count = res.length;\r\n        var decCount = function () {\r\n          count--;\r\n          if (!count) {\r\n            callback(null, res);\r\n          }\r\n        };\r\n        res.forEach(function (doc) {\r\n          if (doc.ok) {\r\n            // TODO: we need better error handling\r\n            self.compactDocument(doc.id, 1, decCount);\r\n          } else {\r\n            decCount();\r\n          }\r\n        });\r\n      }\r\n    };\r\n  };\r\n\r\n  var listeners = 0, changes;\r\n  var eventNames = ['change', 'delete', 'create', 'update'];\r\n  this.on('newListener', function (eventName) {\r\n    if (~eventNames.indexOf(eventName)) {\r\n      if (listeners) {\r\n        listeners++;\r\n        return;\r\n      } else {\r\n        listeners++;\r\n      }\r\n    } else {\r\n      return;\r\n    }\r\n    var lastChange = 0;\r\n    changes = this.changes({\r\n      conflicts: true,\r\n      include_docs: true,\r\n      continuous: true,\r\n      since: 'latest',\r\n      onChange: function (change) {\r\n        if (change.seq <= lastChange) {\r\n          return;\r\n        }\r\n        lastChange = change.seq;\r\n        self.emit('change', change);\r\n        if (change.doc._deleted) {\r\n          self.emit('delete', change);\r\n        } else if (change.doc._rev.split('-')[0] === '1') {\r\n          self.emit('create', change);\r\n        } else {\r\n          self.emit('update', change);\r\n        }\r\n      }\r\n    });\r\n  });\r\n  this.on('removeListener', function (eventName) {\r\n    if (~eventNames.indexOf(eventName)) {\r\n      listeners--;\r\n      if (listeners) {\r\n        return;\r\n      }\r\n    } else {\r\n      return;\r\n    }\r\n    changes.cancel();\r\n  });\r\n}\r\n\r\nAbstractPouchDB.prototype.post = utils.adapterFun('post', function (doc, opts, callback) {\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\r\n    return callback(errors.NOT_AN_OBJECT);\r\n  }\r\n  return this.bulkDocs({docs: [doc]}, opts,\r\n      this.autoCompact(yankError(callback)));\r\n});\r\n\r\nAbstractPouchDB.prototype.put = utils.adapterFun('put', utils.getArguments(function (args) {\r\n  var temp, temptype, opts, callback;\r\n  var doc = args.shift();\r\n  var id = '_id' in doc;\r\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\r\n    callback = args.pop();\r\n    return callback(errors.NOT_AN_OBJECT);\r\n  }\r\n  doc = utils.extend(true, {}, doc);\r\n  while (true) {\r\n    temp = args.shift();\r\n    temptype = typeof temp;\r\n    if (temptype === \"string\" && !id) {\r\n      doc._id = temp;\r\n      id = true;\r\n    } else if (temptype === \"string\" && id && !('_rev' in doc)) {\r\n      doc._rev = temp;\r\n    } else if (temptype === \"object\") {\r\n      opts = temp;\r\n    } else if (temptype === \"function\") {\r\n      callback = temp;\r\n    }\r\n    if (!args.length) {\r\n      break;\r\n    }\r\n  }\r\n  opts = opts || {};\r\n  var error = utils.invalidIdError(doc._id);\r\n  if (error) {\r\n    return callback(error);\r\n  }\r\n  return this.bulkDocs({docs: [doc]}, opts,\r\n      this.autoCompact(yankError(callback)));\r\n}));\r\n\r\nAbstractPouchDB.prototype.putAttachment = utils.adapterFun('putAttachment', function (docId, attachmentId, rev, blob, type, callback) {\r\n  var api = this;\r\n  if (typeof type === 'function') {\r\n    callback = type;\r\n    type = blob;\r\n    blob = rev;\r\n    rev = null;\r\n  }\r\n  if (typeof type === 'undefined') {\r\n    type = blob;\r\n    blob = rev;\r\n    rev = null;\r\n  }\r\n\r\n  function createAttachment(doc) {\r\n    doc._attachments = doc._attachments || {};\r\n    doc._attachments[attachmentId] = {\r\n      content_type: type,\r\n      data: blob\r\n    };\r\n    api.put(doc, callback);\r\n  }\r\n\r\n  api.get(docId, function (err, doc) {\r\n    // create new doc\r\n    if (err && err.error === errors.MISSING_DOC.error) {\r\n      createAttachment({_id: docId});\r\n      return;\r\n    }\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    if (doc._rev !== rev) {\r\n      callback(errors.REV_CONFLICT);\r\n      return;\r\n    }\r\n\r\n    createAttachment(doc);\r\n  });\r\n});\r\n\r\nAbstractPouchDB.prototype.removeAttachment = utils.adapterFun('removeAttachment', function (docId, attachmentId, rev, callback) {\r\n  var self = this;\r\n  self.get(docId, function (err, obj) {\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n    if (obj._rev !== rev) {\r\n      callback(errors.REV_CONFLICT);\r\n      return;\r\n    }\r\n    if (!obj._attachments) {\r\n      return callback();\r\n    }\r\n    delete obj._attachments[attachmentId];\r\n    if (Object.keys(obj._attachments).length === 0) {\r\n      delete obj._attachments;\r\n    }\r\n    self.put(obj, callback);\r\n  });\r\n});\r\n\r\nAbstractPouchDB.prototype.remove = utils.adapterFun('remove', function (doc, opts, callback) {\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  if (opts === undefined) {\r\n    opts = {};\r\n  }\r\n  opts = utils.extend(true, {}, opts);\r\n  opts.was_delete = true;\r\n  var newDoc = {_id: doc._id, _rev: doc._rev};\r\n  newDoc._deleted = true;\r\n  return this.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\r\n});\r\n\r\nAbstractPouchDB.prototype.revsDiff = utils.adapterFun('revsDiff', function (req, opts, callback) {\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  opts = utils.extend(true, {}, opts);\r\n  var ids = Object.keys(req);\r\n  var count = 0;\r\n  var missing = {};\r\n\r\n  function addToMissing(id, revId) {\r\n    if (!missing[id]) {\r\n      missing[id] = {missing: []};\r\n    }\r\n    missing[id].missing.push(revId);\r\n  }\r\n\r\n  function processDoc(id, rev_tree) {\r\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\r\n    var missingForId = req[id].slice(0);\r\n    merge.traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\r\n      opts) {\r\n        var rev = pos + '-' + revHash;\r\n        var idx = missingForId.indexOf(rev);\r\n        if (idx === -1) {\r\n          return;\r\n        }\r\n\r\n        missingForId.splice(idx, 1);\r\n        if (opts.status !== 'available') {\r\n          addToMissing(id, rev);\r\n        }\r\n      });\r\n\r\n    // Traversing the tree is synchronous, so now `missingForId` contains\r\n    // revisions that were not found in the tree\r\n    missingForId.forEach(function (rev) {\r\n      addToMissing(id, rev);\r\n    });\r\n  }\r\n\r\n  ids.map(function (id) {\r\n    this._getRevisionTree(id, function (err, rev_tree) {\r\n      if (err && err.name === 'not_found' && err.message === 'missing') {\r\n        missing[id] = {missing: req[id]};\r\n      } else if (err) {\r\n        return callback(err);\r\n      } else {\r\n        processDoc(id, rev_tree);\r\n      }\r\n\r\n      if (++count === ids.length) {\r\n        return callback(null, missing);\r\n      }\r\n    });\r\n  }, this);\r\n});\r\n\r\n// compact one document and fire callback\r\n// by compacting we mean removing all revisions which\r\n// are further from the leaf in revision tree than max_height\r\nAbstractPouchDB.prototype.compactDocument = function (docId, max_height, callback) {\r\n  var self = this;\r\n  this._getRevisionTree(docId, function (err, rev_tree) {\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n    var height = computeHeight(rev_tree);\r\n    var candidates = [];\r\n    var revs = [];\r\n    Object.keys(height).forEach(function (rev) {\r\n      if (height[rev] > max_height) {\r\n        candidates.push(rev);\r\n      }\r\n    });\r\n\r\n    merge.traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx, opts) {\r\n      var rev = pos + '-' + revHash;\r\n      if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\r\n        opts.status = 'missing';\r\n        revs.push(rev);\r\n      }\r\n    });\r\n    self._doCompaction(docId, rev_tree, revs, callback);\r\n  });\r\n};\r\n\r\n// compact the whole database using single document\r\n// compaction\r\nAbstractPouchDB.prototype.compact = utils.adapterFun('compact', function (opts, callback) {\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  var self = this;\r\n  this.changes({complete: function (err, res) {\r\n    if (err) {\r\n      callback(); // TODO: silently fail\r\n      return;\r\n    }\r\n    var count = res.results.length;\r\n    if (!count) {\r\n      callback();\r\n      return;\r\n    }\r\n    res.results.forEach(function (row) {\r\n      self.compactDocument(row.id, 0, function () {\r\n        count--;\r\n        if (!count) {\r\n          callback();\r\n        }\r\n      });\r\n    });\r\n  }});\r\n});\r\n\r\n/* Begin api wrappers. Specific functionality to storage belongs in the _[method] */\r\nAbstractPouchDB.prototype.get = utils.adapterFun('get', function (id, opts, callback) {\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  if (typeof id !== 'string') {\r\n    return callback(errors.INVALID_ID);\r\n  }\r\n  var leaves = [], self = this;\r\n  function finishOpenRevs() {\r\n    var result = [];\r\n    var count = leaves.length;\r\n    if (!count) {\r\n      return callback(null, result);\r\n    }\r\n    // order with open_revs is unspecified\r\n    leaves.forEach(function (leaf) {\r\n      self.get(id, {rev: leaf, revs: opts.revs, attachments: opts.attachments}, function (err, doc) {\r\n        if (!err) {\r\n          result.push({ok: doc});\r\n        } else {\r\n          result.push({missing: leaf});\r\n        }\r\n        count--;\r\n        if (!count) {\r\n          callback(null, result);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  if (opts.open_revs) {\r\n    if (opts.open_revs === \"all\") {\r\n      this._getRevisionTree(id, function (err, rev_tree) {\r\n        if (err) {\r\n          // if there's no such document we should treat this\r\n          // situation the same way as if revision tree was empty\r\n          rev_tree = [];\r\n        }\r\n        leaves = merge.collectLeaves(rev_tree).map(function (leaf) {\r\n          return leaf.rev;\r\n        });\r\n        finishOpenRevs();\r\n      });\r\n    } else {\r\n      if (Array.isArray(opts.open_revs)) {\r\n        leaves = opts.open_revs;\r\n        for (var i = 0; i < leaves.length; i++) {\r\n          var l = leaves[i];\r\n          // looks like it's the only thing couchdb checks\r\n          if (!(typeof(l) === \"string\" && /^\\d+-/.test(l))) {\r\n            return callback(errors.error(errors.BAD_REQUEST,\r\n              \"Invalid rev format\"));\r\n          }\r\n        }\r\n        finishOpenRevs();\r\n      } else {\r\n        return callback(errors.error(errors.UNKNOWN_ERROR,\r\n          'function_clause'));\r\n      }\r\n    }\r\n    return; // open_revs does not like other options\r\n  }\r\n\r\n  return this._get(id, opts, function (err, result) {\r\n    opts = utils.extend(true, {}, opts);\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n\r\n    var doc = result.doc;\r\n    var metadata = result.metadata;\r\n    var ctx = result.ctx;\r\n\r\n    if (opts.conflicts) {\r\n      var conflicts = merge.collectConflicts(metadata);\r\n      if (conflicts.length) {\r\n        doc._conflicts = conflicts;\r\n      }\r\n    }\r\n\r\n    if (opts.revs || opts.revs_info) {\r\n      var paths = merge.rootToLeaf(metadata.rev_tree);\r\n      var path = arrayFirst(paths, function (arr) {\r\n        return arr.ids.map(function (x) { return x.id; })\r\n          .indexOf(doc._rev.split('-')[1]) !== -1;\r\n      });\r\n\r\n      path.ids.splice(path.ids.map(function (x) {return x.id; })\r\n                      .indexOf(doc._rev.split('-')[1]) + 1);\r\n      path.ids.reverse();\r\n\r\n      if (opts.revs) {\r\n        doc._revisions = {\r\n          start: (path.pos + path.ids.length) - 1,\r\n          ids: path.ids.map(function (rev) {\r\n            return rev.id;\r\n          })\r\n        };\r\n      }\r\n      if (opts.revs_info) {\r\n        var pos =  path.pos + path.ids.length;\r\n        doc._revs_info = path.ids.map(function (rev) {\r\n          pos--;\r\n          return {\r\n            rev: pos + '-' + rev.id,\r\n            status: rev.opts.status\r\n          };\r\n        });\r\n      }\r\n    }\r\n\r\n    if (opts.local_seq) {\r\n      doc._local_seq = result.metadata.seq;\r\n    }\r\n\r\n    if (opts.attachments && doc._attachments) {\r\n      var attachments = doc._attachments;\r\n      var count = Object.keys(attachments).length;\r\n      if (count === 0) {\r\n        return callback(null, doc);\r\n      }\r\n      Object.keys(attachments).forEach(function (key) {\r\n        this._getAttachment(attachments[key], {encode: true, ctx: ctx}, function (err, data) {\r\n          doc._attachments[key].data = data;\r\n          if (!--count) {\r\n            callback(null, doc);\r\n          }\r\n        });\r\n      }, self);\r\n    } else {\r\n      if (doc._attachments) {\r\n        for (var key in doc._attachments) {\r\n          if (doc._attachments.hasOwnProperty(key)) {\r\n            doc._attachments[key].stub = true;\r\n          }\r\n        }\r\n      }\r\n      callback(null, doc);\r\n    }\r\n  });\r\n});\r\n\r\nAbstractPouchDB.prototype.getAttachment = utils.adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\r\n  var self = this;\r\n  if (opts instanceof Function) {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  opts = utils.extend(true, {}, opts);\r\n  this._get(docId, opts, function (err, res) {\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\r\n      opts.ctx = res.ctx;\r\n      self._getAttachment(res.doc._attachments[attachmentId], opts, callback);\r\n    } else {\r\n      return callback(errors.MISSING_DOC);\r\n    }\r\n  });\r\n});\r\n\r\nAbstractPouchDB.prototype.allDocs = utils.adapterFun('allDocs', function (opts, callback) {\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  opts = utils.extend(true, {}, opts);\r\n  if ('keys' in opts) {\r\n    var incompatibleOpt = ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\r\n      return incompatibleOpt in opts;\r\n    })[0];\r\n    if (incompatibleOpt) {\r\n      callback(errors.error(errors.QUERY_PARSE_ERROR,\r\n        'Query parameter `' + incompatibleOpt + '` is not compatible with multi-get'\r\n      ));\r\n      return;\r\n    }\r\n  }\r\n  if (typeof opts.skip === 'undefined') {\r\n    opts.skip = 0;\r\n  }\r\n\r\n  return this._allDocs(opts, callback);\r\n});\r\n\r\nfunction processChange(doc, metadata, opts) {\r\n  var changeList = [{rev: doc._rev}];\r\n  if (opts.style === 'all_docs') {\r\n    changeList = merge.collectLeaves(metadata.rev_tree)\r\n    .map(function (x) { return {rev: x.rev}; });\r\n  }\r\n  var change = {\r\n    id: metadata.id,\r\n    changes: changeList,\r\n    doc: doc\r\n  };\r\n\r\n  if (utils.isDeleted(metadata, doc._rev)) {\r\n    change.deleted = true;\r\n  }\r\n  if (opts.conflicts) {\r\n    change.doc._conflicts = merge.collectConflicts(metadata);\r\n    if (!change.doc._conflicts.length) {\r\n      delete change.doc._conflicts;\r\n    }\r\n  }\r\n  return change;\r\n}\r\n\r\nfunction doChanges(api, opts, promise) {\r\n\r\n  var callback = opts.complete;\r\n\r\n  opts = utils.extend(true, {}, opts);\r\n  if ('live' in opts && !('continuous' in opts)) {\r\n    opts.continuous = opts.live;\r\n  }\r\n  opts.processChange = processChange;\r\n\r\n  if (!opts.since) {\r\n    opts.since = 0;\r\n  }\r\n  if (opts.since === 'latest') {\r\n    api.info(function (err, info) {\r\n      if (promise.isCancelled) {\r\n        callback(null, {status: 'cancelled'});\r\n        return;\r\n      }\r\n      if (err) {\r\n        callback(err);\r\n        return;\r\n      }\r\n      opts.since = info.update_seq  - 1;\r\n      doChanges(api, opts, promise, callback);\r\n    });\r\n    return;\r\n  }\r\n\r\n  if (api.type() !== 'http' && opts.filter && typeof opts.filter === 'string') {\r\n    if (opts.filter === '_view') {\r\n      if (opts.view && typeof opts.view === 'string') {\r\n        // fetch a view from a design doc, make it behave like a filter\r\n        var viewName = opts.view.split('/');\r\n        api.get('_design/' + viewName[0], function (err, ddoc) {\r\n          if (promise.isCancelled) {\r\n            callback(null, {status: 'cancelled'});\r\n            return;\r\n          }\r\n          if (err) {\r\n            callback(err);\r\n            return;\r\n          }\r\n          if (ddoc && ddoc.views && ddoc.views[viewName[1]]) {\r\n            /*jshint evil: true */\r\n            var filter = eval('(function () {' +\r\n                              '  return function (doc) {' +\r\n                              '    var emitted = false;' +\r\n                              '    var emit = function (a, b) {' +\r\n                              '      emitted = true;' +\r\n                              '    };' +\r\n                              '    var view = ' + ddoc.views[viewName[1]].map + ';' +\r\n                              '    view(doc);' +\r\n                              '    if (emitted) {' +\r\n                              '      return true;' +\r\n                              '    }' +\r\n                              '  }' +\r\n                              '})()');\r\n            opts.filter = filter;\r\n            doChanges(api, opts, promise, callback);\r\n            return;\r\n          } else {\r\n            var msg = ddoc.views ? 'missing json key: ' + viewName[1] :\r\n              'missing json key: views';\r\n            err = err || errors.error(errors.MISSING_DOC, msg);\r\n            callback(err);\r\n            return;\r\n          }\r\n        });\r\n      } else {\r\n        var err = errors.error(errors.BAD_REQUEST,\r\n                              '`view` filter parameter is not provided.');\r\n        callback(err);\r\n        return;\r\n      }\r\n    } else {\r\n      // fetch a filter from a design doc\r\n      var filterName = opts.filter.split('/');\r\n      api.get('_design/' + filterName[0], function (err, ddoc) {\r\n        if (promise.isCancelled) {\r\n          callback(null, {status: 'cancelled'});\r\n          return;\r\n        }\r\n        if (err) {\r\n          callback(err);\r\n          return;\r\n        }\r\n        if (ddoc && ddoc.filters && ddoc.filters[filterName[1]]) {\r\n          /*jshint evil: true */\r\n          var filter = eval('(function () { return ' +\r\n                            ddoc.filters[filterName[1]] + ' })()');\r\n          opts.filter = filter;\r\n          doChanges(api, opts, promise, callback);\r\n          return;\r\n        } else {\r\n          var msg = (ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\r\n            : 'missing json key: filters';\r\n          err = err || errors.error(errors.MISSING_DOC, msg);\r\n          callback(err);\r\n          return;\r\n        }\r\n      });\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (!('descending' in opts)) {\r\n    opts.descending = false;\r\n  }\r\n\r\n  // 0 and 1 should return 1 document\r\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\r\n  opts.complete = callback;\r\n  var newPromise = api._changes(opts);\r\n  if (newPromise && typeof newPromise.cancel === 'function') {\r\n    var cancel = promise.cancel;\r\n    promise.cancel = utils.getArguments(function (args) {\r\n      newPromise.cancel();\r\n      cancel.apply(this, args);\r\n    });\r\n  }\r\n}\r\n\r\nAbstractPouchDB.prototype.changes = function (opts) {\r\n  return utils.cancellableFun(doChanges, this, opts);\r\n};\r\n\r\nAbstractPouchDB.prototype.close = utils.adapterFun('close', function (callback) {\r\n  return this._close(callback);\r\n});\r\n\r\nAbstractPouchDB.prototype.info = utils.adapterFun('info', function (callback) {\r\n  var self = this;\r\n  this._info(function (err, info) {\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n    var len = self.prefix.length;\r\n    if (info.db_name.length > len && info.db_name.slice(0, len) === self.prefix) {\r\n      info.db_name = info.db_name.slice(len);\r\n    }\r\n    callback(null, info);\r\n  });\r\n});\r\n\r\nAbstractPouchDB.prototype.id = utils.adapterFun('id', function (callback) {\r\n  return this._id(callback);\r\n});\r\n\r\nAbstractPouchDB.prototype.type = function () {\r\n  return (typeof this._type === 'function') ? this._type() : this.adapter;\r\n};\r\n\r\nAbstractPouchDB.prototype.bulkDocs = utils.adapterFun('bulkDocs', function (req, opts, callback) {\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  if (!opts) {\r\n    opts = {};\r\n  } else {\r\n    opts = utils.extend(true, {}, opts);\r\n  }\r\n\r\n  if (!req || !req.docs) {\r\n    return callback(errors.MISSING_BULK_DOCS);\r\n  }\r\n\r\n  if (!Array.isArray(req.docs)) {\r\n    return callback(errors.QUERY_PARSE_ERROR);\r\n  }\r\n\r\n  for (var i = 0; i < req.docs.length; ++i) {\r\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\r\n      return callback(errors.NOT_AN_OBJECT);\r\n    }\r\n  }\r\n\r\n  req = utils.extend(true, {}, req);\r\n  if (!('new_edits' in opts)) {\r\n    if ('new_edits' in req) {\r\n      opts.new_edits = req.new_edits;\r\n    } else {\r\n      opts.new_edits = true;\r\n    }\r\n  }\r\n\r\n  return this._bulkDocs(req, opts, this.autoCompact(callback));\r\n});\r\n\r\n},{\"./deps/errors\":8,\"./merge\":14,\"./utils\":18,\"events\":22}],2:[function(_dereq_,module,exports){\r\n\"use strict\";\r\n\r\nvar utils = _dereq_('../utils');\r\nvar errors = _dereq_('../deps/errors');\r\n// parseUri 1.2.2\r\n// (c) Steven Levithan <stevenlevithan.com>\r\n// MIT License\r\nfunction parseUri(str) {\r\n  var o = parseUri.options;\r\n  var m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str);\r\n  var uri = {};\r\n  var i = 14;\r\n\r\n  while (i--) {\r\n    uri[o.key[i]] = m[i] || \"\";\r\n  }\r\n\r\n  uri[o.q.name] = {};\r\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\r\n    if ($1) {\r\n      uri[o.q.name][$1] = $2;\r\n    }\r\n  });\r\n\r\n  return uri;\r\n}\r\n\r\nfunction encodeDocId(id) {\r\n  if (/^_(design|local)/.test(id)) {\r\n    return id;\r\n  }\r\n  return encodeURIComponent(id);\r\n}\r\n\r\nparseUri.options = {\r\n  strictMode: false,\r\n  key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\",\r\n        \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\r\n  q:   {\r\n    name:   \"queryKey\",\r\n    parser: /(?:^|&)([^&=]*)=?([^&]*)/g\r\n  },\r\n  parser: {\r\n    strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\r\n    loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\r\n  }\r\n};\r\n\r\n// Get all the information you possibly can about the URI given by name and\r\n// return it as a suitable object.\r\nfunction getHost(name, opts) {\r\n  // If the given name contains \"http:\"\r\n  if (/http(s?):/.test(name)) {\r\n    // Prase the URI into all its little bits\r\n    var uri = parseUri(name);\r\n\r\n    // Store the fact that it is a remote URI\r\n    uri.remote = true;\r\n\r\n    // Store the user and password as a separate auth object\r\n    if (uri.user || uri.password) {\r\n      uri.auth = {username: uri.user, password: uri.password};\r\n    }\r\n\r\n    // Split the path part of the URI into parts using '/' as the delimiter\r\n    // after removing any leading '/' and any trailing '/'\r\n    var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\r\n\r\n    // Store the first part as the database name and remove it from the parts\r\n    // array\r\n    uri.db = parts.pop();\r\n\r\n    // Restore the path by joining all the remaining parts (all the parts\r\n    // except for the database name) with '/'s\r\n    uri.path = parts.join('/');\r\n    opts = opts || {};\r\n    opts = utils.extend(true, {}, opts);\r\n    uri.headers = opts.headers || {};\r\n\r\n    if (opts.auth || uri.auth) {\r\n      var nAuth = opts.auth || uri.auth;\r\n      var token = utils.btoa(nAuth.username + ':' + nAuth.password);\r\n      uri.headers.Authorization = 'Basic ' + token;\r\n    }\r\n\r\n    if (opts.headers) {\r\n      uri.headers = opts.headers;\r\n    }\r\n\r\n    return uri;\r\n  }\r\n\r\n  // If the given name does not contain 'http:' then return a very basic object\r\n  // with no host, the current path, the given name as the database name and no\r\n  // username/password\r\n  return {host: '', path: '/', db: name, auth: false};\r\n}\r\n\r\n// Generate a URL with the host data given by opts and the given path\r\nfunction genDBUrl(opts, path) {\r\n  return genUrl(opts, opts.db + '/' + path);\r\n}\r\n\r\n// Generate a URL with the host data given by opts and the given path\r\nfunction genUrl(opts, path) {\r\n  if (opts.remote) {\r\n    // If the host already has a path, then we need to have a path delimiter\r\n    // Otherwise, the path delimiter is the empty string\r\n    var pathDel = !opts.path ? '' : '/';\r\n\r\n    // If the host already has a path, then we need to have a path delimiter\r\n    // Otherwise, the path delimiter is the empty string\r\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' + opts.path + pathDel + path;\r\n  }\r\n\r\n  return '/' + path;\r\n}\r\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\r\nfunction HttpPouch(opts, callback) {\r\n  // The functions that will be publicly available for HttpPouch\r\n  var api = this;\r\n  api.getHost = opts.getHost ? opts.getHost : getHost;\r\n\r\n  // Parse the URI given by opts.name into an easy-to-use object\r\n  var host = api.getHost(opts.name, opts);\r\n\r\n  // Generate the database URL based on the host\r\n  var dbUrl = genDBUrl(host, '');\r\n\r\n  api.getUrl = function () {return dbUrl; };\r\n\r\n  var ajaxOpts = opts.ajax || {};\r\n  opts = utils.extend(true, {}, opts);\r\n  function ajax(options, callback) {\r\n    return utils.ajax(utils.extend({}, ajaxOpts, options), callback);\r\n  }\r\n  var uuids = {\r\n    list: [],\r\n    get: function (opts, callback) {\r\n      if (typeof opts === 'function') {\r\n        callback = opts;\r\n        opts = {count: 10};\r\n      }\r\n      var cb = function (err, body) {\r\n        if (err || !('uuids' in body)) {\r\n          callback(err || errors.UNKNOWN_ERROR);\r\n        } else {\r\n          uuids.list = uuids.list.concat(body.uuids);\r\n          callback(null, \"OK\");\r\n        }\r\n      };\r\n      var params = '?count=' + opts.count;\r\n      ajax({\r\n        headers: host.headers,\r\n        method: 'GET',\r\n        url: genUrl(host, '_uuids') + params\r\n      }, cb);\r\n    }\r\n  };\r\n\r\n  // Create a new CouchDB database based on the given opts\r\n  var createDB = function () {\r\n    ajax({headers: host.headers, method: 'PUT', url: dbUrl}, function (err, ret) {\r\n      // If we get an \"Unauthorized\" error\r\n      if (err && err.status === 401) {\r\n        // Test if the database already exists\r\n        ajax({headers: host.headers, method: 'HEAD', url: dbUrl}, function (err, ret) {\r\n          // If there is still an error\r\n          if (err) {\r\n            // Give the error to the callback to deal with\r\n            callback(err);\r\n          } else {\r\n            // Continue as if there had been no errors\r\n            callback(null, api);\r\n          }\r\n        });\r\n        // If there were no errros or if the only error is \"Precondition Failed\"\r\n        // (note: \"Precondition Failed\" occurs when we try to create a database\r\n        // that already exists)\r\n      } else if (!err || err.status === 412) {\r\n        // Continue as if there had been no errors\r\n        callback(null, api);\r\n      } else {\r\n        callback(err);\r\n      }\r\n    });\r\n  };\r\n  if (!opts.skipSetup) {\r\n    ajax({headers: host.headers, method: 'GET', url: dbUrl}, function (err, ret) {\r\n      //check if the db exists\r\n      if (err) {\r\n        if (err.status === 404) {\r\n          //if it doesn't, create it\r\n          createDB();\r\n        } else {\r\n          callback(err);\r\n        }\r\n      } else {\r\n        //go do stuff with the db\r\n        callback(null, api);\r\n      }\r\n    });\r\n  }\r\n\r\n  api.type = function () {\r\n    return 'http';\r\n  };\r\n\r\n  api.id = utils.adapterFun('id', function (callback) {\r\n    ajax({\r\n      headers: host.headers,\r\n      method: 'GET',\r\n      url: genUrl(host, '')\r\n    }, function (err, result) {\r\n      if (err) {\r\n        callback(err);\r\n      } else {\r\n        var uuid = (result && result.uuid) ?\r\n          result.uuid + host.db : genDBUrl(host, '');\r\n        callback(null, uuid);\r\n      }\r\n    });\r\n  });\r\n\r\n  api.request = utils.adapterFun('request', function (options, callback) {\r\n    options.headers = host.headers;\r\n    options.url = genDBUrl(host, options.url);\r\n    ajax(options, callback);\r\n  });\r\n\r\n  // Sends a POST request to the host calling the couchdb _compact function\r\n  //    version: The version of CouchDB it is running\r\n  api.compact = utils.adapterFun('compact', function (opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    opts = utils.extend(true, {}, opts);\r\n    ajax({\r\n      headers: host.headers,\r\n      url: genDBUrl(host, '_compact'),\r\n      method: 'POST'\r\n    }, function () {\r\n      function ping() {\r\n        api.info(function (err, res) {\r\n          if (!res.compact_running) {\r\n            callback();\r\n          } else {\r\n            setTimeout(ping, opts.interval || 200);\r\n          }\r\n        });\r\n      }\r\n      // Ping the http if it's finished compaction\r\n      if (typeof callback === \"function\") {\r\n        ping();\r\n      }\r\n    });\r\n  });\r\n\r\n  // Calls GET on the host, which gets back a JSON string containing\r\n  //    couchdb: A welcome string\r\n  //    version: The version of CouchDB it is running\r\n  api._info = function (callback) {\r\n    ajax({\r\n      headers: host.headers,\r\n      method: 'GET',\r\n      url: genDBUrl(host, '')\r\n    }, function (err, res) {\r\n      if (err) {\r\n        callback(err);\r\n      } else {\r\n        res.host = genDBUrl(host, '');\r\n        callback(null, res);\r\n      }\r\n    });\r\n  };\r\n\r\n  // Get the document with the given id from the database given by host.\r\n  // The id could be solely the _id in the database, or it may be a\r\n  // _design/ID or _local/ID path\r\n  api.get = utils.adapterFun('get', function (id, opts, callback) {\r\n    // If no options were given, set the callback to the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    opts = utils.extend(true, {}, opts);\r\n    if (opts.auto_encode === undefined) {\r\n      opts.auto_encode = true;\r\n    }\r\n\r\n    // List of parameters to add to the GET request\r\n    var params = [];\r\n\r\n    // If it exists, add the opts.revs value to the list of parameters.\r\n    // If revs=true then the resulting JSON will include a field\r\n    // _revisions containing an array of the revision IDs.\r\n    if (opts.revs) {\r\n      params.push('revs=true');\r\n    }\r\n\r\n    // If it exists, add the opts.revs_info value to the list of parameters.\r\n    // If revs_info=true then the resulting JSON will include the field\r\n    // _revs_info containing an array of objects in which each object\r\n    // representing an available revision.\r\n    if (opts.revs_info) {\r\n      params.push('revs_info=true');\r\n    }\r\n\r\n    if (opts.local_seq) {\r\n      params.push('local_seq=true');\r\n    }\r\n    // If it exists, add the opts.open_revs value to the list of parameters.\r\n    // If open_revs=all then the resulting JSON will include all the leaf\r\n    // revisions. If open_revs=[\"rev1\", \"rev2\",...] then the resulting JSON\r\n    // will contain an array of objects containing data of all revisions\r\n    if (opts.open_revs) {\r\n      if (opts.open_revs !== \"all\") {\r\n        opts.open_revs = JSON.stringify(opts.open_revs);\r\n      }\r\n      params.push('open_revs=' + opts.open_revs);\r\n    }\r\n\r\n    // If it exists, add the opts.attachments value to the list of parameters.\r\n    // If attachments=true the resulting JSON will include the base64-encoded\r\n    // contents in the \"data\" property of each attachment.\r\n    if (opts.attachments) {\r\n      params.push('attachments=true');\r\n    }\r\n\r\n    // If it exists, add the opts.rev value to the list of parameters.\r\n    // If rev is given a revision number then get the specified revision.\r\n    if (opts.rev) {\r\n      params.push('rev=' + opts.rev);\r\n    }\r\n\r\n    // If it exists, add the opts.conflicts value to the list of parameters.\r\n    // If conflicts=true then the resulting JSON will include the field\r\n    // _conflicts containing all the conflicting revisions.\r\n    if (opts.conflicts) {\r\n      params.push('conflicts=' + opts.conflicts);\r\n    }\r\n\r\n    // Format the list of parameters into a valid URI query string\r\n    params = params.join('&');\r\n    params = params === '' ? '' : '?' + params;\r\n\r\n    if (opts.auto_encode) {\r\n      id = encodeDocId(id);\r\n    }\r\n\r\n    // Set the options for the ajax call\r\n    var options = {\r\n      headers: host.headers,\r\n      method: 'GET',\r\n      url: genDBUrl(host, id + params)\r\n    };\r\n\r\n    // If the given id contains at least one '/' and the part before the '/'\r\n    // is NOT \"_design\" and is NOT \"_local\"\r\n    // OR\r\n    // If the given id contains at least two '/' and the part before the first\r\n    // '/' is \"_design\".\r\n    // TODO This second condition seems strange since if parts[0] === '_design'\r\n    // then we already know that parts[0] !== '_local'.\r\n    var parts = id.split('/');\r\n    if ((parts.length > 1 && parts[0] !== '_design' && parts[0] !== '_local') ||\r\n        (parts.length > 2 && parts[0] === '_design' && parts[0] !== '_local')) {\r\n      // Binary is expected back from the server\r\n      options.binary = true;\r\n    }\r\n\r\n    // Get the document\r\n    ajax(options, function (err, doc, xhr) {\r\n      // If the document does not exist, send an error to the callback\r\n      if (err) {\r\n        return callback(err);\r\n      }\r\n\r\n      // Send the document to the callback\r\n      callback(null, doc, xhr);\r\n    });\r\n  });\r\n\r\n  // Delete the document given by doc from the database given by host.\r\n  api.remove = utils.adapterFun('remove', function (doc, opts, callback) {\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    // Delete the document\r\n    ajax({\r\n      headers: host.headers,\r\n      method: 'DELETE',\r\n      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + doc._rev\r\n    }, callback);\r\n  });\r\n\r\n  // Get the attachment\r\n  api.getAttachment = utils.adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    opts = utils.extend(true, {}, opts);\r\n    if (opts.auto_encode === undefined) {\r\n      opts.auto_encode = true;\r\n    }\r\n    if (opts.auto_encode) {\r\n      docId = encodeDocId(docId);\r\n    }\r\n    opts.auto_encode = false;\r\n    api.get(docId + '/' + attachmentId, opts, callback);\r\n  });\r\n\r\n  // Remove the attachment given by the id and rev\r\n  api.removeAttachment = utils.adapterFun('removeAttachment', function (docId, attachmentId, rev, callback) {\r\n    ajax({\r\n      headers: host.headers,\r\n      method: 'DELETE',\r\n      url: genDBUrl(host, encodeDocId(docId) + '/' + attachmentId) + '?rev=' + rev\r\n    }, callback);\r\n  });\r\n\r\n  // Add the attachment given by blob and its contentType property\r\n  // to the document with the given id, the revision given by rev, and\r\n  // add it to the database given by host.\r\n  api.putAttachment = utils.adapterFun('putAttachment', function (docId, attachmentId, rev, blob, type, callback) {\r\n    if (typeof type === 'function') {\r\n      callback = type;\r\n      type = blob;\r\n      blob = rev;\r\n      rev = null;\r\n    }\r\n    if (typeof type === 'undefined') {\r\n      type = blob;\r\n      blob = rev;\r\n      rev = null;\r\n    }\r\n    var id = encodeDocId(docId) + '/' + attachmentId;\r\n    var url = genDBUrl(host, id);\r\n    if (rev) {\r\n      url += '?rev=' + rev;\r\n    }\r\n\r\n    var opts = {\r\n      headers: host.headers,\r\n      method: 'PUT',\r\n      url: url,\r\n      processData: false,\r\n      body: blob,\r\n      timeout: 60000\r\n    };\r\n    opts.headers['Content-Type'] = type;\r\n    // Add the attachment\r\n    ajax(opts, callback);\r\n  });\r\n\r\n  // Add the document given by doc (in JSON string format) to the database\r\n  // given by host. This fails if the doc has no _id field.\r\n  api.put = utils.adapterFun('put', utils.getArguments(function (args) {\r\n    var temp, temptype, opts, callback;\r\n    var doc = args.shift();\r\n    var id = '_id' in doc;\r\n    if (typeof doc !== 'object' || Array.isArray(doc)) {\r\n      callback = args.pop();\r\n      return callback(errors.NOT_AN_OBJECT);\r\n    }\r\n    doc = utils.extend(true, {}, doc);\r\n    while (true) {\r\n      temp = args.shift();\r\n      temptype = typeof temp;\r\n      if (temptype === \"string\" && !id) {\r\n        doc._id = temp;\r\n        id = true;\r\n      } else if (temptype === \"string\" && id && !('_rev' in doc)) {\r\n        doc._rev = temp;\r\n      } else if (temptype === \"object\") {\r\n        opts = utils.extend(true, {}, temp);\r\n      } else if (temptype === \"function\") {\r\n        callback = temp;\r\n      }\r\n      if (!args.length) {\r\n        break;\r\n      }\r\n    }\r\n    opts = opts || {};\r\n    var error = utils.invalidIdError(doc._id);\r\n    if (error) {\r\n      return callback(error);\r\n    }\r\n\r\n    // List of parameter to add to the PUT request\r\n    var params = [];\r\n\r\n    // If it exists, add the opts.new_edits value to the list of parameters.\r\n    // If new_edits = false then the database will NOT assign this document a\r\n    // new revision number\r\n    if (opts && typeof opts.new_edits !== 'undefined') {\r\n      params.push('new_edits=' + opts.new_edits);\r\n    }\r\n\r\n    // Format the list of parameters into a valid URI query string\r\n    params = params.join('&');\r\n    if (params !== '') {\r\n      params = '?' + params;\r\n    }\r\n\r\n    // Add the document\r\n    ajax({\r\n      headers: host.headers,\r\n      method: 'PUT',\r\n      url: genDBUrl(host, encodeDocId(doc._id)) + params,\r\n      body: doc\r\n    }, callback);\r\n  }));\r\n\r\n  // Add the document given by doc (in JSON string format) to the database\r\n  // given by host. This does not assume that doc is a new document (i.e. does not\r\n  // have a _id or a _rev field.\r\n  api.post = utils.adapterFun('post', function (doc, opts, callback) {\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    opts = utils.extend(true, {}, opts);\r\n    if (typeof doc !== 'object') {\r\n      return callback(errors.NOT_AN_OBJECT);\r\n    }\r\n    if (! (\"_id\" in doc)) {\r\n      if (uuids.list.length > 0) {\r\n        doc._id = uuids.list.pop();\r\n        api.put(doc, opts, callback);\r\n      } else {\r\n        uuids.get(function (err, resp) {\r\n          if (err) {\r\n            return callback(errors.UNKNOWN_ERROR);\r\n          }\r\n          doc._id = uuids.list.pop();\r\n          api.put(doc, opts, callback);\r\n        });\r\n      }\r\n    } else {\r\n      api.put(doc, opts, callback);\r\n    }\r\n  });\r\n\r\n  // Update/create multiple documents given by req in the database\r\n  // given by host.\r\n  api.bulkDocs = utils.adapterFun('bulkDocs', function (req, opts, callback) {\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    if (!opts) {\r\n      opts = {};\r\n    }\r\n    if (!Array.isArray(req.docs)) {\r\n      return callback(errors.error(errors.NOT_AN_OBJECT, \"Missing JSON list of 'docs'\"));\r\n    }\r\n    var bad = req.docs.filter(function (doc) {\r\n      return typeof doc !== 'object' || Array.isArray(doc);\r\n    });\r\n    if (bad.length) {\r\n      return callback(errors.NOT_AN_OBJECT);\r\n    }\r\n    req = utils.extend(true, {}, req);\r\n    opts = utils.extend(true, {}, opts);\r\n    // If opts.new_edits exists add it to the document data to be\r\n    // send to the database.\r\n    // If new_edits=false then it prevents the database from creating\r\n    // new revision numbers for the documents. Instead it just uses\r\n    // the old ones. This is used in database replication.\r\n    if (typeof opts.new_edits !== 'undefined') {\r\n      req.new_edits = opts.new_edits;\r\n    }\r\n\r\n    // Update/create the documents\r\n    ajax({\r\n      headers: host.headers,\r\n      method: 'POST',\r\n      url: genDBUrl(host, '_bulk_docs'),\r\n      body: req\r\n    }, callback);\r\n  });\r\n\r\n  // Get a listing of the documents in the database given\r\n  // by host and ordered by increasing id.\r\n  api.allDocs = utils.adapterFun('allDocs', function (opts, callback) {\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n    opts = utils.extend(true, {}, opts);\r\n    // List of parameters to add to the GET request\r\n    var params = [];\r\n    var body;\r\n    var method = 'GET';\r\n\r\n    // TODO I don't see conflicts as a valid parameter for a\r\n    // _all_docs request (see http://wiki.apache.org/couchdb/HTTP_Document_API#all_docs)\r\n    if (opts.conflicts) {\r\n      params.push('conflicts=true');\r\n    }\r\n\r\n    // If opts.descending is truthy add it to params\r\n    if (opts.descending) {\r\n      params.push('descending=true');\r\n    }\r\n\r\n    // If opts.include_docs exists, add the include_docs value to the\r\n    // list of parameters.\r\n    // If include_docs=true then include the associated document with each\r\n    // result.\r\n    if (opts.include_docs) {\r\n      params.push('include_docs=true');\r\n    }\r\n\r\n    if (opts.key) {\r\n      params.push('key=' + encodeURIComponent(JSON.stringify(opts.key)));\r\n    }\r\n\r\n    // If opts.startkey exists, add the startkey value to the list of\r\n    // parameters.\r\n    // If startkey is given then the returned list of documents will\r\n    // start with the document whose id is startkey.\r\n    if (opts.startkey) {\r\n      params.push('startkey=' +\r\n        encodeURIComponent(JSON.stringify(opts.startkey)));\r\n    }\r\n\r\n    // If opts.endkey exists, add the endkey value to the list of parameters.\r\n    // If endkey is given then the returned list of docuemnts will\r\n    // end with the document whose id is endkey.\r\n    if (opts.endkey) {\r\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\r\n    }\r\n\r\n    // If opts.limit exists, add the limit value to the parameter list.\r\n    if (typeof opts.limit !== 'undefined') {\r\n      params.push('limit=' + opts.limit);\r\n    }\r\n\r\n    if (typeof opts.skip !== 'undefined') {\r\n      params.push('skip=' + opts.skip);\r\n    }\r\n\r\n    // Format the list of parameters into a valid URI query string\r\n    params = params.join('&');\r\n    if (params !== '') {\r\n      params = '?' + params;\r\n    }\r\n\r\n    if (typeof opts.keys !== 'undefined') {\r\n\r\n      var MAX_URL_LENGTH = 2000;\r\n      // according to http://stackoverflow.com/a/417184/680742,\r\n      // the de factor URL length limit is 2000 characters\r\n\r\n      var keysAsString = 'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\r\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\r\n        // If the keys are short enough, do a GET. we do this to work around\r\n        // Safari not understanding 304s on POSTs (see issue #1239)\r\n        params += (params.indexOf('?') !== -1 ? '&' : '?') + keysAsString;\r\n      } else {\r\n        // If keys are too long, issue a POST request to circumvent GET query string limits\r\n        // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\r\n        method = 'POST';\r\n        body = JSON.stringify({keys: opts.keys});\r\n      }\r\n    }\r\n\r\n    // Get the document listing\r\n    ajax({\r\n      headers: host.headers,\r\n      method: method,\r\n      url: genDBUrl(host, '_all_docs' + params),\r\n      body: body\r\n    }, callback);\r\n  });\r\n\r\n  // Get a list of changes made to documents in the database given by host.\r\n  // TODO According to the README, there should be two other methods here,\r\n  // api.changes.addListener and api.changes.removeListener.\r\n  api._changes = function (opts) {\r\n    // We internally page the results of a changes request, this means\r\n    // if there is a large set of changes to be returned we can start\r\n    // processing them quicker instead of waiting on the entire\r\n    // set of changes to return and attempting to process them at once\r\n    var CHANGES_LIMIT = 25;\r\n\r\n    opts = utils.extend(true, {}, opts);\r\n    opts.timeout = opts.timeout || 0;\r\n\r\n    // set timeout to 20s to prevent aborting via Ajax timeout\r\n    var params = { timeout: 20 * 1000 };\r\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\r\n    if (limit === 0) {\r\n      limit = 1;\r\n    }\r\n    //\r\n    var leftToFetch = limit;\r\n\r\n    if (opts.style) {\r\n      params.style = opts.style;\r\n    }\r\n\r\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\r\n      params.include_docs = true;\r\n    }\r\n\r\n    if (opts.continuous) {\r\n      params.feed = 'longpoll';\r\n    }\r\n\r\n    if (opts.conflicts) {\r\n      params.conflicts = true;\r\n    }\r\n\r\n    if (opts.descending) {\r\n      params.descending = true;\r\n    }\r\n\r\n    if (opts.filter && typeof opts.filter === 'string') {\r\n      params.filter = opts.filter;\r\n      if (opts.filter === '_view' && opts.view && typeof opts.view === 'string') {\r\n        params.view = opts.view;\r\n      }\r\n    }\r\n\r\n    // If opts.query_params exists, pass it through to the changes request.\r\n    // These parameters may be used by the filter on the source database.\r\n    if (opts.query_params && typeof opts.query_params === 'object') {\r\n      for (var param_name in opts.query_params) {\r\n        if (opts.query_params.hasOwnProperty(param_name)) {\r\n          params[param_name] = opts.query_params[param_name];\r\n        }\r\n      }\r\n    }\r\n\r\n    var xhr;\r\n    var lastFetchedSeq;\r\n\r\n    // Get all the changes starting wtih the one immediately after the\r\n    // sequence number given by since.\r\n    var fetch = function (since, callback) {\r\n      if (opts.aborted) {\r\n        return;\r\n      }\r\n      params.since = since;\r\n      if (opts.descending) {\r\n        if (limit) {\r\n          params.limit = leftToFetch;\r\n        }\r\n      } else {\r\n        params.limit = (!limit || leftToFetch > CHANGES_LIMIT) ?\r\n          CHANGES_LIMIT : leftToFetch;\r\n      }\r\n\r\n      var paramStr = '?' + Object.keys(params).map(function (k) {\r\n        return k + '=' + params[k];\r\n      }).join('&');\r\n\r\n      // Set the options for the ajax call\r\n      var xhrOpts = {\r\n        headers: host.headers,\r\n        method: 'GET',\r\n        url: genDBUrl(host, '_changes' + paramStr),\r\n        // _changes can take a long time to generate, especially when filtered\r\n        timeout: opts.timeout\r\n      };\r\n      lastFetchedSeq = since;\r\n\r\n      if (opts.aborted) {\r\n        return;\r\n      }\r\n\r\n      // Get the changes\r\n      xhr = ajax(xhrOpts, callback);\r\n    };\r\n\r\n    // If opts.since exists, get all the changes from the sequence\r\n    // number given by opts.since. Otherwise, get all the changes\r\n    // from the sequence number 0.\r\n    var fetchTimeout = 10;\r\n    var fetchRetryCount = 0;\r\n\r\n    var results = {results: []};\r\n\r\n    var fetched = function (err, res) {\r\n      if (opts.aborted) {\r\n        return;\r\n      }\r\n      var raw_results_length = 0;\r\n      // If the result of the ajax call (res) contains changes (res.results)\r\n      if (res && res.results) {\r\n        raw_results_length = res.results.length;\r\n        results.last_seq = res.last_seq;\r\n        // For each change\r\n        var req = {};\r\n        req.query = opts.query_params;\r\n        res.results = res.results.filter(function (c) {\r\n          leftToFetch--;\r\n          var ret = utils.filterChange(opts)(c);\r\n          if (ret) {\r\n            results.results.push(c);\r\n            utils.call(opts.onChange, c);\r\n          }\r\n          return ret;\r\n        });\r\n      } else if (err) {\r\n        // In case of an error, stop listening for changes and call opts.complete\r\n        opts.aborted = true;\r\n        utils.call(opts.complete, err);\r\n        return;\r\n      }\r\n\r\n      // The changes feed may have timed out with no results\r\n      // if so reuse last update sequence\r\n      if (res && res.last_seq) {\r\n        lastFetchedSeq = res.last_seq;\r\n      }\r\n\r\n      var finished = (limit && leftToFetch <= 0) ||\r\n        (res && raw_results_length < CHANGES_LIMIT) ||\r\n        (opts.descending);\r\n\r\n      if (opts.continuous || !finished) {\r\n        // Increase retry delay exponentially as long as errors persist\r\n        if (err) {\r\n          fetchRetryCount += 1;\r\n        } else {\r\n          fetchRetryCount = 0;\r\n        }\r\n        var timeoutMultiplier = 1 << fetchRetryCount;\r\n        var retryWait = fetchTimeout * timeoutMultiplier;\r\n        var maximumWait = opts.maximumWait || 30000;\r\n\r\n        if (retryWait > maximumWait) {\r\n          utils.call(opts.complete, err || errors.UNKNOWN_ERROR);\r\n          return;\r\n        }\r\n\r\n        // Queue a call to fetch again with the newest sequence number\r\n        setTimeout(function () { fetch(lastFetchedSeq, fetched); }, retryWait);\r\n      } else {\r\n        // We're done, call the callback\r\n        utils.call(opts.complete, null, results);\r\n      }\r\n    };\r\n\r\n    fetch(opts.since || 0, fetched);\r\n\r\n    // Return a method to cancel this method from processing any more\r\n    return {\r\n      cancel: function () {\r\n        opts.aborted = true;\r\n        xhr.abort();\r\n      }\r\n    };\r\n  };\r\n\r\n  // Given a set of document/revision IDs (given by req), tets the subset of\r\n  // those that do NOT correspond to revisions stored in the database.\r\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\r\n  api.revsDiff = utils.adapterFun('revsDif', function (req, opts, callback) {\r\n    // If no options were given, set the callback to be the second parameter\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n      opts = {};\r\n    }\r\n\r\n    // Get the missing document/revision IDs\r\n    ajax({\r\n      headers: host.headers,\r\n      method: 'POST',\r\n      url: genDBUrl(host, '_revs_diff'),\r\n      body: req\r\n    }, function (err, res) {\r\n      callback(err, res);\r\n    });\r\n  });\r\n\r\n  api.close = utils.adapterFun('close', function (callback) {\r\n    callback();\r\n  });\r\n\r\n  function replicateOnServer(target, opts, promise, targetHostUrl) {\r\n    opts = utils.extend(true, {}, opts);\r\n    var targetHost = api.getHost(targetHostUrl);\r\n    var params = {\r\n      source: host.db,\r\n      target: targetHost.protocol === host.protocol &&\r\n        targetHost.authority === host.authority ? targetHost.db : targetHost.source\r\n    };\r\n\r\n    if (opts.continuous) {\r\n      params.continuous = true;\r\n    }\r\n\r\n    if (opts.create_target) {\r\n      params.create_target = true;\r\n    }\r\n\r\n    if (opts.doc_ids) {\r\n      params.doc_ids = opts.doc_ids;\r\n    }\r\n\r\n    if (opts.filter && typeof opts.filter === 'string') {\r\n      params.filter = opts.filter;\r\n    }\r\n\r\n    if (opts.query_params) {\r\n      params.query_params = opts.query_params;\r\n    }\r\n\r\n    var result = {};\r\n    var repOpts = {\r\n      headers: host.headers,\r\n      method: 'POST',\r\n      url: genUrl(host, '_replicate'),\r\n      body: params\r\n    };\r\n\r\n    var xhr;\r\n    promise.cancel = function () {\r\n      this.cancelled = true;\r\n      if (xhr && !result.ok) {\r\n        xhr.abort();\r\n      }\r\n      if (result._local_id) {\r\n        repOpts.body = {\r\n          replication_id: result._local_id\r\n        };\r\n      }\r\n      repOpts.body.cancel = true;\r\n      ajax(repOpts, function (err, resp, xhr) {\r\n        // If the replication cancel request fails, send an error to the callback\r\n        if (err) {\r\n          return callback(err);\r\n        }\r\n        // Send the replication cancel result to the complete callback\r\n        utils.call(opts.complete, null, result, xhr);\r\n      });\r\n    };\r\n\r\n    if (promise.cancelled) {\r\n      return;\r\n    }\r\n\r\n    xhr = ajax(repOpts, function (err, resp, xhr) {\r\n      // If the replication fails, send an error to the callback\r\n      if (err) {\r\n        return callback(err);\r\n      }\r\n\r\n      result.ok = true;\r\n\r\n      // Provided by CouchDB from 1.2.0 onward to cancel replication\r\n      if (resp._local_id) {\r\n        result._local_id = resp._local_id;\r\n      }\r\n\r\n      // Send the replication result to the complete callback\r\n      utils.call(opts.complete, null, resp, xhr);\r\n    });\r\n  }\r\n\r\n  api.replicateOnServer = function (target, opts, promise) {\r\n    if (!api.taskqueue.isReady) {\r\n      api.taskqueue.addTask('replicateOnServer', [target, opts, promise]);\r\n      return promise;\r\n    }\r\n    target.info(function (err, info) {\r\n      replicateOnServer(target, opts, promise, info.host);\r\n    });\r\n  };\r\n  api.destroy = utils.adapterFun('destroy', function (callback) {\r\n    ajax({\r\n      url: genDBUrl(host, ''),\r\n      method: 'DELETE',\r\n      headers: host.headers\r\n    }, function (err, resp) {\r\n      if (err) {\r\n        api.emit('error', err);\r\n        callback(err);\r\n      } else {\r\n        api.emit('destroyed');\r\n        callback(null, resp);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n// Delete the HttpPouch specified by the given name.\r\nHttpPouch.destroy = utils.toPromise(function (name, opts, callback) {\r\n  var host = getHost(name, opts);\r\n  opts = opts || {};\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  opts = utils.extend(true, {}, opts);\r\n  opts.headers = host.headers;\r\n  opts.method = 'DELETE';\r\n  opts.url = genDBUrl(host, '');\r\n  var ajaxOpts = opts.ajax || {};\r\n  opts = utils.extend({}, opts, ajaxOpts);\r\n  utils.ajax(opts, callback);\r\n});\r\n\r\n// HttpPouch is a valid adapter.\r\nHttpPouch.valid = function () {\r\n  return true;\r\n};\r\n\r\nmodule.exports = HttpPouch;\r\n\r\n},{\"../deps/errors\":8,\"../utils\":18}],3:[function(_dereq_,module,exports){\r\n(function (global){\r\n'use strict';\r\n\r\nvar utils = _dereq_('../utils');\r\nvar merge = _dereq_('../merge');\r\nvar errors = _dereq_('../deps/errors');\r\n\r\nfunction idbError(callback) {\r\n  return function (event) {\r\n    callback(errors.error(errors.IDB_ERROR, event.target, event.type));\r\n  };\r\n}\r\n\r\nfunction isModernIdb() {\r\n  // check for outdated implementations of IDB\r\n  // that rely on the setVersion method instead of onupgradeneeded (issue #1207)\r\n\r\n  // cache based on appVersion, in case the browser is updated\r\n  var cacheKey = \"_pouch__checkModernIdb_\" +\r\n    (global.navigator && global.navigator.appVersion);\r\n  var cached = utils.hasLocalStorage() && global.localStorage[cacheKey];\r\n  if (cached) {\r\n    return JSON.parse(cached);\r\n  }\r\n\r\n  var dbName = '_pouch__checkModernIdb';\r\n  var result = global.indexedDB.open(dbName, 1).onupgradeneeded === null;\r\n\r\n  if (global.indexedDB.deleteDatabase) {\r\n    global.indexedDB.deleteDatabase(dbName); // db no longer needed\r\n  }\r\n  if (utils.hasLocalStorage()) {\r\n    global.localStorage[cacheKey] = JSON.stringify(result); // cache\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction IdbPouch(opts, callback) {\r\n\r\n  // IndexedDB requires a versioned database structure, so we use the\r\n  // version here to manage migrations.\r\n  var ADAPTER_VERSION = 2;\r\n\r\n  // The object stores created for each database\r\n  // DOC_STORE stores the document meta data, its revision history and state\r\n  var DOC_STORE = 'document-store';\r\n  // BY_SEQ_STORE stores a particular version of a document, keyed by its\r\n  // sequence id\r\n  var BY_SEQ_STORE = 'by-sequence';\r\n  // Where we store attachments\r\n  var ATTACH_STORE = 'attach-store';\r\n  // Where we store meta data\r\n  var META_STORE = 'meta-store';\r\n  // Where we detect blob support\r\n  var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\r\n\r\n  var name = opts.name;\r\n  var req = global.indexedDB.open(name, ADAPTER_VERSION);\r\n\r\n  if (!('openReqList' in IdbPouch)) {\r\n    IdbPouch.openReqList = {};\r\n  }\r\n  IdbPouch.openReqList[name] = req;\r\n\r\n  var blobSupport = null;\r\n  var instanceId = null;\r\n  var api = this;\r\n  var idb = null;\r\n\r\n  req.onupgradeneeded = function (e) {\r\n    var db = e.target.result;\r\n    if (e.oldVersion < 1) {\r\n      // initial schema\r\n      createSchema(db);\r\n    }\r\n    if (e.oldVersion < 2) {\r\n      // version 2 adds the deletedOrLocal index\r\n      addDeletedOrLocalIndex(e);\r\n    }\r\n  };\r\n\r\n  function createSchema(db) {\r\n    db.createObjectStore(DOC_STORE, {keyPath : 'id'})\r\n      .createIndex('seq', 'seq', {unique: true});\r\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\r\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\r\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\r\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\r\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\r\n  }\r\n\r\n  function addDeletedOrLocalIndex(e) {\r\n    var docStore = e.currentTarget.transaction.objectStore(DOC_STORE);\r\n\r\n    docStore.openCursor().onsuccess = function (event) {\r\n      var cursor = event.target.result;\r\n      if (cursor) {\r\n        var metadata = cursor.value;\r\n        var deleted = utils.isDeleted(metadata);\r\n        var local = utils.isLocalId(metadata.id);\r\n        metadata.deletedOrLocal = (deleted || local) ? \"1\" : \"0\";\r\n        docStore.put(metadata);\r\n        cursor['continue']();\r\n      } else {\r\n        docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\r\n      }\r\n    };\r\n  }\r\n\r\n  req.onsuccess = function (e) {\r\n\r\n    idb = e.target.result;\r\n\r\n    idb.onversionchange = function () {\r\n      idb.close();\r\n    };\r\n\r\n    var txn = idb.transaction([META_STORE, DETECT_BLOB_SUPPORT_STORE],\r\n                              'readwrite');\r\n\r\n    var req = txn.objectStore(META_STORE).get(META_STORE);\r\n\r\n    req.onsuccess = function (e) {\r\n\r\n      var idStored = false;\r\n      var checkSetupComplete = function () {\r\n        if (blobSupport === null || !idStored) {\r\n          return;\r\n        } else {\r\n          callback(null, api);\r\n        }\r\n      };\r\n\r\n      var meta = e.target.result || {id: META_STORE};\r\n      if (name  + '_id' in meta) {\r\n        instanceId = meta[name + '_id'];\r\n        idStored = true;\r\n        checkSetupComplete();\r\n      } else {\r\n        instanceId = utils.uuid();\r\n        meta[name + '_id'] = instanceId;\r\n        txn.objectStore(META_STORE).put(meta).onsuccess = function () {\r\n          idStored = true;\r\n          checkSetupComplete();\r\n        };\r\n      }\r\n\r\n      // detect blob support\r\n      try {\r\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(utils.createBlob(), \"key\");\r\n        blobSupport = true;\r\n      } catch (err) {\r\n        blobSupport = false;\r\n      } finally {\r\n        checkSetupComplete();\r\n      }\r\n    };\r\n  };\r\n\r\n  req.onerror = idbError(callback);\r\n\r\n  api.type = function () {\r\n    return 'idb';\r\n  };\r\n\r\n  api._id = utils.toPromise(function (callback) {\r\n    callback(null, instanceId);\r\n  });\r\n\r\n  api._bulkDocs = function idb_bulkDocs(req, opts, callback) {\r\n    var newEdits = opts.new_edits;\r\n    var userDocs = req.docs;\r\n    // Parse the docs, give them a sequence number for the result\r\n    var docInfos = userDocs.map(function (doc, i) {\r\n      var newDoc = utils.parseDoc(doc, newEdits);\r\n      newDoc._bulk_seq = i;\r\n      return newDoc;\r\n    });\r\n\r\n    var docInfoErrors = docInfos.filter(function (docInfo) {\r\n      return docInfo.error;\r\n    });\r\n    if (docInfoErrors.length) {\r\n      return callback(docInfoErrors[0]);\r\n    }\r\n\r\n    var results = [];\r\n    var docsWritten = 0;\r\n\r\n    function writeMetaData(e) {\r\n      var meta = e.target.result;\r\n      meta.updateSeq = (meta.updateSeq || 0) + docsWritten;\r\n      txn.objectStore(META_STORE).put(meta);\r\n    }\r\n\r\n    function processDocs() {\r\n      if (!docInfos.length) {\r\n        txn.objectStore(META_STORE).get(META_STORE).onsuccess = writeMetaData;\r\n        return;\r\n      }\r\n      var currentDoc = docInfos.shift();\r\n      var req = txn.objectStore(DOC_STORE).get(currentDoc.metadata.id);\r\n      req.onsuccess = function process_docRead(event) {\r\n        var oldDoc = event.target.result;\r\n        if (!oldDoc) {\r\n          insertDoc(currentDoc);\r\n        } else {\r\n          updateDoc(oldDoc, currentDoc);\r\n        }\r\n      };\r\n    }\r\n\r\n    function complete(event) {\r\n      var aresults = [];\r\n      results.sort(sortByBulkSeq);\r\n      results.forEach(function (result) {\r\n        delete result._bulk_seq;\r\n        if (result.error) {\r\n          aresults.push(result);\r\n          return;\r\n        }\r\n        var metadata = result.metadata;\r\n        var rev = merge.winningRev(metadata);\r\n\r\n        aresults.push({\r\n          ok: true,\r\n          id: metadata.id,\r\n          rev: rev\r\n        });\r\n\r\n        if (utils.isLocalId(metadata.id)) {\r\n          return;\r\n        }\r\n\r\n        IdbPouch.Changes.notify(name);\r\n        IdbPouch.Changes.notifyLocalWindows(name);\r\n      });\r\n      callback(null, aresults);\r\n    }\r\n\r\n    function preprocessAttachment(att, finish) {\r\n      if (att.stub) {\r\n        return finish();\r\n      }\r\n      if (typeof att.data === 'string') {\r\n        var data;\r\n        try {\r\n          data = atob(att.data);\r\n        } catch (e) {\r\n          var err = errors.error(errors.BAD_ARG,\r\n                                \"Attachments need to be base64 encoded\");\r\n          return callback(err);\r\n        }\r\n        att.digest = 'md5-' + utils.Crypto.MD5(data);\r\n        if (blobSupport) {\r\n          var type = att.content_type;\r\n          data = utils.fixBinary(data);\r\n          att.data = utils.createBlob([data], {type: type});\r\n        }\r\n        return finish();\r\n      }\r\n      var reader = new FileReader();\r\n      reader.onloadend = function (e) {\r\n        var binary = utils.arrayBufferToBinaryString(this.result);\r\n        att.digest = 'md5-' + utils.Crypto.MD5(binary);\r\n        if (!blobSupport) {\r\n          att.data = btoa(binary);\r\n        }\r\n        finish();\r\n      };\r\n      reader.readAsArrayBuffer(att.data);\r\n    }\r\n\r\n    function preprocessAttachments(callback) {\r\n      if (!docInfos.length) {\r\n        return callback();\r\n      }\r\n\r\n      var docv = 0;\r\n      docInfos.forEach(function (docInfo) {\r\n        var attachments = docInfo.data && docInfo.data._attachments ?\r\n          Object.keys(docInfo.data._attachments) : [];\r\n\r\n        if (!attachments.length) {\r\n          return done();\r\n        }\r\n\r\n        var recv = 0;\r\n        function attachmentProcessed() {\r\n          recv++;\r\n          if (recv === attachments.length) {\r\n            done();\r\n          }\r\n        }\r\n\r\n        for (var key in docInfo.data._attachments) {\r\n          if (docInfo.data._attachments.hasOwnProperty(key)) {\r\n            preprocessAttachment(docInfo.data._attachments[key], attachmentProcessed);\r\n          }\r\n        }\r\n      });\r\n\r\n      function done() {\r\n        docv++;\r\n        if (docInfos.length === docv) {\r\n          callback();\r\n        }\r\n      }\r\n    }\r\n\r\n    function writeDoc(docInfo, callback) {\r\n      var err = null;\r\n      var recv = 0;\r\n      docInfo.data._id = docInfo.metadata.id;\r\n      docInfo.data._rev = docInfo.metadata.rev;\r\n\r\n      docsWritten++;\r\n\r\n      if (utils.isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\r\n        docInfo.data._deleted = true;\r\n      }\r\n\r\n      var attachments = docInfo.data._attachments ?\r\n        Object.keys(docInfo.data._attachments) : [];\r\n\r\n      function collectResults(attachmentErr) {\r\n        if (!err) {\r\n          if (attachmentErr) {\r\n            err = attachmentErr;\r\n            callback(err);\r\n          } else if (recv === attachments.length) {\r\n            finish();\r\n          }\r\n        }\r\n      }\r\n\r\n      function attachmentSaved(err) {\r\n        recv++;\r\n        collectResults(err);\r\n      }\r\n\r\n      for (var key in docInfo.data._attachments) {\r\n        if (!docInfo.data._attachments[key].stub) {\r\n          var data = docInfo.data._attachments[key].data;\r\n          delete docInfo.data._attachments[key].data;\r\n          var digest = docInfo.data._attachments[key].digest;\r\n          saveAttachment(docInfo, digest, data, attachmentSaved);\r\n        } else {\r\n          recv++;\r\n          collectResults();\r\n        }\r\n      }\r\n\r\n      function finish() {\r\n\r\n        docInfo.data._doc_id_rev = docInfo.data._id + \"::\" + docInfo.data._rev;\r\n        var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\r\n\r\n        index.getKey(docInfo.data._doc_id_rev).onsuccess = function (e) {\r\n\r\n          var dataReq = e.target.result ?\r\n            txn.objectStore(BY_SEQ_STORE).put(docInfo.data, e.target.result) :\r\n            txn.objectStore(BY_SEQ_STORE).put(docInfo.data);\r\n\r\n          dataReq.onsuccess = function (e) {\r\n            docInfo.metadata.seq = e.target.result;\r\n            // Current _rev is calculated from _rev_tree on read\r\n            delete docInfo.metadata.rev;\r\n            var deleted = utils.isDeleted(docInfo.metadata);\r\n            var local = utils.isLocalId(docInfo.metadata.id);\r\n            var metadata = utils.extend(true, {\r\n              deletedOrLocal : (deleted || local) ? \"1\" : \"0\"\r\n            }, docInfo.metadata);\r\n            var metaDataReq = txn.objectStore(DOC_STORE).put(metadata);\r\n            metaDataReq.onsuccess = function () {\r\n              results.push(docInfo);\r\n              utils.call(callback);\r\n            };\r\n          };\r\n        };\r\n      }\r\n\r\n      if (!attachments.length) {\r\n        finish();\r\n      }\r\n    }\r\n\r\n    function updateDoc(oldDoc, docInfo) {\r\n      var merged = merge.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\r\n      var wasPreviouslyDeleted = utils.isDeleted(oldDoc);\r\n      var inConflict = (wasPreviouslyDeleted &&\r\n                        utils.isDeleted(docInfo.metadata)) ||\r\n        (!wasPreviouslyDeleted && newEdits && merged.conflicts !== 'new_leaf');\r\n\r\n      if (inConflict) {\r\n        results.push(makeErr(errors.REV_CONFLICT, docInfo._bulk_seq));\r\n        return processDocs();\r\n      }\r\n\r\n      docInfo.metadata.rev_tree = merged.tree;\r\n      writeDoc(docInfo, processDocs);\r\n    }\r\n\r\n    function insertDoc(docInfo) {\r\n      // Cant insert new deleted documents\r\n      if ('was_delete' in opts && utils.isDeleted(docInfo.metadata)) {\r\n        results.push(errors.MISSING_DOC);\r\n        return processDocs();\r\n      }\r\n      writeDoc(docInfo, processDocs);\r\n    }\r\n\r\n    // Insert sequence number into the error so we can sort later\r\n    function makeErr(err, seq) {\r\n      err._bulk_seq = seq;\r\n      return err;\r\n    }\r\n\r\n    function saveAttachment(docInfo, digest, data, callback) {\r\n      var objectStore = txn.objectStore(ATTACH_STORE);\r\n      objectStore.get(digest).onsuccess = function (e) {\r\n        var originalRefs = e.target.result && e.target.result.refs || {};\r\n        var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\r\n        var newAtt = {\r\n          digest: digest,\r\n          body: data,\r\n          refs: originalRefs\r\n        };\r\n        newAtt.refs[ref] = true;\r\n        objectStore.put(newAtt).onsuccess = function (e) {\r\n          utils.call(callback);\r\n        };\r\n      };\r\n    }\r\n\r\n    var txn;\r\n    preprocessAttachments(function () {\r\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, META_STORE],\r\n                            'readwrite');\r\n      txn.onerror = idbError(callback);\r\n      txn.ontimeout = idbError(callback);\r\n      txn.oncomplete = complete;\r\n\r\n      processDocs();\r\n    });\r\n  };\r\n\r\n  function sortByBulkSeq(a, b) {\r\n    return a._bulk_seq - b._bulk_seq;\r\n  }\r\n\r\n  // First we look up the metadata in the ids database, then we fetch the\r\n  // current revision(s) from the by sequence store\r\n  api._get = function idb_get(id, opts, callback) {\r\n    var doc;\r\n    var metadata;\r\n    var err;\r\n    var txn;\r\n    opts = utils.extend(true, {}, opts);\r\n    if (opts.ctx) {\r\n      txn = opts.ctx;\r\n    } else {\r\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\r\n    }\r\n\r\n    function finish() {\r\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\r\n    }\r\n\r\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\r\n      metadata = e.target.result;\r\n      // we can determine the result here if:\r\n      // 1. there is no such document\r\n      // 2. the document is deleted and we don't ask about specific rev\r\n      // When we ask with opts.rev we expect the answer to be either\r\n      // doc (possibly with _deleted=true) or missing error\r\n      if (!metadata) {\r\n        err = errors.MISSING_DOC;\r\n        return finish();\r\n      }\r\n      if (utils.isDeleted(metadata) && !opts.rev) {\r\n        err = errors.error(errors.MISSING_DOC, \"deleted\");\r\n        return finish();\r\n      }\r\n\r\n      var rev = merge.winningRev(metadata);\r\n      var key = metadata.id + '::' + (opts.rev ? opts.rev : rev);\r\n      var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\r\n\r\n      index.get(key).onsuccess = function (e) {\r\n        doc = e.target.result;\r\n        if (doc && doc._doc_id_rev) {\r\n          delete(doc._doc_id_rev);\r\n        }\r\n        if (!doc) {\r\n          err = errors.MISSING_DOC;\r\n          return finish();\r\n        }\r\n        finish();\r\n      };\r\n    };\r\n  };\r\n\r\n  api._getAttachment = function (attachment, opts, callback) {\r\n    var result;\r\n    var txn;\r\n    opts = utils.extend(true, {}, opts);\r\n    if (opts.ctx) {\r\n      txn = opts.ctx;\r\n    } else {\r\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\r\n    }\r\n    var digest = attachment.digest;\r\n    var type = attachment.content_type;\r\n\r\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\r\n      var data = e.target.result.body;\r\n      if (opts.encode) {\r\n        if (blobSupport) {\r\n          var reader = new FileReader();\r\n          reader.onloadend = function (e) {\r\n            var binary = utils.arrayBufferToBinaryString(this.result);\r\n            result = btoa(binary);\r\n            callback(null, result);\r\n          };\r\n          reader.readAsArrayBuffer(data);\r\n        } else {\r\n          result = data;\r\n          callback(null, result);\r\n        }\r\n      } else {\r\n        if (blobSupport) {\r\n          result = data;\r\n        } else {\r\n          data = utils.fixBinary(atob(data));\r\n          result = utils.createBlob([data], {type: type});\r\n        }\r\n        callback(null, result);\r\n      }\r\n    };\r\n  };\r\n\r\n  function allDocsKeysQuery(totalRows, opts, callback) {\r\n    var keys = opts.keys;\r\n    var descending = 'descending' in opts ? opts.descending : false;\r\n\r\n    if (!keys.length) { // empty list is okay\r\n      callback(null, {\r\n        offset : opts.skip,\r\n        rows : [],\r\n        total_rows : totalRows\r\n      });\r\n    } else {\r\n      // do a separate \"key\" query for each key in the keys array\r\n      var resultsToCollate = [];\r\n      keys.forEach(function (key) {\r\n        var subOpts = utils.extend(true, {}, opts);\r\n        subOpts.keys_request = true; // internal param, says this is a \"keys\" request\r\n        subOpts.key = key;\r\n        delete subOpts.keys;\r\n        delete subOpts.skip;\r\n        delete subOpts.limit;\r\n\r\n        allDocsNormalQuery(totalRows, subOpts, function (err, res) {\r\n          resultsToCollate.push({err : err, res : res, key : key});\r\n          if (resultsToCollate.length === keys.length) {\r\n            // all done, time to collate\r\n            var keysToResults = {};\r\n            for (var i = 0; i < resultsToCollate.length; i++) {\r\n              var result = resultsToCollate[i];\r\n              if (result.err) {\r\n                callback(err);\r\n                return;\r\n              } else {\r\n                keysToResults[result.key] = result;\r\n              }\r\n            }\r\n            var results = [];\r\n            keys.forEach(function (key) {\r\n              var result = keysToResults[key];\r\n              if (result.res.rows.length) {\r\n                results.push(result.res.rows[0]); // only one result ever\r\n              } else {\r\n                results.push({\"key\": key, \"error\": \"not_found\"});\r\n              }\r\n            });\r\n            if (descending) {\r\n              results = results.reverse();\r\n            }\r\n            callback(null, {\r\n              total_rows: totalRows,\r\n              offset: opts.skip,\r\n              rows: ('limit' in opts) ? results.slice(opts.skip, opts.limit + opts.skip) :\r\n                (opts.skip > 0) ? results.slice(opts.skip) : results\r\n            });\r\n          }\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  function allDocsNormalQuery(totalRows, opts, callback) {\r\n    var start = 'startkey' in opts ? opts.startkey : false;\r\n    var end = 'endkey' in opts ? opts.endkey : false;\r\n    var key = 'key' in opts ? opts.key : false;\r\n    var skip = opts.skip || 0;\r\n    var limit = typeof opts.limit === 'number' ? opts.limit : -1;\r\n\r\n    var descending = 'descending' in opts && opts.descending ? 'prev' : null;\r\n\r\n    var manualDescEnd = false;\r\n    if (descending && start && end) {\r\n      // unfortunately IDB has a quirk where IDBKeyRange.bound is invalid if the\r\n      // start is less than the end, even in descending mode.  Best bet\r\n      // is just to handle it manually in that case.\r\n      manualDescEnd = end;\r\n      end = false;\r\n    }\r\n\r\n    var keyRange;\r\n    try {\r\n      keyRange = start && end ? global.IDBKeyRange.bound(start, end)\r\n        : start ? (descending ? global.IDBKeyRange.upperBound(start) : global.IDBKeyRange.lowerBound(start))\r\n        : end ? (descending ? global.IDBKeyRange.lowerBound(end) : global.IDBKeyRange.upperBound(end))\r\n        : key ? global.IDBKeyRange.only(key) : null;\r\n    } catch (e) {\r\n      if (e.name === \"DataError\" && e.code === 0) {\r\n        // data error, start is less than end\r\n        return callback(null, {\r\n          total_rows : totalRows,\r\n          offset : opts.skip,\r\n          rows : []\r\n        });\r\n      } else {\r\n        return callback(errors.error(errors.IDB_ERROR, e.name, e.message));\r\n      }\r\n    }\r\n\r\n    var transaction = idb.transaction([DOC_STORE, BY_SEQ_STORE], 'readonly');\r\n    transaction.oncomplete = function () {\r\n      callback(null, {\r\n        total_rows: totalRows,\r\n        offset: opts.skip,\r\n        rows: results\r\n      });\r\n    };\r\n\r\n    var oStore = transaction.objectStore(DOC_STORE);\r\n    var oCursor = descending ? oStore.openCursor(keyRange, descending)\r\n      : oStore.openCursor(keyRange);\r\n    var results = [];\r\n    oCursor.onsuccess = function (e) {\r\n      if (!e.target.result) {\r\n        return;\r\n      }\r\n      var cursor = e.target.result;\r\n      var metadata = cursor.value;\r\n\r\n      function allDocsInner(metadata, data) {\r\n        if (utils.isLocalId(metadata.id)) {\r\n          return cursor['continue']();\r\n        }\r\n        var doc = {\r\n          id: metadata.id,\r\n          key: metadata.id,\r\n          value: {\r\n            rev: merge.winningRev(metadata)\r\n          }\r\n        };\r\n        if (opts.include_docs) {\r\n          doc.doc = data;\r\n          doc.doc._rev = merge.winningRev(metadata);\r\n          if (doc.doc._doc_id_rev) {\r\n            delete(doc.doc._doc_id_rev);\r\n          }\r\n          if (opts.conflicts) {\r\n            doc.doc._conflicts = merge.collectConflicts(metadata);\r\n          }\r\n          for (var att in doc.doc._attachments) {\r\n            if (doc.doc._attachments.hasOwnProperty(att)) {\r\n              doc.doc._attachments[att].stub = true;\r\n            }\r\n          }\r\n        }\r\n        if (opts.keys_request) {\r\n          // deleted docs are okay with keys_requests\r\n          if (utils.isDeleted(metadata)) {\r\n            doc.value.deleted = true;\r\n            doc.doc = null;\r\n          }\r\n          results.push(doc);\r\n        } else if (!utils.isDeleted(metadata) && skip-- <= 0) {\r\n          if (manualDescEnd && doc.key < manualDescEnd) {\r\n            return;\r\n          }\r\n          results.push(doc);\r\n          if (--limit === 0) {\r\n            return;\r\n          }\r\n        }\r\n        cursor['continue']();\r\n      }\r\n\r\n      if (!opts.include_docs) {\r\n        allDocsInner(metadata);\r\n      } else {\r\n        var index = transaction.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\r\n        var mainRev = merge.winningRev(metadata);\r\n        var key = metadata.id + \"::\" + mainRev;\r\n        index.get(key).onsuccess = function (event) {\r\n          allDocsInner(cursor.value, event.target.result);\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  api._allDocs = function idb_allDocs(opts, callback) {\r\n\r\n    // first count the total_rows using the undeleted/non-local count\r\n    var txn = idb.transaction([DOC_STORE], 'readonly');\r\n\r\n    var totalRows;\r\n    function countUndeletedNonlocalDocs(e) {\r\n      totalRows = e.target.result;\r\n    }\r\n\r\n    var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\r\n    index.count(global.IDBKeyRange.only(\"0\")).onsuccess = countUndeletedNonlocalDocs;\r\n\r\n    txn.onerror = idbError(callback);\r\n\r\n    txn.oncomplete = function () {\r\n      if (opts.limit === 0) {\r\n        return callback(null, {\r\n          total_rows : totalRows,\r\n          offset : opts.skip,\r\n          rows : []\r\n        });\r\n      } else if ('keys' in opts) {\r\n        allDocsKeysQuery(totalRows, opts, callback);\r\n      } else {\r\n        allDocsNormalQuery(totalRows, opts, callback);\r\n      }\r\n    };\r\n  };\r\n\r\n  api._info = function idb_info(callback) {\r\n    var count = 0;\r\n    var update_seq = 0;\r\n    var txn = idb.transaction([DOC_STORE, META_STORE], 'readonly');\r\n\r\n    function fetchUpdateSeq(e) {\r\n      update_seq = e.target.result && e.target.result.updateSeq || 0;\r\n    }\r\n\r\n    function countDocs(e) {\r\n      var cursor = e.target.result;\r\n      if (!cursor) {\r\n        txn.objectStore(META_STORE).get(META_STORE).onsuccess = fetchUpdateSeq;\r\n        return;\r\n      }\r\n      if (cursor.value.deleted !== true) {\r\n        count++;\r\n      }\r\n      cursor['continue']();\r\n    }\r\n\r\n    txn.oncomplete = function () {\r\n      callback(null, {\r\n        db_name: name,\r\n        doc_count: count,\r\n        update_seq: update_seq\r\n      });\r\n    };\r\n\r\n    txn.objectStore(DOC_STORE).openCursor().onsuccess = countDocs;\r\n  };\r\n\r\n  api._changes = function idb_changes(opts) {\r\n    opts = utils.extend(true, {}, opts);\r\n\r\n    if (opts.continuous) {\r\n      var id = name + ':' + utils.uuid();\r\n      IdbPouch.Changes.addListener(name, id, api, opts);\r\n      IdbPouch.Changes.notify(name);\r\n      return {\r\n        cancel: function () {\r\n          IdbPouch.Changes.removeListener(name, id);\r\n        }\r\n      };\r\n    }\r\n\r\n    var descending = opts.descending ? 'prev' : null;\r\n    var last_seq = 0;\r\n\r\n    // Ignore the `since` parameter when `descending` is true\r\n    opts.since = opts.since && !descending ? opts.since : 0;\r\n\r\n    var results = [], resultIndices = {}, dedupResults = [];\r\n    var txn;\r\n\r\n    function fetchChanges() {\r\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE]);\r\n      txn.oncomplete = onTxnComplete;\r\n\r\n      var req;\r\n\r\n      if (descending) {\r\n        req = txn.objectStore(BY_SEQ_STORE)\r\n            .openCursor(global.IDBKeyRange.lowerBound(opts.since, true), descending);\r\n      } else {\r\n        req = txn.objectStore(BY_SEQ_STORE)\r\n            .openCursor(global.IDBKeyRange.lowerBound(opts.since, true));\r\n      }\r\n\r\n      req.onsuccess = onsuccess;\r\n      req.onerror = onerror;\r\n    }\r\n\r\n    fetchChanges();\r\n\r\n    function onsuccess(event) {\r\n      if (!event.target.result) {\r\n        // Filter out null results casued by deduping\r\n        for (var i = 0, l = results.length; i < l; i++) {\r\n          var result = results[i];\r\n          if (result) {\r\n            dedupResults.push(result);\r\n          }\r\n        }\r\n        return false;\r\n      }\r\n\r\n      var cursor = event.target.result;\r\n\r\n      // Try to pre-emptively dedup to save us a bunch of idb calls\r\n      var changeId = cursor.value._id;\r\n      var changeIdIndex = resultIndices[changeId];\r\n      if (changeIdIndex !== undefined) {\r\n        results[changeIdIndex].seq = cursor.key;\r\n        // update so it has the later sequence number\r\n        results.push(results[changeIdIndex]);\r\n        results[changeIdIndex] = null;\r\n        resultIndices[changeId] = results.length - 1;\r\n        return cursor['continue']();\r\n      }\r\n\r\n      var index = txn.objectStore(DOC_STORE);\r\n      index.get(cursor.value._id).onsuccess = function (event) {\r\n        var metadata = event.target.result;\r\n        if (utils.isLocalId(metadata.id)) {\r\n          return cursor['continue']();\r\n        }\r\n\r\n        if (last_seq < metadata.seq) {\r\n          last_seq = metadata.seq;\r\n        }\r\n\r\n        var mainRev = merge.winningRev(metadata);\r\n        var key = metadata.id + \"::\" + mainRev;\r\n        var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\r\n        index.get(key).onsuccess = function (docevent) {\r\n          var doc = docevent.target.result;\r\n          delete doc['_doc_id_rev'];\r\n\r\n          doc._rev = mainRev;\r\n          var change = opts.processChange(doc, metadata, opts);\r\n          change.seq = cursor.key;\r\n\r\n          // Dedupe the changes feed\r\n          var changeId = change.id, changeIdIndex = resultIndices[changeId];\r\n          if (changeIdIndex !== undefined) {\r\n            results[changeIdIndex] = null;\r\n          }\r\n          results.push(change);\r\n          resultIndices[changeId] = results.length - 1;\r\n          cursor['continue']();\r\n        };\r\n      };\r\n    }\r\n\r\n    function onTxnComplete() {\r\n      utils.processChanges(opts, dedupResults, last_seq);\r\n    }\r\n  };\r\n\r\n  api._close = function (callback) {\r\n    if (idb === null) {\r\n      return callback(errors.NOT_OPEN);\r\n    }\r\n\r\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\r\n    // \"Returns immediately and closes the connection in a separate thread...\"\r\n    idb.close();\r\n    callback();\r\n  };\r\n\r\n  api._getRevisionTree = function (docId, callback) {\r\n    var txn = idb.transaction([DOC_STORE], 'readonly');\r\n    var req = txn.objectStore(DOC_STORE).get(docId);\r\n    req.onsuccess = function (event) {\r\n      var doc = event.target.result;\r\n      if (!doc) {\r\n        callback(errors.MISSING_DOC);\r\n      } else {\r\n        callback(null, doc.rev_tree);\r\n      }\r\n    };\r\n  };\r\n\r\n  // This function removes revisions of document docId\r\n  // which are listed in revs and sets this document\r\n  // revision to to rev_tree\r\n  api._doCompaction = function (docId, rev_tree, revs, callback) {\r\n    var txn = idb.transaction([DOC_STORE, BY_SEQ_STORE], 'readwrite');\r\n\r\n    var index = txn.objectStore(DOC_STORE);\r\n    index.get(docId).onsuccess = function (event) {\r\n      var metadata = event.target.result;\r\n      metadata.rev_tree = rev_tree;\r\n\r\n      var count = revs.length;\r\n      revs.forEach(function (rev) {\r\n        var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\r\n        var key = docId + \"::\" + rev;\r\n        index.getKey(key).onsuccess = function (e) {\r\n          var seq = e.target.result;\r\n          if (!seq) {\r\n            return;\r\n          }\r\n          txn.objectStore(BY_SEQ_STORE)['delete'](seq);\r\n\r\n          count--;\r\n          if (!count) {\r\n            if (metadata) {\r\n              var deleted = utils.isDeleted(metadata);\r\n              var local = utils.isLocalId(metadata.id);\r\n              metadata = utils.extend(true, {deletedOrLocal : (deleted || local) ? \"1\" : \"0\"}, metadata);\r\n            }\r\n            txn.objectStore(DOC_STORE).put(metadata);\r\n          }\r\n        };\r\n      });\r\n    };\r\n    txn.oncomplete = function () {\r\n      utils.call(callback);\r\n    };\r\n  };\r\n\r\n}\r\n\r\nIdbPouch.valid = function () {\r\n  return global.indexedDB && isModernIdb();\r\n};\r\n\r\nIdbPouch.destroy = utils.toPromise(function (name, opts, callback) {\r\n  if (!('openReqList' in IdbPouch)) {\r\n    IdbPouch.openReqList = {};\r\n  }\r\n  IdbPouch.Changes.clearListeners(name);\r\n\r\n  //Close open request for \"name\" database to fix ie delay.\r\n  if (IdbPouch.openReqList[name] && IdbPouch.openReqList[name].result) {\r\n    IdbPouch.openReqList[name].result.close();\r\n  }\r\n  var req = global.indexedDB.deleteDatabase(name);\r\n\r\n  req.onsuccess = function () {\r\n    //Remove open request from the list.\r\n    if (IdbPouch.openReqList[name]) {\r\n      IdbPouch.openReqList[name] = null;\r\n    }\r\n    callback();\r\n  };\r\n\r\n  req.onerror = idbError(callback);\r\n});\r\n\r\nIdbPouch.Changes = new utils.Changes();\r\n\r\nmodule.exports = IdbPouch;\r\n\r\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{\"../deps/errors\":8,\"../merge\":14,\"../utils\":18}],4:[function(_dereq_,module,exports){\r\n(function (global){\r\n'use strict';\r\n\r\nvar utils = _dereq_('../utils');\r\nvar merge = _dereq_('../merge');\r\nvar errors = _dereq_('../deps/errors');\r\nfunction quote(str) {\r\n  return \"'\" + str + \"'\";\r\n}\r\n\r\nvar cachedDatabases = {};\r\n\r\nvar openDB = utils.getArguments(function (args) {\r\n  if (typeof global !== 'undefined') {\r\n    if (global.navigator && global.navigator.sqlitePlugin &&\r\n        global.navigator.sqlitePlugin.openDatabase) {\r\n      return navigator.sqlitePlugin.openDatabase\r\n        .apply(navigator.sqlitePlugin, args);\r\n    } else if (global.sqlitePlugin && global.sqlitePlugin.openDatabase) {\r\n      return global.sqlitePlugin.openDatabase\r\n        .apply(global.sqlitePlugin, args);\r\n    } else {\r\n      var db = cachedDatabases[args[0]];\r\n      if (!db) {\r\n        db = cachedDatabases[args[0]] = global.openDatabase.apply(global, args);\r\n      }\r\n      return db;\r\n    }\r\n  }\r\n});\r\n\r\nvar POUCH_VERSION = 1;\r\nvar POUCH_SIZE = 5 * 1024 * 1024;\r\nvar ADAPTER_VERSION = 2; // used to manage migrations\r\n\r\n// The object stores created for each database\r\n// DOC_STORE stores the document meta data, its revision history and state\r\nvar DOC_STORE = quote('document-store');\r\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\r\n// sequence id\r\nvar BY_SEQ_STORE = quote('by-sequence');\r\n// Where we store attachments\r\nvar ATTACH_STORE = quote('attach-store');\r\nvar META_STORE = quote('metadata-store');\r\n\r\n// these indexes cover the ground for most allDocs queries\r\nvar BY_SEQ_STORE_DELETED_INDEX_SQL = 'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\r\n  BY_SEQ_STORE + ' (seq, deleted)';\r\nvar DOC_STORE_LOCAL_INDEX_SQL = 'CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\r\n  DOC_STORE + ' (local, id)';\r\nvar DOC_STORE_WINNINGSEQ_INDEX_SQL = 'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\r\n  DOC_STORE + ' (winningseq)';\r\n\r\n\r\nfunction unknownError(callback) {\r\n  return function (event) {\r\n    // event may actually be a SQLError object, so report is as such\r\n    var errorNameMatch = event && event.constructor.toString()\r\n      .match(/function ([^\\(]+)/);\r\n    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\r\n    var errorReason = event.target || event.message;\r\n    callback(errors.error(errors.WSQ_ERROR, errorReason, errorName));\r\n  };\r\n}\r\nfunction decodeUtf8(str) {\r\n  return decodeURIComponent(window.escape(str));\r\n}\r\nfunction parseHexString(str, encoding) {\r\n  var result = '';\r\n  var charWidth = encoding === 'UTF-8' ? 2 : 4;\r\n  for (var i = 0, len = str.length; i < len; i += charWidth) {\r\n    var substring = str.substring(i, i + charWidth);\r\n    if (charWidth === 4) { // UTF-16, twiddle the bits\r\n      substring = substring.substring(2, 4) + substring.substring(0, 2);\r\n    }\r\n    result += String.fromCharCode(parseInt(substring, 16));\r\n  }\r\n  result = encoding === 'UTF-8' ? decodeUtf8(result) : result;\r\n  return result;\r\n}\r\n\r\nfunction WebSqlPouch(opts, callback) {\r\n  var api = this;\r\n  var instanceId = null;\r\n  var name = opts.name;\r\n  var idRequests = [];\r\n  var encoding;\r\n\r\n  var db = openDB(name, POUCH_VERSION, name, POUCH_SIZE);\r\n  if (!db) {\r\n    return callback(errors.UNKNOWN_ERROR);\r\n  }\r\n\r\n  function dbCreated() {\r\n    // note the db name in case the browser upgrades to idb\r\n    if (utils.hasLocalStorage()) {\r\n      global.localStorage['_pouch__websqldb_' + name] = true;\r\n    }\r\n    callback(null, api);\r\n  }\r\n\r\n  // In this migration, we added the 'deleted' and 'local' columns to the by-seq and doc store tables.\r\n  // To preserve existing user data, we re-process all the existing JSON\r\n  // and add these values.\r\n  // Called migration2 because it corresponds to adapter version (db_version) #2\r\n  function runMigration2(tx) {\r\n\r\n    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL); // index used for the join in the allDocs query\r\n\r\n    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE + ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\r\n      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\r\n      tx.executeSql('ALTER TABLE ' + DOC_STORE + ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\r\n        tx.executeSql(DOC_STORE_LOCAL_INDEX_SQL);\r\n\r\n        var sql = 'SELECT ' + DOC_STORE + '.winningseq AS seq, ' + DOC_STORE + '.json AS metadata FROM ' +\r\n          BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\r\n          DOC_STORE + '.winningseq';\r\n\r\n        tx.executeSql(sql, [], function (tx, result) {\r\n\r\n          var deleted = [];\r\n          var local = [];\r\n\r\n          for (var i = 0; i < result.rows.length; i++) {\r\n            var item = result.rows.item(i);\r\n            var seq = item.seq;\r\n            var metadata = JSON.parse(item.metadata);\r\n            if (utils.isDeleted(metadata)) {\r\n              deleted.push(seq);\r\n            }\r\n            if (utils.isLocalId(metadata.id)) {\r\n              local.push(metadata.id);\r\n            }\r\n          }\r\n\r\n          tx.executeSql('UPDATE ' + DOC_STORE + 'SET local = 1 WHERE id IN (' + local.map(function () {\r\n            return '?';\r\n          }).join(',') + ')', local);\r\n          tx.executeSql('UPDATE ' + BY_SEQ_STORE + ' SET deleted = 1 WHERE seq IN (' + deleted.map(function () {\r\n            return '?';\r\n          }).join(',') + ')', deleted);\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  function onGetInstanceId(tx) {\r\n    while (idRequests.length > 0) {\r\n      var idCallback = idRequests.pop();\r\n      idCallback(null, instanceId);\r\n    }\r\n    checkDbEncoding(tx);\r\n  }\r\n\r\n  function checkDbEncoding(tx) {\r\n    // check db encoding - utf-8 (chrome, opera) or utf-16 (safari)?\r\n    tx.executeSql('SELECT dbid, hex(dbid) AS hexId FROM ' + META_STORE, [],\r\n      function (err, result) {\r\n        var id = result.rows.item(0).dbid;\r\n        var hexId = result.rows.item(0).hexId;\r\n        encoding = (hexId.length === id.length * 2) ? 'UTF-8' : 'UTF-16';\r\n      }\r\n    );\r\n  }\r\n\r\n  function onGetVersion(tx, dbVersion) {\r\n    if (dbVersion === 0) {\r\n      // initial schema\r\n\r\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE +\r\n        ' (update_seq, dbid, db_version INTEGER)';\r\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE +\r\n        ' (digest, json, body BLOB)';\r\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE +\r\n        ' (id unique, seq, json, winningseq, local TINYINT(1))';\r\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE +\r\n        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, doc_id_rev UNIQUE, json, deleted TINYINT(1))';\r\n\r\n      // creates\r\n      tx.executeSql(attach);\r\n      tx.executeSql(doc, [], function () {\r\n        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\r\n        tx.executeSql(DOC_STORE_LOCAL_INDEX_SQL);\r\n      });\r\n      tx.executeSql(seq, [], function () {\r\n        tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\r\n      });\r\n      tx.executeSql(meta, [], function () {\r\n        // mark the update_seq, db version, and new dbid\r\n        var initSeq = 'INSERT INTO ' + META_STORE + ' (update_seq, db_version, dbid) VALUES (?, ?, ?)';\r\n        instanceId = utils.uuid();\r\n        tx.executeSql(initSeq, [0, ADAPTER_VERSION, instanceId]);\r\n        onGetInstanceId(tx);\r\n      });\r\n    } else { // version > 0\r\n\r\n      if (dbVersion === 1) {\r\n        runMigration2(tx);\r\n        // mark the db version within this transaction\r\n        tx.executeSql('UPDATE ' + META_STORE + ' SET db_version = ' + ADAPTER_VERSION);\r\n      } // in the future, add more migrations here\r\n\r\n      // notify db.id() callers\r\n      tx.executeSql('SELECT dbid FROM ' + META_STORE, [], function (tx, result) {\r\n        instanceId = result.rows.item(0).dbid;\r\n        onGetInstanceId(tx);\r\n      });\r\n    }\r\n  }\r\n\r\n  function setup() {\r\n\r\n    db.transaction(function (tx) {\r\n      // first get the version\r\n      tx.executeSql('SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE, [], function (tx, result) {\r\n        if (!result.rows.length) {\r\n          // database hasn't even been created yet (version 0)\r\n          onGetVersion(tx, 0);\r\n        } else if (!/db_version/.test(result.rows.item(0).sql)) {\r\n          // table was created, but without the new db_version column, so add it.\r\n          tx.executeSql('ALTER TABLE ' + META_STORE + ' ADD COLUMN db_version INTEGER', [], function () {\r\n            onGetVersion(tx, 1); // before version 2, this column didn't even exist\r\n          });\r\n        } else { // column exists, we can safely get it\r\n          tx.executeSql('SELECT db_version FROM ' + META_STORE, [], function (tx, result) {\r\n            var dbVersion = result.rows.item(0).db_version;\r\n            onGetVersion(tx, dbVersion);\r\n          });\r\n        }\r\n      });\r\n    }, unknownError(callback), dbCreated);\r\n  }\r\n\r\n  if (utils.isCordova() && typeof global !== 'undefined') {\r\n    //to wait until custom api is made in pouch.adapters before doing setup\r\n    global.addEventListener(name + '_pouch', function cordova_init() {\r\n      global.removeEventListener(name + '_pouch', cordova_init, false);\r\n      setup();\r\n    }, false);\r\n  } else {\r\n    setup();\r\n  }\r\n\r\n\r\n  api.type = function () {\r\n    return 'websql';\r\n  };\r\n\r\n  api._id = utils.toPromise(function (callback) {\r\n    callback(null, instanceId);\r\n  });\r\n\r\n  api._info = function (callback) {\r\n    db.transaction(function (tx) {\r\n      var sql = 'SELECT COUNT(id) AS count FROM ' + DOC_STORE;\r\n      tx.executeSql(sql, [], function (tx, result) {\r\n        var doc_count = result.rows.item(0).count;\r\n        var updateseq = 'SELECT update_seq FROM ' + META_STORE;\r\n        tx.executeSql(updateseq, [], function (tx, result) {\r\n          var update_seq = result.rows.item(0).update_seq;\r\n          callback(null, {\r\n            db_name: name,\r\n            doc_count: doc_count,\r\n            update_seq: update_seq\r\n          });\r\n        });\r\n      });\r\n    });\r\n  };\r\n\r\n  api._bulkDocs = function (req, opts, callback) {\r\n\r\n    var newEdits = opts.new_edits;\r\n    var userDocs = req.docs;\r\n    var docsWritten = 0;\r\n\r\n    // Parse the docs, give them a sequence number for the result\r\n    var docInfos = userDocs.map(function (doc, i) {\r\n      var newDoc = utils.parseDoc(doc, newEdits);\r\n      newDoc._bulk_seq = i;\r\n      return newDoc;\r\n    });\r\n\r\n    var docInfoErrors = docInfos.filter(function (docInfo) {\r\n      return docInfo.error;\r\n    });\r\n    if (docInfoErrors.length) {\r\n      return callback(docInfoErrors[0]);\r\n    }\r\n\r\n    var tx;\r\n    var results = [];\r\n    var fetchedDocs = {};\r\n\r\n    function sortByBulkSeq(a, b) {\r\n      return a._bulk_seq - b._bulk_seq;\r\n    }\r\n\r\n    function complete(event) {\r\n      var aresults = [];\r\n      results.sort(sortByBulkSeq);\r\n      results.forEach(function (result) {\r\n        delete result._bulk_seq;\r\n        if (result.error) {\r\n          aresults.push(result);\r\n          return;\r\n        }\r\n        var metadata = result.metadata;\r\n        var rev = merge.winningRev(metadata);\r\n\r\n        aresults.push({\r\n          ok: true,\r\n          id: metadata.id,\r\n          rev: rev\r\n        });\r\n\r\n        if (utils.isLocalId(metadata.id)) {\r\n          return;\r\n        }\r\n\r\n        docsWritten++;\r\n\r\n        WebSqlPouch.Changes.notify(name);\r\n        WebSqlPouch.Changes.notifyLocalWindows(name);\r\n      });\r\n\r\n      var updateseq = 'SELECT update_seq FROM ' + META_STORE;\r\n      tx.executeSql(updateseq, [], function (tx, result) {\r\n        var update_seq = result.rows.item(0).update_seq + docsWritten;\r\n        var sql = 'UPDATE ' + META_STORE + ' SET update_seq=?';\r\n        tx.executeSql(sql, [update_seq], function () {\r\n          callback(null, aresults);\r\n        });\r\n      });\r\n    }\r\n\r\n    function preprocessAttachment(att, finish) {\r\n      if (att.stub) {\r\n        return finish();\r\n      }\r\n      if (typeof att.data === 'string') {\r\n        try {\r\n          att.data = atob(att.data);\r\n        } catch (e) {\r\n          var err = errors.error(errors.BAD_ARG,\r\n                                \"Attachments need to be base64 encoded\");\r\n          return callback(err);\r\n        }\r\n        var data = utils.fixBinary(att.data);\r\n        att.data = utils.createBlob([data], {type: att.content_type});\r\n      }\r\n      var reader = new FileReader();\r\n      reader.onloadend = function (e) {\r\n        var binary = utils.arrayBufferToBinaryString(this.result);\r\n        att.data = binary;\r\n        att.digest = 'md5-' + utils.Crypto.MD5(binary);\r\n        finish();\r\n      };\r\n      reader.readAsArrayBuffer(att.data);\r\n    }\r\n\r\n    function preprocessAttachments(callback) {\r\n      if (!docInfos.length) {\r\n        return callback();\r\n      }\r\n\r\n      var docv = 0;\r\n\r\n      docInfos.forEach(function (docInfo) {\r\n        var attachments = docInfo.data && docInfo.data._attachments ?\r\n          Object.keys(docInfo.data._attachments) : [];\r\n        var recv = 0;\r\n\r\n        if (!attachments.length) {\r\n          return done();\r\n        }\r\n\r\n        function processedAttachment() {\r\n          recv++;\r\n          if (recv === attachments.length) {\r\n            done();\r\n          }\r\n        }\r\n\r\n        for (var key in docInfo.data._attachments) {\r\n          if (docInfo.data._attachments.hasOwnProperty(key)) {\r\n            preprocessAttachment(docInfo.data._attachments[key], processedAttachment);\r\n          }\r\n        }\r\n      });\r\n\r\n      function done() {\r\n        docv++;\r\n        if (docInfos.length === docv) {\r\n          callback();\r\n        }\r\n      }\r\n    }\r\n\r\n    function writeDoc(docInfo, callback, isUpdate) {\r\n\r\n      function finish() {\r\n        var data = docInfo.data;\r\n        var doc_id_rev = data._id + \"::\" + data._rev;\r\n        var deleted = utils.isDeleted(docInfo.metadata, docInfo.metadata.rev) ? 1 : 0;\r\n        var fetchSql = 'SELECT * FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev=?;';\r\n\r\n        tx.executeSql(fetchSql, [doc_id_rev], function (err, res) {\r\n          var sql, sqlArgs;\r\n          if (res.rows.length) {\r\n            sql = 'UPDATE ' + BY_SEQ_STORE +\r\n              ' SET json=?, deleted=? WHERE doc_id_rev=?;';\r\n            sqlArgs = [JSON.stringify(data), deleted, doc_id_rev];\r\n            tx.executeSql(sql, sqlArgs, function (tx) {\r\n              dataWritten(tx, res.rows.item(0).seq);\r\n            });\r\n          } else {\r\n            sql = 'INSERT INTO ' + BY_SEQ_STORE +\r\n              ' (doc_id_rev, json, deleted) VALUES (?, ?, ?);';\r\n            sqlArgs = [doc_id_rev, JSON.stringify(data), deleted];\r\n            tx.executeSql(sql, sqlArgs, function (tx, result) {\r\n              dataWritten(tx, result.insertId);\r\n            });\r\n          }\r\n        });\r\n      }\r\n\r\n      function collectResults(attachmentErr) {\r\n        if (!err) {\r\n          if (attachmentErr) {\r\n            err = attachmentErr;\r\n            callback(err);\r\n          } else if (recv === attachments.length) {\r\n            finish();\r\n          }\r\n        }\r\n      }\r\n\r\n      var err = null;\r\n      var recv = 0;\r\n\r\n      docInfo.data._id = docInfo.metadata.id;\r\n      docInfo.data._rev = docInfo.metadata.rev;\r\n\r\n      if (utils.isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\r\n        docInfo.data._deleted = true;\r\n      }\r\n\r\n      var attachments = docInfo.data._attachments ?\r\n        Object.keys(docInfo.data._attachments) : [];\r\n\r\n      function attachmentSaved(err) {\r\n        recv++;\r\n        collectResults(err);\r\n      }\r\n\r\n      for (var key in docInfo.data._attachments) {\r\n        if (!docInfo.data._attachments[key].stub) {\r\n          var data = docInfo.data._attachments[key].data;\r\n          delete docInfo.data._attachments[key].data;\r\n          var digest = docInfo.data._attachments[key].digest;\r\n          saveAttachment(docInfo, digest, data, attachmentSaved);\r\n        } else {\r\n          recv++;\r\n          collectResults();\r\n        }\r\n      }\r\n\r\n      if (!attachments.length) {\r\n        finish();\r\n      }\r\n\r\n      function dataWritten(tx, seq) {\r\n        docInfo.metadata.seq = seq;\r\n        delete docInfo.metadata.rev;\r\n\r\n        var mainRev = merge.winningRev(docInfo.metadata);\r\n\r\n        var sql = isUpdate ?\r\n          'UPDATE ' + DOC_STORE + ' SET seq=?, json=?, winningseq=(SELECT seq FROM ' +\r\n          BY_SEQ_STORE + ' WHERE doc_id_rev=?) WHERE id=?' :\r\n          'INSERT INTO ' + DOC_STORE + ' (id, seq, winningseq, json, local) VALUES (?, ?, ?, ?, ?);';\r\n        var metadataStr = JSON.stringify(docInfo.metadata);\r\n        var key = docInfo.metadata.id + \"::\" + mainRev;\r\n        var local = utils.isLocalId(docInfo.metadata.id) ? 1 : 0;\r\n        var params = isUpdate ?\r\n          [seq, metadataStr, key, docInfo.metadata.id] :\r\n          [docInfo.metadata.id, seq, seq, metadataStr, local];\r\n        tx.executeSql(sql, params, function (tx, result) {\r\n          results.push(docInfo);\r\n          callback();\r\n        });\r\n      }\r\n    }\r\n\r\n    function updateDoc(oldDoc, docInfo) {\r\n      var merged = merge.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\r\n      var inConflict = (utils.isDeleted(oldDoc) &&\r\n                        utils.isDeleted(docInfo.metadata)) ||\r\n        (!utils.isDeleted(oldDoc) &&\r\n         newEdits && merged.conflicts !== 'new_leaf');\r\n\r\n      if (inConflict) {\r\n        results.push(makeErr(errors.REV_CONFLICT, docInfo._bulk_seq));\r\n        return processDocs();\r\n      }\r\n\r\n      docInfo.metadata.rev_tree = merged.tree;\r\n      writeDoc(docInfo, processDocs, true);\r\n    }\r\n\r\n    function insertDoc(docInfo) {\r\n      // Cant insert new deleted documents\r\n      if ('was_delete' in opts && utils.isDeleted(docInfo.metadata)) {\r\n        results.push(errors.MISSING_DOC);\r\n        return processDocs();\r\n      }\r\n      writeDoc(docInfo, processDocs, false);\r\n    }\r\n\r\n    function processDocs() {\r\n      if (!docInfos.length) {\r\n        return complete();\r\n      }\r\n      var currentDoc = docInfos.shift();\r\n      var id = currentDoc.metadata.id;\r\n      if (id in fetchedDocs) {\r\n        updateDoc(fetchedDocs[id], currentDoc);\r\n      } else {\r\n        // if we have newEdits=false then we can update the same\r\n        // document twice in a single bulk docs call\r\n        fetchedDocs[id] = currentDoc.metadata;\r\n        insertDoc(currentDoc);\r\n      }\r\n    }\r\n\r\n    // Insert sequence number into the error so we can sort later\r\n    function makeErr(err, seq) {\r\n      err._bulk_seq = seq;\r\n      return err;\r\n    }\r\n\r\n    function saveAttachment(docInfo, digest, data, callback) {\r\n      var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\r\n      var newAtt = {digest: digest};\r\n      var sql = 'SELECT digest, json FROM ' + ATTACH_STORE + ' WHERE digest=?';\r\n      tx.executeSql(sql, [digest], function (tx, result) {\r\n        if (!result.rows.length) {\r\n          newAtt.refs = {};\r\n          newAtt.refs[ref] = true;\r\n          sql = 'INSERT INTO ' + ATTACH_STORE + '(digest, json, body) VALUES (?, ?, ?)';\r\n          tx.executeSql(sql, [digest, JSON.stringify(newAtt), data], function () {\r\n            callback();\r\n          });\r\n        } else {\r\n          newAtt.refs = JSON.parse(result.rows.item(0).json).refs;\r\n          sql = 'UPDATE ' + ATTACH_STORE + ' SET json=?, body=? WHERE digest=?';\r\n          tx.executeSql(sql, [JSON.stringify(newAtt), data, digest], function () {\r\n            callback();\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    function metadataFetched(tx, results) {\r\n      for (var j = 0; j < results.rows.length; j++) {\r\n        var row = results.rows.item(j);\r\n        var id = parseHexString(row.hexId, encoding);\r\n        fetchedDocs[id] = JSON.parse(row.json);\r\n      }\r\n      processDocs();\r\n    }\r\n\r\n    preprocessAttachments(function () {\r\n      db.transaction(function (txn) {\r\n        tx = txn;\r\n        var sql = 'SELECT hex(id) AS hexId, json FROM ' + DOC_STORE + ' WHERE id IN ' +\r\n          '(' + docInfos.map(function () {return '?'; }).join(',') + ')';\r\n        var queryArgs = docInfos.map(function (d) { return d.metadata.id; });\r\n        tx.executeSql(sql, queryArgs, metadataFetched);\r\n      }, unknownError(callback));\r\n    });\r\n  };\r\n\r\n  api._get = function (id, opts, callback) {\r\n    opts = utils.extend(true, {}, opts);\r\n    var doc;\r\n    var metadata;\r\n    var err;\r\n    if (!opts.ctx) {\r\n      db.transaction(function (txn) {\r\n        opts.ctx = txn;\r\n        api._get(id, opts, callback);\r\n      });\r\n      return;\r\n    }\r\n    var tx = opts.ctx;\r\n\r\n    function finish() {\r\n      callback(err, {doc: doc, metadata: metadata, ctx: tx});\r\n    }\r\n\r\n    var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id=?';\r\n    tx.executeSql(sql, [id], function (a, results) {\r\n      if (!results.rows.length) {\r\n        err = errors.MISSING_DOC;\r\n        return finish();\r\n      }\r\n      metadata = JSON.parse(results.rows.item(0).json);\r\n      if (utils.isDeleted(metadata) && !opts.rev) {\r\n        err = errors.error(errors.MISSING_DOC, \"deleted\");\r\n        return finish();\r\n      }\r\n\r\n      var rev = merge.winningRev(metadata);\r\n      var key = opts.rev ? opts.rev : rev;\r\n      key = metadata.id + '::' + key;\r\n      var sql = 'SELECT * FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev=?';\r\n      tx.executeSql(sql, [key], function (tx, results) {\r\n        if (!results.rows.length) {\r\n          err = errors.MISSING_DOC;\r\n          return finish();\r\n        }\r\n        doc = JSON.parse(results.rows.item(0).json);\r\n\r\n        finish();\r\n      });\r\n    });\r\n  };\r\n\r\n  api._allDocs = function (opts, callback) {\r\n    var results = [];\r\n    var resultsMap = {};\r\n    var totalRows;\r\n\r\n    var from = BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\r\n      DOC_STORE + '.winningseq';\r\n\r\n    var start = 'startkey' in opts ? opts.startkey : false;\r\n    var end = 'endkey' in opts ? opts.endkey : false;\r\n    var key = 'key' in opts ? opts.key : false;\r\n    var descending = 'descending' in opts ? opts.descending : false;\r\n    var keys = 'keys' in opts ? opts.keys : false;\r\n    var limit = 'limit' in opts ? opts.limit : false;\r\n    var offset = 'skip' in opts ? opts.skip : false;\r\n\r\n    var sqlArgs = [];\r\n    var criteria = [DOC_STORE + '.local = 0'];\r\n\r\n    if (key !== false) {\r\n      criteria.push(DOC_STORE + '.id = ?');\r\n      sqlArgs.push(key);\r\n    } else if (keys !== false) {\r\n      criteria.push(DOC_STORE + '.id in (' + keys.map(function () {\r\n        return '?';\r\n      }).join(',') + ')');\r\n      sqlArgs = sqlArgs.concat(keys);\r\n    } else if (start !== false || end !== false) {\r\n      if (start !== false) {\r\n        criteria.push(DOC_STORE + '.id ' + (descending ? '<=' : '>=') + ' ?');\r\n        sqlArgs.push(start);\r\n      }\r\n      if (end !== false) {\r\n        criteria.push(DOC_STORE + '.id ' + (descending ? '>=' : '<=') + ' ?');\r\n        sqlArgs.push(end);\r\n      }\r\n      if (key !== false) {\r\n        criteria.push(DOC_STORE + '.id = ?');\r\n        sqlArgs.push(key);\r\n      }\r\n    }\r\n\r\n    if (keys === false) {\r\n      // report deleted if keys are specified\r\n      criteria.push(BY_SEQ_STORE + '.deleted = 0');\r\n    }\r\n\r\n    db.transaction(function (tx) {\r\n\r\n      // first count up the total rows\r\n      var sql = 'SELECT COUNT(' + DOC_STORE + '.id) AS \\'num\\' FROM ' +\r\n        from + ' WHERE ' + BY_SEQ_STORE + '.deleted = 0 AND ' +\r\n        // local docs are e.g. '_local_foo'\r\n        DOC_STORE + '.local = 0';\r\n\r\n      tx.executeSql(sql, [], function (tx, result) {\r\n        totalRows = result.rows.item(0).num;\r\n\r\n        if (limit === 0) {\r\n          return;\r\n        }\r\n\r\n        // then actually fetch the documents\r\n\r\n        var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\r\n          BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' + from;\r\n\r\n        if (criteria.length) {\r\n          sql += ' WHERE ' + criteria.join(' AND ');\r\n        }\r\n        sql += ' ORDER BY ' + DOC_STORE + '.id ' + (descending ? 'DESC' : 'ASC');\r\n        if (limit !== false) {\r\n          sql += ' LIMIT ' + limit;\r\n        }\r\n        if (offset !== false && offset > 0) {\r\n          if (limit === false) {\r\n            // sqlite requires limit with offset, -1 acts as infinity here\r\n            sql += ' LIMIT -1';\r\n          }\r\n          sql += ' OFFSET ' + offset;\r\n        }\r\n\r\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\r\n          for (var i = 0, l = result.rows.length; i < l; i++) {\r\n            var doc = result.rows.item(i);\r\n            var metadata = JSON.parse(doc.metadata);\r\n            var data = JSON.parse(doc.data);\r\n            doc = {\r\n              id: metadata.id,\r\n              key: metadata.id,\r\n              value: {rev: merge.winningRev(metadata)}\r\n            };\r\n            if (opts.include_docs) {\r\n              doc.doc = data;\r\n              doc.doc._rev = merge.winningRev(metadata);\r\n              if (opts.conflicts) {\r\n                doc.doc._conflicts = merge.collectConflicts(metadata);\r\n              }\r\n              for (var att in doc.doc._attachments) {\r\n                if (doc.doc._attachments.hasOwnProperty(att)) {\r\n                  doc.doc._attachments[att].stub = true;\r\n                }\r\n              }\r\n            }\r\n            if ('keys' in opts) {\r\n              if (opts.keys.indexOf(metadata.id) > -1) {\r\n                if (utils.isDeleted(metadata)) {\r\n                  doc.value.deleted = true;\r\n                  doc.doc = null;\r\n                }\r\n                resultsMap[doc.id] = doc;\r\n              }\r\n            } else {\r\n              results.push(doc);\r\n            }\r\n          }\r\n        });\r\n      });\r\n    }, unknownError(callback), function () {\r\n      if (limit !== 0 && 'keys' in opts) {\r\n        opts.keys.forEach(function (key) {\r\n          if (key in resultsMap) {\r\n            results.push(resultsMap[key]);\r\n          } else {\r\n            results.push({\"key\": key, \"error\": \"not_found\"});\r\n          }\r\n        });\r\n        if (opts.descending) {\r\n          results.reverse();\r\n        }\r\n      }\r\n      callback(null, {\r\n        total_rows: totalRows,\r\n        offset: opts.skip,\r\n        rows: results\r\n      });\r\n    });\r\n  };\r\n\r\n  api._changes = function idb_changes(opts) {\r\n    opts = utils.extend(true, {}, opts);\r\n\r\n    if (opts.continuous) {\r\n      var id = name + ':' + utils.uuid();\r\n      WebSqlPouch.Changes.addListener(name, id, api, opts);\r\n      WebSqlPouch.Changes.notify(name);\r\n      return {\r\n        cancel: function () {\r\n          WebSqlPouch.Changes.removeListener(name, id);\r\n        }\r\n      };\r\n    }\r\n\r\n    var descending = opts.descending;\r\n\r\n    // Ignore the `since` parameter when `descending` is true\r\n    opts.since = opts.since && !descending ? opts.since : 0;\r\n\r\n    var results = [];\r\n\r\n    function fetchChanges() {\r\n      var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\r\n        BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +\r\n        BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\r\n        DOC_STORE + '.winningseq WHERE ' + DOC_STORE + '.seq > ' + opts.since +\r\n        ' ORDER BY ' + DOC_STORE + '.seq ' + (descending ? 'DESC' : 'ASC');\r\n\r\n      db.transaction(function (tx) {\r\n        tx.executeSql(sql, [], function (tx, result) {\r\n          var last_seq = 0;\r\n          for (var i = 0, l = result.rows.length; i < l; i++) {\r\n            var res = result.rows.item(i);\r\n            var metadata = JSON.parse(res.metadata);\r\n            if (!utils.isLocalId(metadata.id)) {\r\n              if (last_seq < res.seq) {\r\n                last_seq = res.seq;\r\n              }\r\n              var doc = JSON.parse(res.data);\r\n              var change = opts.processChange(doc, metadata, opts);\r\n              change.seq = res.seq;\r\n\r\n              results.push(change);\r\n            }\r\n          }\r\n          utils.processChanges(opts, results, last_seq);\r\n        });\r\n      });\r\n    }\r\n\r\n    fetchChanges();\r\n  };\r\n\r\n  api._close = function (callback) {\r\n    //WebSQL databases do not need to be closed\r\n    callback();\r\n  };\r\n\r\n  api._getAttachment = function (attachment, opts, callback) {\r\n    var res;\r\n    var tx = opts.ctx;\r\n    var digest = attachment.digest;\r\n    var type = attachment.content_type;\r\n    var sql = 'SELECT hex(body) as body FROM ' + ATTACH_STORE + ' WHERE digest=?';\r\n    tx.executeSql(sql, [digest], function (tx, result) {\r\n      // sqlite normally stores data as utf8, so even the hex() function\r\n      // \"encodes\" the binary data in utf8/16 before returning it. yet hex()\r\n      // is the only way to get the full data, so we do this.\r\n      var data = parseHexString(result.rows.item(0).body, encoding);\r\n      if (opts.encode) {\r\n        res = btoa(data);\r\n      } else {\r\n        data = utils.fixBinary(data);\r\n        res = utils.createBlob([data], {type: type});\r\n      }\r\n      callback(null, res);\r\n    });\r\n  };\r\n\r\n  api._getRevisionTree = function (docId, callback) {\r\n    db.transaction(function (tx) {\r\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE + ' WHERE id = ?';\r\n      tx.executeSql(sql, [docId], function (tx, result) {\r\n        if (!result.rows.length) {\r\n          callback(errors.MISSING_DOC);\r\n        } else {\r\n          var data = JSON.parse(result.rows.item(0).metadata);\r\n          callback(null, data.rev_tree);\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  api._doCompaction = function (docId, rev_tree, revs, callback) {\r\n    db.transaction(function (tx) {\r\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE + ' WHERE id = ?';\r\n      tx.executeSql(sql, [docId], function (tx, result) {\r\n        if (!result.rows.length) {\r\n          return utils.call(callback);\r\n        }\r\n        var metadata = JSON.parse(result.rows.item(0).metadata);\r\n        metadata.rev_tree = rev_tree;\r\n\r\n        var sql = 'DELETE FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev IN (' +\r\n          revs.map(function () { return '?'; }).join(',') + ')';\r\n\r\n        var docIdRevs = revs.map(function (rev) {return docId + '::' + rev; });\r\n        tx.executeSql(sql, [docIdRevs], function (tx) {\r\n          var sql = 'UPDATE ' + DOC_STORE + ' SET json = ? WHERE id = ?';\r\n\r\n          tx.executeSql(sql, [JSON.stringify(metadata), docId], function () {\r\n            callback();\r\n          });\r\n        });\r\n      });\r\n    });\r\n  };\r\n}\r\n\r\nWebSqlPouch.valid = function () {\r\n  if (typeof global !== 'undefined') {\r\n    if (global.navigator && global.navigator.sqlitePlugin && global.navigator.sqlitePlugin.openDatabase) {\r\n      return true;\r\n    } else if (global.sqlitePlugin && global.sqlitePlugin.openDatabase) {\r\n      return true;\r\n    } else if (global.openDatabase) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nWebSqlPouch.destroy = utils.toPromise(function (name, opts, callback) {\r\n  var db = openDB(name, POUCH_VERSION, name, POUCH_SIZE);\r\n  db.transaction(function (tx) {\r\n    tx.executeSql('DROP TABLE IF EXISTS ' + DOC_STORE, []);\r\n    tx.executeSql('DROP TABLE IF EXISTS ' + BY_SEQ_STORE, []);\r\n    tx.executeSql('DROP TABLE IF EXISTS ' + ATTACH_STORE, []);\r\n    tx.executeSql('DROP TABLE IF EXISTS ' + META_STORE, []);\r\n  }, unknownError(callback), function () {\r\n    if (utils.hasLocalStorage()) {\r\n      delete global.localStorage['_pouch__websqldb_' + name];\r\n    }\r\n    callback();\r\n  });\r\n});\r\n\r\nWebSqlPouch.Changes = new utils.Changes();\r\n\r\nmodule.exports = WebSqlPouch;\r\n\r\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{\"../deps/errors\":8,\"../merge\":14,\"../utils\":18}],5:[function(_dereq_,module,exports){\r\n(function (global){\r\n/*globals cordova */\r\n\"use strict\";\r\n\r\nvar Promise = typeof global.Promise === 'function' ?\r\n  global.Promise : _dereq_('bluebird');\r\n\r\nvar Adapter = _dereq_('./adapter');\r\nvar utils = _dereq_('./utils');\r\nvar TaskQueue = _dereq_('./taskqueue');\r\n\r\nfunction defaultCallback(err) {\r\n  if (err && global.debug) {\r\n    console.error(err);\r\n  }\r\n}\r\n\r\nutils.inherits(PouchDB, Adapter);\r\nfunction PouchDB(name, opts, callback) {\r\n\r\n  if (!(this instanceof PouchDB)) {\r\n    return new PouchDB(name, opts, callback);\r\n  }\r\n  var self = this;\r\n  if (typeof opts === 'function' || typeof opts === 'undefined') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n\r\n  if (typeof name === 'object') {\r\n    opts = name;\r\n    name = undefined;\r\n  }\r\n  if (typeof callback === 'undefined') {\r\n    callback = defaultCallback;\r\n  }\r\n  opts = opts || {};\r\n  var oldCB = callback;\r\n  self.auto_compaction = opts.auto_compaction;\r\n  self.prefix = PouchDB.prefix;\r\n  Adapter.call(self);\r\n  self.taskqueue = new TaskQueue();\r\n  var promise = new Promise(function (fulfill, reject) {\r\n    callback = function (err, resp) {\r\n      if (err) {\r\n        return reject(err);\r\n      }\r\n      delete resp.then;\r\n      fulfill(resp);\r\n    };\r\n\r\n    opts = utils.extend(true, {}, opts);\r\n    var originalName = opts.name || name;\r\n    var backend, error;\r\n    (function () {\r\n      try {\r\n\r\n        if (typeof originalName !== 'string') {\r\n          error = new Error('Missing/invalid DB name');\r\n          error.code = 400;\r\n          throw error;\r\n        }\r\n\r\n        backend = PouchDB.parseAdapter(originalName, opts);\r\n\r\n        opts.originalName = originalName;\r\n        opts.name = backend.name;\r\n        opts.adapter = opts.adapter || backend.adapter;\r\n\r\n        if (!PouchDB.adapters[opts.adapter]) {\r\n          error = new Error('Adapter is missing');\r\n          error.code = 404;\r\n          throw error;\r\n        }\r\n\r\n        if (!PouchDB.adapters[opts.adapter].valid()) {\r\n          error = new Error('Invalid Adapter');\r\n          error.code = 404;\r\n          throw error;\r\n        }\r\n      } catch (err) {\r\n        self.taskqueue.fail(err);\r\n        self.changes = utils.toPromise(function (opts) {\r\n          if (opts.complete) {\r\n            opts.complete(err);\r\n          }\r\n        });\r\n      }\r\n    }());\r\n    if (error) {\r\n      return reject(error); // constructor error, see above\r\n    }\r\n    self.adapter = opts.adapter;\r\n\r\n    // needs access to PouchDB;\r\n    self.replicate = function (src, target, opts) {\r\n      return utils.cancellableFun(function (api, _opts, promise) {\r\n        var replicate = PouchDB.replicate(src, target, opts);\r\n        promise.cancel = replicate.cancel;\r\n      }, self, opts);\r\n    };\r\n\r\n    self.replicate.from = function (url, opts, callback) {\r\n      if (typeof opts === 'function') {\r\n        callback = opts;\r\n        opts = {};\r\n      }\r\n      return PouchDB.replicate(url, self, opts, callback);\r\n    };\r\n\r\n    self.replicate.to = function (url, opts, callback) {\r\n      if (typeof opts === 'function') {\r\n        callback = opts;\r\n        opts = {};\r\n      }\r\n      return PouchDB.replicate(self, url, opts, callback);\r\n    };\r\n\r\n    self.replicate.sync = function (dbName, opts, callback) {\r\n      if (typeof opts === 'function') {\r\n        callback = opts;\r\n        opts = {};\r\n      }\r\n      return utils.cancellableFun(function (api, _opts, promise) {\r\n        var sync = PouchDB.sync(self, dbName, opts, callback);\r\n        promise.cancel = sync.cancel;\r\n      }, self, opts);\r\n    };\r\n\r\n    self.destroy = utils.adapterFun('destroy', function (callback) {\r\n      var self = this;\r\n      self.info(function (err, info) {\r\n        if (err) {\r\n          return callback(err);\r\n        }\r\n        PouchDB.destroy(info.db_name, callback);\r\n      });\r\n    });\r\n\r\n    PouchDB.adapters[opts.adapter].call(self, opts, function (err, db) {\r\n      if (err) {\r\n        if (callback) {\r\n          self.taskqueue.fail(err);\r\n          callback(err);\r\n        }\r\n        return;\r\n      }\r\n      function destructionListener(event) {\r\n        if (event === 'destroyed') {\r\n          self.emit('destroyed');\r\n          PouchDB.removeListener(opts.name, destructionListener);\r\n        }\r\n      }\r\n      PouchDB.on(opts.name, destructionListener);\r\n      self.emit('created', self);\r\n      PouchDB.emit('created', opts.originalName);\r\n      self.taskqueue.ready(self);\r\n      callback(null, self);\r\n\r\n    });\r\n    if (opts.skipSetup) {\r\n      self.taskqueue.ready(self);\r\n    }\r\n\r\n    if (utils.isCordova()) {\r\n      //to inform websql adapter that we can use api\r\n      cordova.fireWindowEvent(opts.name + \"_pouch\", {});\r\n    }\r\n  });\r\n  promise.then(function (resp) {\r\n    oldCB(null, resp);\r\n  }, oldCB);\r\n  self.then = promise.then.bind(promise);\r\n  //prevent deoptimizing\r\n  (function () {\r\n    try {\r\n      self['catch'] = promise['catch'].bind(promise);\r\n    } catch (e) {}\r\n  }());\r\n}\r\n\r\nmodule.exports = PouchDB;\r\n\r\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{\"./adapter\":1,\"./taskqueue\":17,\"./utils\":18,\"bluebird\":28}],6:[function(_dereq_,module,exports){\r\n(function (process){\r\n\"use strict\";\r\n\r\nvar request = _dereq_('request');\r\nvar extend = _dereq_('./extend.js');\r\nvar createBlob = _dereq_('./blob.js');\r\nvar errors = _dereq_('./errors');\r\nvar uuid = _dereq_('../deps/uuid');\r\nvar utils = _dereq_(\"../utils\");\r\n\r\nfunction ajax(options, adapterCallback) {\r\n\r\n  var requestCompleted = false;\r\n  var callback = utils.getArguments(function (args) {\r\n    if (requestCompleted) {\r\n      return;\r\n    }\r\n    adapterCallback.apply(this, args);\r\n    requestCompleted = true;\r\n  });\r\n\r\n  if (typeof options === \"function\") {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  options = extend(true, {}, options);\r\n\r\n  var defaultOptions = {\r\n    method : \"GET\",\r\n    headers: {},\r\n    json: true,\r\n    processData: true,\r\n    timeout: 10000,\r\n    cache: false\r\n  };\r\n\r\n  options = extend(true, defaultOptions, options);\r\n\r\n  // cache-buster, specifically designed to work around IE's aggressive caching\r\n  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\r\n  if (options.method === 'GET' && !options.cache) {\r\n    var hasArgs = options.url.indexOf('?') !== -1;\r\n    options.url += (hasArgs ? '&' : '?') + '_nonce=' + uuid(16);\r\n  }\r\n\r\n  function onSuccess(obj, resp, cb) {\r\n    if (!options.binary && !options.json && options.processData &&\r\n      typeof obj !== 'string') {\r\n      obj = JSON.stringify(obj);\r\n    } else if (!options.binary && options.json && typeof obj === 'string') {\r\n      try {\r\n        obj = JSON.parse(obj);\r\n      } catch (e) {\r\n        // Probably a malformed JSON from server\r\n        return cb(e);\r\n      }\r\n    }\r\n    if (Array.isArray(obj)) {\r\n      obj = obj.map(function (v) {\r\n        var obj;\r\n        if (v.ok) {\r\n          return v;\r\n        } else if (v.error && v.error === 'conflict') {\r\n          obj = errors.REV_CONFLICT;\r\n          obj.id = v.id;\r\n          return obj;\r\n        } else if (v.error && v.error === 'forbidden') {\r\n          obj = errors.FORBIDDEN;\r\n          obj.id = v.id;\r\n          obj.reason = v.reason;\r\n          return obj;\r\n        } else if (v.missing) {\r\n          obj = errors.MISSING_DOC;\r\n          obj.missing = v.missing;\r\n          return obj;\r\n        } else {\r\n          return v;\r\n        }\r\n      });\r\n    }\r\n    cb(null, obj, resp);\r\n  }\r\n\r\n  function onError(err, cb) {\r\n    var errParsed, errObj, errType, key;\r\n    try {\r\n      errParsed = JSON.parse(err.responseText);\r\n      //would prefer not to have a try/catch clause\r\n      for (key in errors) {\r\n        if (errors.hasOwnProperty(key) &&\r\n            errors[key].name === errParsed.error) {\r\n          errType = errors[key];\r\n          break;\r\n        }\r\n      }\r\n      if (!errType) {\r\n        errType = errors.UNKNOWN_ERROR;\r\n        if (err.status) {\r\n          errType.status = err.status;\r\n        }\r\n        if (err.statusText) {\r\n          err.name = err.statusText;\r\n        }\r\n      }\r\n      errObj = errors.error(errType, errParsed.reason);\r\n    } catch (e) {\r\n      for (var key in errors) {\r\n        if (errors.hasOwnProperty(key) && errors[key].status === err.status) {\r\n          errType = errors[key];\r\n          break;\r\n        }\r\n      }\r\n      if (!errType) {\r\n        errType = errors.UNKNOWN_ERROR;\r\n        if (err.status) {\r\n          errType.status = err.status;\r\n        }\r\n        if (err.statusText) {\r\n          err.name = err.statusText;\r\n        }\r\n      }\r\n      errObj = errors.error(errType);\r\n    }\r\n    cb(errObj);\r\n  }\r\n\r\n  if (process.browser) {\r\n    var timer;\r\n    var xhr;\r\n    if (options.xhr) {\r\n      xhr = new options.xhr();\r\n    } else {\r\n      xhr = new XMLHttpRequest();\r\n    }\r\n    xhr.open(options.method, options.url);\r\n    xhr.withCredentials = true;\r\n\r\n    if (options.json) {\r\n      options.headers.Accept = 'application/json';\r\n      options.headers['Content-Type'] = options.headers['Content-Type'] ||\r\n        'application/json';\r\n      if (options.body &&\r\n          options.processData &&\r\n          typeof options.body !== \"string\") {\r\n        options.body = JSON.stringify(options.body);\r\n      }\r\n    }\r\n\r\n    if (options.binary) {\r\n      xhr.responseType = 'arraybuffer';\r\n    }\r\n\r\n    var createCookie = function (name, value, days) {\r\n      var expires = \"\";\r\n      if (days) {\r\n        var date = new Date();\r\n        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\r\n        expires = \"; expires=\" + date.toGMTString();\r\n      }\r\n      document.cookie = name + \"=\" + value + expires + \"; path=/\";\r\n    };\r\n\r\n    for (var key in options.headers) {\r\n      if (key === 'Cookie') {\r\n        var cookie = options.headers[key].split('=');\r\n        createCookie(cookie[0], cookie[1], 10);\r\n      } else {\r\n        xhr.setRequestHeader(key, options.headers[key]);\r\n      }\r\n    }\r\n\r\n    if (!(\"body\" in options)) {\r\n      options.body = null;\r\n    }\r\n\r\n    var abortReq = function () {\r\n      if (requestCompleted) {\r\n        return;\r\n      }\r\n      xhr.abort();\r\n      onError(xhr, callback);\r\n    };\r\n\r\n    xhr.onreadystatechange = function () {\r\n      if (xhr.readyState !== 4 || requestCompleted) {\r\n        return;\r\n      }\r\n      clearTimeout(timer);\r\n      if (xhr.status >= 200 && xhr.status < 300) {\r\n        var data;\r\n        if (options.binary) {\r\n          data = createBlob([xhr.response || ''], {\r\n            type: xhr.getResponseHeader('Content-Type')\r\n          });\r\n        } else {\r\n          data = xhr.responseText;\r\n        }\r\n        onSuccess(data, xhr, callback);\r\n      } else {\r\n        onError(xhr, callback);\r\n      }\r\n    };\r\n\r\n    if (options.timeout > 0) {\r\n      timer = setTimeout(abortReq, options.timeout);\r\n      xhr.onprogress = function () {\r\n        clearTimeout(timer);\r\n        timer = setTimeout(abortReq, options.timeout);\r\n      };\r\n      if (xhr.upload) { // does not exist in ie9\r\n        xhr.upload.onprogress = xhr.onprogress;\r\n      }\r\n    }\r\n    xhr.send(options.body);\r\n    return {abort: abortReq};\r\n\r\n  } else {\r\n\r\n    if (options.json) {\r\n      if (!options.binary) {\r\n        options.headers.Accept = 'application/json';\r\n      }\r\n      options.headers['Content-Type'] = options.headers['Content-Type'] ||\r\n        'application/json';\r\n    }\r\n\r\n    if (options.binary) {\r\n      options.encoding = null;\r\n      options.json = false;\r\n    }\r\n\r\n    if (!options.processData) {\r\n      options.json = false;\r\n    }\r\n\r\n    return request(options, function (err, response, body) {\r\n      if (err) {\r\n        err.status = response ? response.statusCode : 400;\r\n        return onError(err, callback);\r\n      }\r\n      var error;\r\n      var content_type = response.headers['content-type'];\r\n      var data = (body || '');\r\n\r\n      // CouchDB doesn't always return the right content-type for JSON data, so\r\n      // we check for ^{ and }$ (ignoring leading/trailing whitespace)\r\n      if (!options.binary && (options.json || !options.processData) &&\r\n          typeof data !== 'object' &&\r\n          (/json/.test(content_type) ||\r\n           (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\r\n        data = JSON.parse(data);\r\n      }\r\n\r\n      if (response.statusCode >= 200 && response.statusCode < 300) {\r\n        onSuccess(data, response, callback);\r\n      }\r\n      else {\r\n        if (options.binary) {\r\n          data = JSON.parse(data.toString());\r\n        }\r\n        if (data.reason === 'missing') {\r\n          error = errors.MISSING_DOC;\r\n        } else if (data.reason === 'no_db_file') {\r\n          error = errors.error(errors.DB_MISSING, data.reason);\r\n        } else if (data.error === 'conflict') {\r\n          error = errors.REV_CONFLICT;\r\n        } else {\r\n          error = errors.error(errors.UNKNOWN_ERROR, data.reason, data.error);\r\n        }\r\n        error.status = response.statusCode;\r\n        callback(error);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = ajax;\r\n\r\n}).call(this,_dereq_(\"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js\"))\r\n},{\"../deps/uuid\":12,\"../utils\":18,\"./blob.js\":7,\"./errors\":8,\"./extend.js\":10,\"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js\":23,\"request\":21}],7:[function(_dereq_,module,exports){\r\n(function (global){\r\n\"use strict\";\r\n\r\n//Abstracts constructing a Blob object, so it also works in older\r\n//browsers that don't support the native Blob constructor. (i.e.\r\n//old QtWebKit versions, at least).\r\nfunction createBlob(parts, properties) {\r\n  parts = parts || [];\r\n  properties = properties || {};\r\n  try {\r\n    return new Blob(parts, properties);\r\n  } catch (e) {\r\n    if (e.name !== \"TypeError\") {\r\n      throw e;\r\n    }\r\n    var BlobBuilder = global.BlobBuilder ||\r\n                      global.MSBlobBuilder ||\r\n                      global.MozBlobBuilder ||\r\n                      global.WebKitBlobBuilder;\r\n    var builder = new BlobBuilder();\r\n    for (var i = 0; i < parts.length; i += 1) {\r\n      builder.append(parts[i]);\r\n    }\r\n    return builder.getBlob(properties.type);\r\n  }\r\n}\r\n\r\nmodule.exports = createBlob;\r\n\r\n\r\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{}],8:[function(_dereq_,module,exports){\r\n\"use strict\";\r\n\r\nfunction PouchError(opts) {\r\n  this.status = opts.status;\r\n  this.name = opts.error;\r\n  this.message = opts.reason;\r\n  this.error = true;\r\n}\r\n\r\nPouchError.prototype__proto__ = Error.prototype;\r\n\r\nPouchError.prototype.toString = function () {\r\n  return JSON.stringify({\r\n    status: this.status,\r\n    name: this.name,\r\n    message: this.message\r\n  });\r\n};\r\n\r\nexports.UNAUTHORIZED = new PouchError({\r\n  status: 401,\r\n  error: 'unauthorized',\r\n  reason: \"Name or password is incorrect.\"\r\n});\r\nexports.MISSING_BULK_DOCS = new PouchError({\r\n  status: 400,\r\n  error: 'bad_request',\r\n  reason: \"Missing JSON list of 'docs'\"\r\n});\r\nexports.MISSING_DOC = new PouchError({\r\n  status: 404,\r\n  error: 'not_found',\r\n  reason: 'missing'\r\n});\r\nexports.REV_CONFLICT = new PouchError({\r\n  status: 409,\r\n  error: 'conflict',\r\n  reason: 'Document update conflict'\r\n});\r\nexports.INVALID_ID = new PouchError({\r\n  status: 400,\r\n  error: 'invalid_id',\r\n  reason: '_id field must contain a string'\r\n});\r\nexports.MISSING_ID = new PouchError({\r\n  status: 412,\r\n  error: 'missing_id',\r\n  reason: '_id is required for puts'\r\n});\r\nexports.RESERVED_ID = new PouchError({\r\n  status: 400,\r\n  error: 'bad_request',\r\n  reason: 'Only reserved document ids may start with underscore.'\r\n});\r\nexports.NOT_OPEN = new PouchError({\r\n  status: 412,\r\n  error: 'precondition_failed',\r\n  reason: 'Database not open so cannot close'\r\n});\r\nexports.UNKNOWN_ERROR = new PouchError({\r\n  status: 500,\r\n  error: 'unknown_error',\r\n  reason: 'Database encountered an unknown error'\r\n});\r\nexports.BAD_ARG = new PouchError({\r\n  status: 500,\r\n  error: 'badarg',\r\n  reason: 'Some query argument is invalid'\r\n});\r\nexports.INVALID_REQUEST = new PouchError({\r\n  status: 400,\r\n  error: 'invalid_request',\r\n  reason: 'Request was invalid'\r\n});\r\nexports.QUERY_PARSE_ERROR = new PouchError({\r\n  status: 400,\r\n  error: 'query_parse_error',\r\n  reason: 'Some query parameter is invalid'\r\n});\r\nexports.DOC_VALIDATION = new PouchError({\r\n  status: 500,\r\n  error: 'doc_validation',\r\n  reason: 'Bad special document member'\r\n});\r\nexports.BAD_REQUEST = new PouchError({\r\n  status: 400,\r\n  error: 'bad_request',\r\n  reason: 'Something wrong with the request'\r\n});\r\nexports.NOT_AN_OBJECT = new PouchError({\r\n  status: 400,\r\n  error: 'bad_request',\r\n  reason: 'Document must be a JSON object'\r\n});\r\nexports.DB_MISSING = new PouchError({\r\n  status: 404,\r\n  error: 'not_found',\r\n  reason: 'Database not found'\r\n});\r\nexports.IDB_ERROR = new PouchError({\r\n  status: 500,\r\n  error: 'indexed_db_went_bad',\r\n  reason: 'unknown'\r\n});\r\nexports.WSQ_ERROR = new PouchError({\r\n  status: 500,\r\n  error: 'web_sql_went_bad',\r\n  reason: 'unknown'\r\n});\r\nexports.LDB_ERROR = new PouchError({\r\n  status: 500,\r\n  error: 'levelDB_went_went_bad',\r\n  reason: 'unknown'\r\n});\r\nexports.FORBIDDEN = new PouchError({\r\n  status: 403,\r\n  error: 'forbidden',\r\n  reason: 'Forbidden by design doc validate_doc_update function'\r\n});\r\nexports.error = function (error, reason, name) {\r\n  function CustomPouchError(msg) {\r\n    this.message = reason;\r\n    if (name) {\r\n      this.name = name;\r\n    }\r\n  }\r\n  CustomPouchError.prototype = error;\r\n  return new CustomPouchError(reason);\r\n};\r\n\r\n},{}],9:[function(_dereq_,module,exports){\r\n// some small shims for es5 just for the features we commonly use\r\n// some of this is copied from\r\n// https://github.com/kriskowal/es5-shim/blob/master/es5-shim.js\r\n'use strict';\r\n\r\nif (!Object.keys) {\r\n  Object.keys = function keys(object) {\r\n\r\n    if ((typeof object !== 'object' &&\r\n         typeof object !== 'function') ||\r\n         object === null) {\r\n      throw new TypeError('Object.keys called on a non-object');\r\n    }\r\n\r\n    var mykeys = [];\r\n    for (var name in object) {\r\n      if (Object.prototype.hasOwnProperty.call(object, name)) {\r\n        mykeys.push(name);\r\n      }\r\n    }\r\n    return mykeys;\r\n  };\r\n}\r\n\r\nif (!Array.isArray) {\r\n  Array.isArray = function isArray(obj) {\r\n    return Object.prototype.toString.call(obj) === '[object Array]';\r\n  };\r\n}\r\n\r\nif (!('forEach' in Array.prototype)) {\r\n  Array.prototype.forEach = function (action, that /*opt*/) {\r\n    for (var i = 0, n = this.length; i < n; i++) {\r\n      if (i in this) {\r\n        action.call(that, this[i], i, this);\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nif (!('map' in Array.prototype)) {\r\n  Array.prototype.map = function (mapper, that /*opt*/) {\r\n    var other = new Array(this.length);\r\n    for (var i = 0, n = this.length; i < n; i++) {\r\n      if (i in this) {\r\n        other[i] = mapper.call(that, this[i], i, this);\r\n      }\r\n    }\r\n    return other;\r\n  };\r\n}\r\n\r\n},{}],10:[function(_dereq_,module,exports){\r\n\"use strict\";\r\n\r\n// Extends method\r\n// (taken from http://code.jquery.com/jquery-1.9.0.js)\r\n// Populate the class2type map\r\nvar class2type = {};\r\n\r\nvar types = [\"Boolean\", \"Number\", \"String\", \"Function\", \"Array\", \"Date\", \"RegExp\", \"Object\", \"Error\"];\r\nfor (var i = 0; i < types.length; i++) {\r\n  var typename = types[i];\r\n  class2type[\"[object \" + typename + \"]\"] = typename.toLowerCase();\r\n}\r\n\r\nvar core_toString = class2type.toString;\r\nvar core_hasOwn = class2type.hasOwnProperty;\r\n\r\nfunction type(obj) {\r\n  if (obj === null) {\r\n    return String(obj);\r\n  }\r\n  return typeof obj === \"object\" || typeof obj === \"function\" ?\r\n    class2type[core_toString.call(obj)] || \"object\" :\r\n    typeof obj;\r\n}\r\n\r\nfunction isWindow(obj) {\r\n  return obj !== null && obj === obj.window;\r\n}\r\n\r\nfunction isPlainObject(obj) {\r\n  // Must be an Object.\r\n  // Because of IE, we also have to check the presence of the constructor property.\r\n  // Make sure that DOM nodes and window objects don't pass through, as well\r\n  if (!obj || type(obj) !== \"object\" || obj.nodeType || isWindow(obj)) {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    // Not own constructor property must be Object\r\n    if (obj.constructor &&\r\n      !core_hasOwn.call(obj, \"constructor\") &&\r\n      !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\r\n      return false;\r\n    }\r\n  } catch ( e ) {\r\n    // IE8,9 Will throw exceptions on certain host objects #9897\r\n    return false;\r\n  }\r\n\r\n  // Own properties are enumerated firstly, so to speed up,\r\n  // if last one is own, then all properties are own.\r\n  var key;\r\n  for (key in obj) {}\r\n\r\n  return key === undefined || core_hasOwn.call(obj, key);\r\n}\r\n\r\n\r\nfunction isFunction(obj) {\r\n  return type(obj) === \"function\";\r\n}\r\n\r\nvar isArray = Array.isArray || function (obj) {\r\n  return type(obj) === \"array\";\r\n};\r\n\r\nfunction extend() {\r\n  var options, name, src, copy, copyIsArray, clone,\r\n    target = arguments[0] || {},\r\n    i = 1,\r\n    length = arguments.length,\r\n    deep = false;\r\n\r\n  // Handle a deep copy situation\r\n  if (typeof target === \"boolean\") {\r\n    deep = target;\r\n    target = arguments[1] || {};\r\n    // skip the boolean and the target\r\n    i = 2;\r\n  }\r\n\r\n  // Handle case when target is a string or something (possible in deep copy)\r\n  if (typeof target !== \"object\" && !isFunction(target)) {\r\n    target = {};\r\n  }\r\n\r\n  // extend jQuery itself if only one argument is passed\r\n  if (length === i) {\r\n    /* jshint validthis: true */\r\n    target = this;\r\n    --i;\r\n  }\r\n\r\n  for (; i < length; i++) {\r\n    // Only deal with non-null/undefined values\r\n    if ((options = arguments[i]) != null) {\r\n      // Extend the base object\r\n      for (name in options) {\r\n        //if (options.hasOwnProperty(name)) {\r\n        if (!(name in Object.prototype)) {\r\n\r\n          src = target[name];\r\n          copy = options[name];\r\n\r\n          // Prevent never-ending loop\r\n          if (target === copy) {\r\n            continue;\r\n          }\r\n\r\n          // Recurse if we're merging plain objects or arrays\r\n          if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\r\n            if (copyIsArray) {\r\n              copyIsArray = false;\r\n              clone = src && isArray(src) ? src : [];\r\n\r\n            } else {\r\n              clone = src && isPlainObject(src) ? src : {};\r\n            }\r\n\r\n            // Never move original objects, clone them\r\n            target[name] = extend(deep, clone, copy);\r\n\r\n          // Don't bring in undefined values\r\n          } else if (copy !== undefined) {\r\n            if (!(isArray(options) && isFunction(copy))) {\r\n              target[name] = copy;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Return the modified object\r\n  return target;\r\n}\r\n\r\n\r\nmodule.exports = extend;\r\n\r\n\r\n},{}],11:[function(_dereq_,module,exports){\r\n(function (process){\r\n\"use strict\";\r\n\r\n/**\r\n*\r\n*  MD5 (Message-Digest Algorithm)\r\n*\r\n*  For original source see http://www.webtoolkit.info/\r\n*  Download: 15.02.2009 from http://www.webtoolkit.info/javascript-md5.html\r\n*\r\n*  Licensed under CC-BY 2.0 License\r\n*  (http://creativecommons.org/licenses/by/2.0/uk/)\r\n*\r\n**/\r\nvar crypto = _dereq_('crypto');\r\n\r\nexports.MD5 = function (string) {\r\n  if (!process.browser) {\r\n    return crypto.createHash('md5').update(string).digest('hex');\r\n  }\r\n  function rotateLeft(lValue, iShiftBits) {\r\n    return (lValue<<iShiftBits) | (lValue>>>(32 - iShiftBits));\r\n  }\r\n\r\n  function addUnsigned(lX, lY) {\r\n    var lX4, lY4, lX8, lY8, lResult;\r\n    lX8 = (lX & 0x80000000);\r\n    lY8 = (lY & 0x80000000);\r\n    lX4 = (lX & 0x40000000);\r\n    lY4 = (lY & 0x40000000);\r\n    lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);\r\n    if (lX4 & lY4) {\r\n      return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\r\n    }\r\n    if (lX4 | lY4) {\r\n      if (lResult & 0x40000000) {\r\n        return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\r\n      } else {\r\n        return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\r\n      }\r\n    } else {\r\n      return (lResult ^ lX8 ^ lY8);\r\n    }\r\n  }\r\n\r\n  function f(x, y, z) { return (x & y) | ((~x) & z); }\r\n  function g(x, y, z) { return (x & z) | (y & (~z)); }\r\n  function h(x, y, z) { return (x ^ y ^ z); }\r\n  function i(x, y, z) { return (y ^ (x | (~z))); }\r\n\r\n  function ff(a, b, c, d, x, s, ac) {\r\n    a = addUnsigned(a, addUnsigned(addUnsigned(f(b, c, d), x), ac));\r\n    return addUnsigned(rotateLeft(a, s), b);\r\n  }\r\n\r\n  function gg(a, b, c, d, x, s, ac) {\r\n    a = addUnsigned(a, addUnsigned(addUnsigned(g(b, c, d), x), ac));\r\n    return addUnsigned(rotateLeft(a, s), b);\r\n  }\r\n\r\n  function hh(a, b, c, d, x, s, ac) {\r\n    a = addUnsigned(a, addUnsigned(addUnsigned(h(b, c, d), x), ac));\r\n    return addUnsigned(rotateLeft(a, s), b);\r\n  }\r\n\r\n  function ii(a, b, c, d, x, s, ac) {\r\n    a = addUnsigned(a, addUnsigned(addUnsigned(i(b, c, d), x), ac));\r\n    return addUnsigned(rotateLeft(a, s), b);\r\n  }\r\n\r\n  function convertToWordArray(string) {\r\n    var lWordCount;\r\n    var lMessageLength = string.length;\r\n    var lNumberOfWords_temp1 = lMessageLength + 8;\r\n    var lNumberOfWords_temp2 =\r\n      (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;\r\n    var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;\r\n    var lWordArray = new Array(lNumberOfWords - 1);\r\n    var lBytePosition = 0;\r\n    var lByteCount = 0;\r\n    while (lByteCount < lMessageLength) {\r\n      lWordCount = (lByteCount - (lByteCount % 4)) / 4;\r\n      lBytePosition = (lByteCount % 4) * 8;\r\n      lWordArray[lWordCount] = (lWordArray[lWordCount] |\r\n                               (string.charCodeAt(lByteCount)<<lBytePosition));\r\n      lByteCount++;\r\n    }\r\n    lWordCount = (lByteCount - (lByteCount % 4)) / 4;\r\n    lBytePosition = (lByteCount % 4) * 8;\r\n    lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\r\n    lWordArray[lNumberOfWords - 2] = lMessageLength<<3;\r\n    lWordArray[lNumberOfWords - 1] = lMessageLength>>>29;\r\n    return lWordArray;\r\n  }\r\n\r\n  function wordToHex(lValue) {\r\n    var   wordToHexValue = \"\",   wordToHexValue_temp = \"\", lByte, lCount;\r\n    for (lCount = 0;lCount <= 3;lCount++) {\r\n      lByte = (lValue>>>(lCount * 8)) & 255;\r\n      wordToHexValue_temp = \"0\" + lByte.toString(16);\r\n      wordToHexValue = wordToHexValue +\r\n                      wordToHexValue_temp.substr(\r\n                        wordToHexValue_temp.length - 2, 2\r\n                      );\r\n    }\r\n    return   wordToHexValue;\r\n  }\r\n\r\n  //**  function Utf8Encode(string) removed. Aready defined in pidcrypt_utils.js\r\n\r\n  var x = [];\r\n  var k, AA, BB, CC, DD, a, b, c, d;\r\n  var S11 = 7, S12 = 12, S13 = 17, S14 = 22;\r\n  var S21 = 5, S22 = 9,  S23 = 14, S24 = 20;\r\n  var S31 = 4, S32 = 11, S33 = 16, S34 = 23;\r\n  var S41 = 6, S42 = 10, S43 = 15, S44 = 21;\r\n\r\n  //  string = Utf8Encode(string); #function call removed\r\n\r\n  x = convertToWordArray(string);\r\n\r\n  a = 0x67452301;\r\n  b = 0xEFCDAB89;\r\n  c = 0x98BADCFE;\r\n  d = 0x10325476;\r\n\r\n  for (k = 0;k < x.length;k += 16) {\r\n    AA = a;\r\n    BB = b;\r\n    CC = c;\r\n    DD = d;\r\n    a = ff(a, b, c, d, x[k + 0],  S11, 0xD76AA478);\r\n    d = ff(d, a, b, c, x[k + 1],  S12, 0xE8C7B756);\r\n    c = ff(c, d, a, b, x[k + 2],  S13, 0x242070DB);\r\n    b = ff(b, c, d, a, x[k + 3],  S14, 0xC1BDCEEE);\r\n    a = ff(a, b, c, d, x[k + 4],  S11, 0xF57C0FAF);\r\n    d = ff(d, a, b, c, x[k + 5],  S12, 0x4787C62A);\r\n    c = ff(c, d, a, b, x[k + 6],  S13, 0xA8304613);\r\n    b = ff(b, c, d, a, x[k + 7],  S14, 0xFD469501);\r\n    a = ff(a, b, c, d, x[k + 8],  S11, 0x698098D8);\r\n    d = ff(d, a, b, c, x[k + 9],  S12, 0x8B44F7AF);\r\n    c = ff(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);\r\n    b = ff(b, c, d, a, x[k + 11], S14, 0x895CD7BE);\r\n    a = ff(a, b, c, d, x[k + 12], S11, 0x6B901122);\r\n    d = ff(d, a, b, c, x[k + 13], S12, 0xFD987193);\r\n    c = ff(c, d, a, b, x[k + 14], S13, 0xA679438E);\r\n    b = ff(b, c, d, a, x[k + 15], S14, 0x49B40821);\r\n    a = gg(a, b, c, d, x[k + 1],  S21, 0xF61E2562);\r\n    d = gg(d, a, b, c, x[k + 6],  S22, 0xC040B340);\r\n    c = gg(c, d, a, b, x[k + 11], S23, 0x265E5A51);\r\n    b = gg(b, c, d, a, x[k + 0],  S24, 0xE9B6C7AA);\r\n    a = gg(a, b, c, d, x[k + 5],  S21, 0xD62F105D);\r\n    d = gg(d, a, b, c, x[k + 10], S22, 0x2441453);\r\n    c = gg(c, d, a, b, x[k + 15], S23, 0xD8A1E681);\r\n    b = gg(b, c, d, a, x[k + 4],  S24, 0xE7D3FBC8);\r\n    a = gg(a, b, c, d, x[k + 9],  S21, 0x21E1CDE6);\r\n    d = gg(d, a, b, c, x[k + 14], S22, 0xC33707D6);\r\n    c = gg(c, d, a, b, x[k + 3],  S23, 0xF4D50D87);\r\n    b = gg(b, c, d, a, x[k + 8],  S24, 0x455A14ED);\r\n    a = gg(a, b, c, d, x[k + 13], S21, 0xA9E3E905);\r\n    d = gg(d, a, b, c, x[k + 2],  S22, 0xFCEFA3F8);\r\n    c = gg(c, d, a, b, x[k + 7],  S23, 0x676F02D9);\r\n    b = gg(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);\r\n    a = hh(a, b, c, d, x[k + 5],  S31, 0xFFFA3942);\r\n    d = hh(d, a, b, c, x[k + 8],  S32, 0x8771F681);\r\n    c = hh(c, d, a, b, x[k + 11], S33, 0x6D9D6122);\r\n    b = hh(b, c, d, a, x[k + 14], S34, 0xFDE5380C);\r\n    a = hh(a, b, c, d, x[k + 1],  S31, 0xA4BEEA44);\r\n    d = hh(d, a, b, c, x[k + 4],  S32, 0x4BDECFA9);\r\n    c = hh(c, d, a, b, x[k + 7],  S33, 0xF6BB4B60);\r\n    b = hh(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);\r\n    a = hh(a, b, c, d, x[k + 13], S31, 0x289B7EC6);\r\n    d = hh(d, a, b, c, x[k + 0],  S32, 0xEAA127FA);\r\n    c = hh(c, d, a, b, x[k + 3],  S33, 0xD4EF3085);\r\n    b = hh(b, c, d, a, x[k + 6],  S34, 0x4881D05);\r\n    a = hh(a, b, c, d, x[k + 9],  S31, 0xD9D4D039);\r\n    d = hh(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);\r\n    c = hh(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);\r\n    b = hh(b, c, d, a, x[k + 2],  S34, 0xC4AC5665);\r\n    a = ii(a, b, c, d, x[k + 0],  S41, 0xF4292244);\r\n    d = ii(d, a, b, c, x[k + 7],  S42, 0x432AFF97);\r\n    c = ii(c, d, a, b, x[k + 14], S43, 0xAB9423A7);\r\n    b = ii(b, c, d, a, x[k + 5],  S44, 0xFC93A039);\r\n    a = ii(a, b, c, d, x[k + 12], S41, 0x655B59C3);\r\n    d = ii(d, a, b, c, x[k + 3],  S42, 0x8F0CCC92);\r\n    c = ii(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);\r\n    b = ii(b, c, d, a, x[k + 1],  S44, 0x85845DD1);\r\n    a = ii(a, b, c, d, x[k + 8],  S41, 0x6FA87E4F);\r\n    d = ii(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);\r\n    c = ii(c, d, a, b, x[k + 6],  S43, 0xA3014314);\r\n    b = ii(b, c, d, a, x[k + 13], S44, 0x4E0811A1);\r\n    a = ii(a, b, c, d, x[k + 4],  S41, 0xF7537E82);\r\n    d = ii(d, a, b, c, x[k + 11], S42, 0xBD3AF235);\r\n    c = ii(c, d, a, b, x[k + 2],  S43, 0x2AD7D2BB);\r\n    b = ii(b, c, d, a, x[k + 9],  S44, 0xEB86D391);\r\n    a = addUnsigned(a, AA);\r\n    b = addUnsigned(b, BB);\r\n    c = addUnsigned(c, CC);\r\n    d = addUnsigned(d, DD);\r\n  }\r\n  var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);\r\n  return temp.toLowerCase();\r\n};\r\n\r\n}).call(this,_dereq_(\"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js\"))\r\n},{\"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js\":23,\"crypto\":20}],12:[function(_dereq_,module,exports){\r\n\"use strict\";\r\n\r\n// BEGIN Math.uuid.js\r\n\r\n/*!\r\nMath.uuid.js (v1.4)\r\nhttp://www.broofa.com\r\nmailto:robert@broofa.com\r\n\r\nCopyright (c) 2010 Robert Kieffer\r\nDual licensed under the MIT and GPL licenses.\r\n*/\r\n\r\n/*\r\n * Generate a random uuid.\r\n *\r\n * USAGE: Math.uuid(length, radix)\r\n *   length - the desired number of characters\r\n *   radix  - the number of allowable values for each character.\r\n *\r\n * EXAMPLES:\r\n *   // No arguments  - returns RFC4122, version 4 ID\r\n *   >>> Math.uuid()\r\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\r\n *\r\n *   // One argument - returns ID of the specified length\r\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\r\n *   \"VcydxgltxrVZSTV\"\r\n *\r\n *   // Two arguments - returns ID of the specified length, and radix.\r\n *   // (Radix must be <= 62)\r\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\r\n *   \"01001010\"\r\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\r\n *   \"47473046\"\r\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\r\n *   \"098F4D35\"\r\n */\r\n\r\n\r\nfunction uuid(len, radix) {\r\n  var chars = uuid.CHARS;\r\n  var uuidInner = [];\r\n  var i;\r\n\r\n  radix = radix || chars.length;\r\n\r\n  if (len) {\r\n    // Compact form\r\n    for (i = 0; i < len; i++) {\r\n      uuidInner[i] = chars[0 | Math.random() * radix];\r\n    }\r\n  } else {\r\n    // rfc4122, version 4 form\r\n    var r;\r\n\r\n    // rfc4122 requires these characters\r\n    uuidInner[8] = uuidInner[13] = uuidInner[18] = uuidInner[23] = '-';\r\n    uuidInner[14] = '4';\r\n\r\n    // Fill in random data.  At i==19 set the high bits of clock sequence as\r\n    // per rfc4122, sec. 4.1.5\r\n    for (i = 0; i < 36; i++) {\r\n      if (!uuidInner[i]) {\r\n        r = 0 | Math.random() * 16;\r\n        uuidInner[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];\r\n      }\r\n    }\r\n  }\r\n\r\n  return uuidInner.join('');\r\n}\r\n\r\nuuid.CHARS = (\r\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\r\n  'abcdefghijklmnopqrstuvwxyz'\r\n).split('');\r\n\r\nmodule.exports = uuid;\r\n\r\n\r\n},{}],13:[function(_dereq_,module,exports){\r\n(function (process){\r\n\"use strict\";\r\n\r\n_dereq_('./deps/es5_shims');\r\n\r\nvar PouchDB = _dereq_('./setup');\r\n\r\nmodule.exports = PouchDB;\r\n\r\nPouchDB.ajax = _dereq_('./deps/ajax');\r\nPouchDB.extend = _dereq_('./deps/extend');\r\nPouchDB.utils = _dereq_('./utils');\r\nPouchDB.Errors = _dereq_('./deps/errors');\r\nvar replicate = _dereq_('./replicate');\r\nPouchDB.replicate = replicate.replicate;\r\nPouchDB.sync = replicate.sync;\r\nPouchDB.version = _dereq_('./version');\r\nvar httpAdapter = _dereq_('./adapters/http');\r\nPouchDB.adapter('http', httpAdapter);\r\nPouchDB.adapter('https', httpAdapter);\r\n\r\nPouchDB.adapter('idb', _dereq_('./adapters/idb'));\r\nPouchDB.adapter('websql', _dereq_('./adapters/websql'));\r\nPouchDB.plugin(_dereq_('pouchdb-mapreduce'));\r\n\r\nif (!process.browser) {\r\n  var ldbAdapter = _dereq_('./adapters/leveldb');\r\n  PouchDB.adapter('ldb', ldbAdapter);\r\n  PouchDB.adapter('leveldb', ldbAdapter);\r\n}\r\n\r\n}).call(this,_dereq_(\"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js\"))\r\n},{\"./adapters/http\":2,\"./adapters/idb\":3,\"./adapters/websql\":4,\"./deps/ajax\":6,\"./deps/errors\":8,\"./deps/es5_shims\":9,\"./deps/extend\":10,\"./replicate\":15,\"./setup\":16,\"./utils\":18,\"./version\":19,\"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js\":23,\"pouchdb-mapreduce\":43}],14:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nvar extend = _dereq_('./deps/extend');\r\n\r\n\r\n// for a better overview of what this is doing, read:\r\n// https://github.com/apache/couchdb/blob/master/src/couchdb/couch_key_tree.erl\r\n//\r\n// But for a quick intro, CouchDB uses a revision tree to store a documents\r\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\r\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\r\n//\r\n// KeyTree = [Path ... ]\r\n// Path = {pos: position_from_root, ids: Tree}\r\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\r\n\r\n// Turn a path as a flat array into a tree with a single branch\r\nfunction pathToTree(path) {\r\n  var doc = path.shift();\r\n  var root = [doc.id, doc.opts, []];\r\n  var leaf = root;\r\n  var nleaf;\r\n\r\n  while (path.length) {\r\n    doc = path.shift();\r\n    nleaf = [doc.id, doc.opts, []];\r\n    leaf[2].push(nleaf);\r\n    leaf = nleaf;\r\n  }\r\n  return root;\r\n}\r\n\r\n// Merge two trees together\r\n// The roots of tree1 and tree2 must be the same revision\r\nfunction mergeTree(in_tree1, in_tree2) {\r\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\r\n  var conflicts = false;\r\n  while (queue.length > 0) {\r\n    var item = queue.pop();\r\n    var tree1 = item.tree1;\r\n    var tree2 = item.tree2;\r\n\r\n    if (tree1[1].status || tree2[1].status) {\r\n      tree1[1].status = (tree1[1].status ===  'available' ||\r\n                         tree2[1].status === 'available') ? 'available' : 'missing';\r\n    }\r\n\r\n    for (var i = 0; i < tree2[2].length; i++) {\r\n      if (!tree1[2][0]) {\r\n        conflicts = 'new_leaf';\r\n        tree1[2][0] = tree2[2][i];\r\n        continue;\r\n      }\r\n\r\n      var merged = false;\r\n      for (var j = 0; j < tree1[2].length; j++) {\r\n        if (tree1[2][j][0] === tree2[2][i][0]) {\r\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\r\n          merged = true;\r\n        }\r\n      }\r\n      if (!merged) {\r\n        conflicts = 'new_branch';\r\n        tree1[2].push(tree2[2][i]);\r\n        tree1[2].sort();\r\n      }\r\n    }\r\n  }\r\n  return {conflicts: conflicts, tree: in_tree1};\r\n}\r\n\r\nfunction doMerge(tree, path, dontExpand) {\r\n  var restree = [];\r\n  var conflicts = false;\r\n  var merged = false;\r\n  var res;\r\n\r\n  if (!tree.length) {\r\n    return {tree: [path], conflicts: 'new_leaf'};\r\n  }\r\n\r\n  tree.forEach(function (branch) {\r\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\r\n      // Paths start at the same position and have the same root, so they need\r\n      // merged\r\n      res = mergeTree(branch.ids, path.ids);\r\n      restree.push({pos: branch.pos, ids: res.tree});\r\n      conflicts = conflicts || res.conflicts;\r\n      merged = true;\r\n    } else if (dontExpand !== true) {\r\n      // The paths start at a different position, take the earliest path and\r\n      // traverse up until it as at the same point from root as the path we want to\r\n      // merge.  If the keys match we return the longer path with the other merged\r\n      // After stemming we dont want to expand the trees\r\n\r\n      var t1 = branch.pos < path.pos ? branch : path;\r\n      var t2 = branch.pos < path.pos ? path : branch;\r\n      var diff = t2.pos - t1.pos;\r\n\r\n      var candidateParents = [];\r\n\r\n      var trees = [];\r\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\r\n      while (trees.length > 0) {\r\n        var item = trees.pop();\r\n        if (item.diff === 0) {\r\n          if (item.ids[0] === t2.ids[0]) {\r\n            candidateParents.push(item);\r\n          }\r\n          continue;\r\n        }\r\n        if (!item.ids) {\r\n          continue;\r\n        }\r\n        /*jshint loopfunc:true */\r\n        item.ids[2].forEach(function (el, idx) {\r\n          trees.push({ids: el, diff: item.diff - 1, parent: item.ids, parentIdx: idx});\r\n        });\r\n      }\r\n\r\n      var el = candidateParents[0];\r\n\r\n      if (!el) {\r\n        restree.push(branch);\r\n      } else {\r\n        res = mergeTree(el.ids, t2.ids);\r\n        el.parent[2][el.parentIdx] = res.tree;\r\n        restree.push({pos: t1.pos, ids: t1.ids});\r\n        conflicts = conflicts || res.conflicts;\r\n        merged = true;\r\n      }\r\n    } else {\r\n      restree.push(branch);\r\n    }\r\n  });\r\n\r\n  // We didnt find\r\n  if (!merged) {\r\n    restree.push(path);\r\n  }\r\n\r\n  restree.sort(function (a, b) {\r\n    return a.pos - b.pos;\r\n  });\r\n\r\n  return {\r\n    tree: restree,\r\n    conflicts: conflicts || 'internal_node'\r\n  };\r\n}\r\n\r\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\r\nfunction stem(tree, depth) {\r\n  // First we break out the tree into a complete list of root to leaf paths,\r\n  // we cut off the start of the path and generate a new set of flat trees\r\n  var stemmedPaths = PouchMerge.rootToLeaf(tree).map(function (path) {\r\n    var stemmed = path.ids.slice(-depth);\r\n    return {\r\n      pos: path.pos + (path.ids.length - stemmed.length),\r\n      ids: pathToTree(stemmed)\r\n    };\r\n  });\r\n  // Then we remerge all those flat trees together, ensuring that we dont\r\n  // connect trees that would go beyond the depth limit\r\n  return stemmedPaths.reduce(function (prev, current, i, arr) {\r\n    return doMerge(prev, current, true).tree;\r\n  }, [stemmedPaths.shift()]);\r\n}\r\n\r\nvar PouchMerge = {};\r\n\r\nPouchMerge.merge = function (tree, path, depth) {\r\n  // Ugh, nicer way to not modify arguments in place?\r\n  tree = extend(true, [], tree);\r\n  path = extend(true, {}, path);\r\n  var newTree = doMerge(tree, path);\r\n  return {\r\n    tree: stem(newTree.tree, depth),\r\n    conflicts: newTree.conflicts\r\n  };\r\n};\r\n\r\n// We fetch all leafs of the revision tree, and sort them based on tree length\r\n// and whether they were deleted, undeleted documents with the longest revision\r\n// tree (most edits) win\r\n// The final sort algorithm is slightly documented in a sidebar here:\r\n// http://guide.couchdb.org/draft/conflicts.html\r\nPouchMerge.winningRev = function (metadata) {\r\n  var leafs = [];\r\n  PouchMerge.traverseRevTree(metadata.rev_tree,\r\n                              function (isLeaf, pos, id, something, opts) {\r\n    if (isLeaf) {\r\n      leafs.push({pos: pos, id: id, deleted: !!opts.deleted});\r\n    }\r\n  });\r\n  leafs.sort(function (a, b) {\r\n    if (a.deleted !== b.deleted) {\r\n      return a.deleted > b.deleted ? 1 : -1;\r\n    }\r\n    if (a.pos !== b.pos) {\r\n      return b.pos - a.pos;\r\n    }\r\n    return a.id < b.id ? 1 : -1;\r\n  });\r\n\r\n  return leafs[0].pos + '-' + leafs[0].id;\r\n};\r\n\r\n// Pretty much all below can be combined into a higher order function to\r\n// traverse revisions\r\n// The return value from the callback will be passed as context to all\r\n// children of that node\r\nPouchMerge.traverseRevTree = function (revs, callback) {\r\n  var toVisit = [];\r\n\r\n  revs.forEach(function (tree) {\r\n    toVisit.push({pos: tree.pos, ids: tree.ids});\r\n  });\r\n  while (toVisit.length > 0) {\r\n    var node = toVisit.pop();\r\n    var pos = node.pos;\r\n    var tree = node.ids;\r\n    var newCtx = callback(tree[2].length === 0, pos, tree[0], node.ctx, tree[1]);\r\n    /*jshint loopfunc: true */\r\n    tree[2].forEach(function (branch) {\r\n      toVisit.push({pos: pos + 1, ids: branch, ctx: newCtx});\r\n    });\r\n  }\r\n};\r\n\r\nPouchMerge.collectLeaves = function (revs) {\r\n  var leaves = [];\r\n  PouchMerge.traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\r\n    if (isLeaf) {\r\n      leaves.unshift({rev: pos + \"-\" + id, pos: pos, opts: opts});\r\n    }\r\n  });\r\n  leaves.sort(function (a, b) {\r\n    return b.pos - a.pos;\r\n  });\r\n  leaves.map(function (leaf) { delete leaf.pos; });\r\n  return leaves;\r\n};\r\n\r\n// returns revs of all conflicts that is leaves such that\r\n// 1. are not deleted and\r\n// 2. are different than winning revision\r\nPouchMerge.collectConflicts = function (metadata) {\r\n  var win = PouchMerge.winningRev(metadata);\r\n  var leaves = PouchMerge.collectLeaves(metadata.rev_tree);\r\n  var conflicts = [];\r\n  leaves.forEach(function (leaf) {\r\n    if (leaf.rev !== win && !leaf.opts.deleted) {\r\n      conflicts.push(leaf.rev);\r\n    }\r\n  });\r\n  return conflicts;\r\n};\r\n\r\nPouchMerge.rootToLeaf = function (tree) {\r\n  var paths = [];\r\n  PouchMerge.traverseRevTree(tree, function (isLeaf, pos, id, history, opts) {\r\n    history = history ? history.slice(0) : [];\r\n    history.push({id: id, opts: opts});\r\n    if (isLeaf) {\r\n      var rootPos = pos + 1 - history.length;\r\n      paths.unshift({pos: rootPos, ids: history});\r\n    }\r\n    return history;\r\n  });\r\n  return paths;\r\n};\r\n\r\n\r\nmodule.exports = PouchMerge;\r\n\r\n},{\"./deps/extend\":10}],15:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nvar PouchUtils = _dereq_('./utils');\r\nvar Pouch = _dereq_('./index');\r\n\r\n// We create a basic promise so the caller can cancel the replication possibly\r\n// before we have actually started listening to changes etc\r\nfunction Promise() {\r\n  var that = this;\r\n  this.cancelled = false;\r\n  this.cancel = function () {\r\n    that.cancelled = true;\r\n  };\r\n}\r\n\r\n\r\n// A batch of changes to be processed as a unit\r\nfunction Batch() {\r\n  this.seq = 0;\r\n  this.changes = [];\r\n  this.docs = [];\r\n}\r\n\r\n\r\n// TODO: check CouchDB's replication id generation\r\n// Generate a unique id particular to this replication\r\nfunction genReplicationId(src, target, opts, callback) {\r\n  var filterFun = opts.filter ? opts.filter.toString() : '';\r\n  src.id(function (err, src_id) {\r\n    target.id(function (err, target_id) {\r\n      var queryData = src_id + target_id + filterFun +\r\n        JSON.stringify(opts.query_params) + opts.doc_ids;\r\n      callback('_local/' + PouchUtils.Crypto.MD5(queryData));\r\n    });\r\n  });\r\n}\r\n\r\n\r\n// A checkpoint lets us restart replications from when they were last cancelled\r\nfunction fetchCheckpoint(src, target, id, callback) {\r\n  target.get(id, function (err, targetDoc) {\r\n    if (err && err.status === 404) {\r\n      callback(null, 0);\r\n    } else if (err) {\r\n      callback(err);\r\n    } else {\r\n      src.get(id, function (err, sourceDoc) {\r\n        if (err && err.status === 404 ||\r\n            (!err && (targetDoc.last_seq !== sourceDoc.last_seq))) {\r\n          callback(null, 0);\r\n        } else if (err) {\r\n          callback(err);\r\n        } else {\r\n          callback(null, sourceDoc.last_seq);\r\n        }\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n\r\nfunction writeCheckpoint(src, target, id, checkpoint, callback) {\r\n  function updateCheckpoint(db, callback) {\r\n    db.get(id, function (err, doc) {\r\n      if (err && err.status === 404) {\r\n        doc = {_id: id};\r\n      } else if (err) {\r\n        return callback(err);\r\n      }\r\n      doc.last_seq = checkpoint;\r\n      db.put(doc, callback);\r\n    });\r\n  }\r\n  updateCheckpoint(target, function (err, doc) {\r\n    if (err) { return callback(err); }\r\n    updateCheckpoint(src, function (err, doc) {\r\n      if (err) { return callback(err); }\r\n      callback();\r\n    });\r\n  });\r\n}\r\n\r\n\r\nfunction replicate(repId, src, target, opts, promise) {\r\n  var batches = [];               // list of batches to be processed\r\n  var currentBatch;               // the batch currently being processed\r\n  var pendingBatch = new Batch(); // next batch, not yet ready to be processed\r\n  var fetchAgain = [];  // queue of documents to be fetched again with api.get\r\n  var writingCheckpoint = false;\r\n  var changesCompleted = false;\r\n  var completeCalled = false;\r\n  var last_seq = 0;\r\n  var continuous = opts.continuous || opts.live || false;\r\n  var batch_size = opts.batch_size || 1;\r\n  var doc_ids = opts.doc_ids;\r\n  var result = {\r\n    ok: true,\r\n    start_time: new Date(),\r\n    docs_read: 0,\r\n    docs_written: 0,\r\n    doc_write_failures: 0,\r\n    errors: []\r\n  };\r\n\r\n\r\n  function writeDocs() {\r\n    if (currentBatch.docs.length === 0) {\r\n      // This should never happen:\r\n      // batch processing continues past onRevsDiff only if there are diffs\r\n      // and replication is aborted if a get fails.\r\n      // TODO: throw or log the error\r\n      return finishBatch();\r\n    }\r\n\r\n    var docs = currentBatch.docs;\r\n    target.bulkDocs({docs: docs}, {new_edits: false}, function (err, res) {\r\n      if (err) {\r\n        result.doc_write_failures += docs.length;\r\n        return abortReplication('target.bulkDocs completed with error', err);\r\n      }\r\n\r\n      var errors = [];\r\n      res.forEach(function (res) {\r\n        if (!res.ok) {\r\n          result.doc_write_failures++;\r\n          errors.push({\r\n            status: 500,\r\n            error: res.error || 'Unknown document write error',\r\n            reason: res.reason || 'Unknown reason',\r\n          });\r\n        }\r\n      });\r\n\r\n      if (errors.length > 0) {\r\n        return abortReplication('target.bulkDocs failed to write docs', errors);\r\n      }\r\n\r\n      result.docs_written += docs.length;\r\n      finishBatch();\r\n    });\r\n  }\r\n\r\n\r\n  function onGet(err, docs) {\r\n    if (promise.cancelled) {\r\n      return replicationComplete();\r\n    }\r\n\r\n    if (err) {\r\n      return abortReplication('src.get completed with error', err);\r\n    }\r\n\r\n    Object.keys(docs).forEach(function (revpos) {\r\n      var doc = docs[revpos].ok;\r\n\r\n      if (doc) {\r\n        result.docs_read++;\r\n        currentBatch.pendingRevs++;\r\n        currentBatch.docs.push(doc);\r\n      }\r\n    });\r\n\r\n    fetchRev();\r\n  }\r\n\r\n  function fetchGenerationOneRevs(ids, revs) {\r\n    src.allDocs({keys: ids, include_docs: true}, function (err, res) {\r\n      if (promise.cancelled) {\r\n        return replicationComplete();\r\n      }\r\n      if (err) {\r\n        return abortReplication('src.get completed with error', err);\r\n      }\r\n\r\n      res.rows.forEach(function (row, i) {\r\n        // fetch document again via api.get when doc\r\n        // * is deleted document (could have data)\r\n        // * is no longer generation 1\r\n        // * has attachments\r\n        var needsSingleFetch = !row.doc ||\r\n          row.value.rev.slice(0, 2) !== '1-' ||\r\n          row.doc._attachments && Object.keys(row.doc._attachments).length;\r\n\r\n        if (needsSingleFetch) {\r\n          return fetchAgain.push({\r\n            id: row.error === 'not_found' ? row.key : row.id,\r\n            rev: revs[i]\r\n          });\r\n        }\r\n\r\n        result.docs_read++;\r\n        currentBatch.pendingRevs++;\r\n        currentBatch.docs.push(row.doc);\r\n      });\r\n\r\n      fetchRev();\r\n    });\r\n  }\r\n\r\n  function fetchRev() {\r\n    if (fetchAgain.length) {\r\n      var doc = fetchAgain.shift();\r\n      return fetchSingleRev(src, onGet, doc.id, [doc.rev]);\r\n    }\r\n\r\n    var diffs = currentBatch.diffs;\r\n\r\n    if (Object.keys(diffs).length === 0) {\r\n      writeDocs();\r\n      return;\r\n    }\r\n\r\n    var generationOne = Object.keys(diffs).reduce(function (memo, id) {\r\n      if (diffs[id].missing.length === 1 && diffs[id].missing[0].slice(0, 2) === '1-') {\r\n        memo.ids.push(id);\r\n        memo.revs.push(diffs[id].missing[0]);\r\n        delete diffs[id];\r\n      }\r\n\r\n      return memo;\r\n    }, {\r\n      ids: [],\r\n      revs: []\r\n    });\r\n\r\n    if (generationOne.ids.length) {\r\n      return fetchGenerationOneRevs(generationOne.ids, generationOne.revs);\r\n    }\r\n\r\n    var id = Object.keys(diffs)[0];\r\n    var revs = diffs[id].missing;\r\n    delete diffs[id];\r\n\r\n    fetchSingleRev(src, onGet, id, revs);\r\n  }\r\n\r\n\r\n  function abortReplication(reason, err) {\r\n    if (completeCalled) {\r\n      return;\r\n    }\r\n    result.ok = false;\r\n    result.status = 'aborted';\r\n    result.errors.push(err);\r\n    result.end_time = new Date();\r\n    result.last_seq = last_seq;\r\n    batches = [];\r\n    pendingBatch = new Batch();\r\n    var error = {\r\n      status: 500,\r\n      error: 'Replication aborted',\r\n      reason: reason,\r\n      details: err\r\n    };\r\n    completeCalled = true;\r\n    PouchUtils.call(opts.complete, error, result);\r\n    promise.cancel();\r\n  }\r\n\r\n\r\n  function finishBatch() {\r\n    writingCheckpoint = true;\r\n    writeCheckpoint(src, target, repId, currentBatch.seq, function (err, res) {\r\n      writingCheckpoint = false;\r\n      if (promise.cancelled) {\r\n        return replicationComplete();\r\n      }\r\n      if (err) {\r\n        return abortReplication('writeCheckpoint completed with error', err);\r\n      }\r\n      result.last_seq = last_seq = currentBatch.seq;\r\n      PouchUtils.call(opts.onChange, null, result);\r\n      currentBatch = undefined;\r\n      startNextBatch();\r\n    });\r\n  }\r\n\r\n  function onRevsDiff(err, diffs) {\r\n    if (promise.cancelled) {\r\n      return replicationComplete();\r\n    }\r\n\r\n    if (err) {\r\n      return abortReplication('target.revsDiff completed with error', err);\r\n    }\r\n\r\n    if (Object.keys(diffs).length === 0) {\r\n      finishBatch();\r\n      return;\r\n    }\r\n\r\n    currentBatch.diffs = diffs;\r\n    currentBatch.pendingRevs = 0;\r\n    fetchRev();\r\n  }\r\n\r\n\r\n  function fetchRevsDiff() {\r\n    var diff = {};\r\n    currentBatch.changes.forEach(function (change) {\r\n      diff[change.id] = change.changes.map(function (x) { return x.rev; });\r\n    });\r\n\r\n    target.revsDiff(diff, onRevsDiff);\r\n  }\r\n\r\n\r\n  function startNextBatch() {\r\n    if (promise.cancelled) {\r\n      return replicationComplete();\r\n    }\r\n\r\n    if (currentBatch) {\r\n      return;\r\n    }\r\n\r\n    if (batches.length === 0) {\r\n      processPendingBatch();\r\n      return;\r\n    }\r\n\r\n    currentBatch = batches.shift();\r\n    fetchRevsDiff();\r\n  }\r\n\r\n\r\n  function processPendingBatch() {\r\n    if (pendingBatch.changes.length === 0) {\r\n      if (changesCompleted && batches.length === 0 && !currentBatch) {\r\n        replicationComplete();\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (changesCompleted || pendingBatch.changes.length >= batch_size) {\r\n      batches.push(pendingBatch);\r\n      pendingBatch = new Batch();\r\n      startNextBatch();\r\n    }\r\n  }\r\n\r\n\r\n  function replicationComplete() {\r\n    if (completeCalled) {\r\n      return;\r\n    }\r\n    if (promise.cancelled) {\r\n      result.status = 'cancelled';\r\n      if (writingCheckpoint) {\r\n        return;\r\n      }\r\n    }\r\n    result.status = result.status || 'complete';\r\n    result.end_time = new Date();\r\n    result.last_seq = last_seq;\r\n    completeCalled = true;\r\n    if (result.errors.length > 0) {\r\n      return PouchUtils.call(opts.complete, result.errors[0], result);\r\n    } else {\r\n      return PouchUtils.call(opts.complete, null, result);\r\n    }\r\n  }\r\n\r\n\r\n  function onChange(change) {\r\n    if (promise.cancelled) {\r\n      return replicationComplete();\r\n    }\r\n\r\n    if (completeCalled) {\r\n      // This should never happen\r\n      // The complete callback has already been called\r\n      // How to raise an exception in PouchDB?\r\n      return;\r\n    }\r\n\r\n    pendingBatch.seq = change.seq;\r\n    pendingBatch.changes.push(change);\r\n\r\n    processPendingBatch();\r\n  }\r\n\r\n\r\n  function complete(err, changes) {\r\n    changesCompleted = true;\r\n    if (promise.cancelled) {\r\n      return replicationComplete();\r\n    }\r\n\r\n    if (err) {\r\n      result.status = 'src.changes completed with error';\r\n      result.errors.push(err);\r\n    }\r\n\r\n    processPendingBatch();\r\n  }\r\n\r\n\r\n  function getChanges() {\r\n    fetchCheckpoint(src, target, repId, function (err, checkpoint) {\r\n      if (err) {\r\n        return abortReplication('fetchCheckpoint completed with error', err);\r\n      }\r\n\r\n      last_seq = checkpoint;\r\n\r\n      // Was the replication cancelled by the caller before it had a chance\r\n      // to start. Shouldnt we be calling complete?\r\n      if (promise.cancelled) {\r\n        return replicationComplete();\r\n      }\r\n\r\n      // Call changes on the source database, with callbacks to onChange for\r\n      // each change and complete when done.\r\n      var repOpts = {\r\n        continuous: continuous,\r\n        since: last_seq,\r\n        style: 'all_docs',\r\n        onChange: onChange,\r\n        complete: complete,\r\n        doc_ids: doc_ids\r\n      };\r\n\r\n      if (opts.filter) {\r\n        repOpts.filter = opts.filter;\r\n      }\r\n\r\n      if (opts.query_params) {\r\n        repOpts.query_params = opts.query_params;\r\n      }\r\n\r\n      var changes = src.changes(repOpts);\r\n\r\n      var cancelPromise = promise.cancel;\r\n      promise.cancel = function () {\r\n        cancelPromise();\r\n        replicationComplete();\r\n        if (changes && changes.cancel instanceof Function) {\r\n          changes.cancel();\r\n        }\r\n      };\r\n\r\n    });\r\n  }\r\n\r\n  // If opts.since is given, set the checkpoint to opts.since\r\n  if (typeof opts.since === 'undefined') {\r\n    getChanges();\r\n  } else {\r\n    writeCheckpoint(src, target, repId, opts.since, function (err, res) {\r\n      if (err) {\r\n        return abortReplication('writeCheckpoint completed with error', err);\r\n      }\r\n      last_seq = opts.since;\r\n      getChanges();\r\n    });\r\n  }\r\n}\r\n\r\nfunction fetchSingleRev(src, callback, id, revs) {\r\n  src.get(id, {revs: true, open_revs: revs, attachments: true}, callback);\r\n}\r\n\r\nfunction toPouch(db, callback) {\r\n  if (typeof db === 'string') {\r\n    return new Pouch(db, callback);\r\n  }\r\n  callback(null, db);\r\n}\r\n\r\nfunction replicateWrapper(src, target, opts, callback) {\r\n  if (opts instanceof Function) {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  if (opts === undefined) {\r\n    opts = {};\r\n  }\r\n  if (!opts.complete) {\r\n    opts.complete = callback;\r\n  }\r\n  opts = PouchUtils.extend(true, {}, opts);\r\n  opts.continuous = opts.continuous || opts.live;\r\n  var replicateRet = new Promise();\r\n  toPouch(src, function (err, src) {\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n    toPouch(target, function (err, target) {\r\n      if (err) {\r\n        return callback(err);\r\n      }\r\n      if (opts.server) {\r\n        if (typeof src.replicateOnServer !== 'function') {\r\n          return callback({\r\n            error: 'Server replication not supported for ' + src.type() +\r\n              'adapter'\r\n          });\r\n        }\r\n        if (src.type() !== target.type()) {\r\n          return callback({\r\n            error: 'Server replication for different adapter types (' +\r\n              src.type() + ' and ' + target.type() + ') is not supported'\r\n          });\r\n        }\r\n        src.replicateOnServer(target, opts, replicateRet);\r\n      } else {\r\n        genReplicationId(src, target, opts, function (repId) {\r\n          replicate(repId, src, target, opts, replicateRet);\r\n        });\r\n      }\r\n    });\r\n  });\r\n  return replicateRet;\r\n}\r\n\r\nfunction sync(db1, db2, opts, callback) {\r\n  var push_promise;\r\n  var pull_promise;\r\n\r\n  if (opts instanceof Function) {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  if (opts === undefined) {\r\n    opts = {};\r\n  }\r\n  if (callback instanceof Function && !opts.complete) {\r\n    opts.complete = callback;\r\n  }\r\n\r\n  function complete(callback, direction) {\r\n    return function (err, res) {\r\n      if (err) {\r\n        // cancel both replications if either experiences problems\r\n        cancel();\r\n      }\r\n      res.direction = direction;\r\n      callback(err, res);\r\n    };\r\n  }\r\n\r\n  function onChange(src, callback) {\r\n    callback = callback || function () {};\r\n    return function (change) {\r\n      return {\r\n        source: src,\r\n        change: callback(change)\r\n      };\r\n    };\r\n  }\r\n\r\n  function makeOpts(src, opts, direction) {\r\n    opts = PouchUtils.extend(true, {}, opts);\r\n    opts.complete = complete(opts.complete, direction);\r\n    opts.onChange = onChange(src, opts.onChange);\r\n    opts.continuous = opts.continuous || opts.live;\r\n    return opts;\r\n  }\r\n\r\n  function push() {\r\n    push_promise =\r\n      replicateWrapper(db1, db2, makeOpts(db1, opts, 'push'), callback);\r\n    return push_promise;\r\n  }\r\n\r\n  function pull() {\r\n    pull_promise =\r\n      replicateWrapper(db2, db1, makeOpts(db2, opts, 'pull'), callback);\r\n    return pull_promise;\r\n  }\r\n\r\n  function cancel() {\r\n    if (push_promise) {\r\n      push_promise.cancel();\r\n    }\r\n    if (pull_promise) {\r\n      pull_promise.cancel();\r\n    }\r\n  }\r\n\r\n  return {\r\n    push: push(),\r\n    pull: pull(),\r\n    cancel: cancel\r\n  };\r\n}\r\n\r\nexports.replicate = replicateWrapper;\r\nexports.sync = sync;\r\n\r\n},{\"./index\":13,\"./utils\":18}],16:[function(_dereq_,module,exports){\r\n(function (global){\r\n\"use strict\";\r\n\r\nvar PouchDB = _dereq_(\"./constructor\");\r\nvar utils = _dereq_('./utils');\r\nvar EventEmitter = _dereq_('events').EventEmitter;\r\nPouchDB.adapters = {};\r\n\r\nPouchDB.prefix = '_pouch_';\r\n\r\nvar eventEmitter = new EventEmitter();\r\n\r\nvar eventEmitterMethods = [\r\n  'on',\r\n  'addListener',\r\n  'emit',\r\n  'listeners',\r\n  'once',\r\n  'removeAllListeners',\r\n  'removeListener',\r\n  'setMaxListeners'\r\n];\r\n\r\nvar preferredAdapters = ['levelalt', 'idb', 'leveldb', 'websql'];\r\n\r\neventEmitterMethods.forEach(function (method) {\r\n  PouchDB[method] = eventEmitter[method].bind(eventEmitter);\r\n});\r\nPouchDB.setMaxListeners(0);\r\nPouchDB.parseAdapter = function (name, opts) {\r\n  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\r\n  var adapter, adapterName;\r\n  if (match) {\r\n    // the http adapter expects the fully qualified name\r\n    name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];\r\n    adapter = match[1];\r\n    if (!PouchDB.adapters[adapter].valid()) {\r\n      throw 'Invalid adapter';\r\n    }\r\n    return {name: name, adapter: match[1]};\r\n  }\r\n\r\n  // check for browsers that have been upgraded from websql-only to websql+idb\r\n  var skipIdb = 'idb' in PouchDB.adapters && 'websql' in PouchDB.adapters &&\r\n    utils.hasLocalStorage() &&\r\n    global.localStorage['_pouch__websqldb_' + PouchDB.prefix + name];\r\n\r\n  if (typeof opts !== 'undefined' && opts.db) {\r\n    adapterName = 'leveldb';\r\n  } else {\r\n    for (var i = 0; i < preferredAdapters.length; ++i) {\r\n      adapterName = preferredAdapters[i];\r\n      if (adapterName in PouchDB.adapters) {\r\n        if (skipIdb && adapterName === 'idb') {\r\n          continue; // keep using websql to avoid user data loss\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (adapterName) {\r\n    adapter = PouchDB.adapters[adapterName];\r\n    var use_prefix = 'use_prefix' in adapter ? adapter.use_prefix : true;\r\n\r\n    return {\r\n      name: use_prefix ? PouchDB.prefix + name : name,\r\n      adapter: adapterName\r\n    };\r\n  }\r\n\r\n  throw 'No valid adapter found';\r\n};\r\n\r\nPouchDB.destroy = utils.toPromise(function (name, opts, callback) {\r\n  if (typeof opts === 'function' || typeof opts === 'undefined') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n\r\n  if (typeof name === 'object') {\r\n    opts = name;\r\n    name = undefined;\r\n  }\r\n\r\n  var backend = PouchDB.parseAdapter(opts.name || name, opts);\r\n  var dbName = backend.name;\r\n\r\n  // call destroy method of the particular adaptor\r\n  PouchDB.adapters[backend.adapter].destroy(dbName, opts, function (err, resp) {\r\n    if (err) {\r\n      callback(err);\r\n    } else {\r\n      PouchDB.emit('destroyed', dbName);\r\n      //so we don't have to sift through all dbnames\r\n      PouchDB.emit(dbName, 'destroyed');\r\n      callback(null, resp);\r\n    }\r\n  });\r\n});\r\nPouchDB.allDbs = utils.toPromise(function (callback) {\r\n  var err = new Error('allDbs method removed');\r\n  err.stats = '400';\r\n  callback(err);\r\n});\r\nPouchDB.adapter = function (id, obj) {\r\n  if (obj.valid()) {\r\n    PouchDB.adapters[id] = obj;\r\n  }\r\n};\r\n\r\nPouchDB.plugin = function (obj) {\r\n  Object.keys(obj).forEach(function (id) {\r\n    PouchDB.prototype[id] = obj[id];\r\n  });\r\n};\r\n\r\nmodule.exports = PouchDB;\r\n\r\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{\"./constructor\":5,\"./utils\":18,\"events\":22}],17:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nmodule.exports = TaskQueue;\r\n\r\nfunction TaskQueue() {\r\n  this.isReady = false;\r\n  this.failed = false;\r\n  this.queue = [];\r\n}\r\n\r\nTaskQueue.prototype.execute = function () {\r\n  var d, func;\r\n  if (this.failed) {\r\n    while ((d = this.queue.shift())) {\r\n      func = d.parameters[d.parameters.length - 1];\r\n      if (typeof func === 'function') {\r\n        func(this.failed);\r\n      } else if (d.name === 'changes' && typeof func.complete === 'function') {\r\n        func.complete(this.failed);\r\n      }\r\n    }\r\n  } else if (this.isReady) {\r\n    while ((d = this.queue.shift())) {\r\n      if (typeof d === 'function') {\r\n        d();\r\n      } else {\r\n        d.task = this.db[d.name].apply(this.db, d.parameters);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nTaskQueue.prototype.fail = function (err) {\r\n  this.failed = err;\r\n  this.execute();\r\n};\r\n\r\nTaskQueue.prototype.ready = function (db) {\r\n  if (this.failed) {\r\n    return false;\r\n  } else if (arguments.length === 0) {\r\n    return this.isReady;\r\n  }\r\n  this.isReady = db ? true: false;\r\n  this.db = db;\r\n  this.execute();\r\n};\r\n\r\nTaskQueue.prototype.addTask = function (name, parameters) {\r\n  if (typeof name === 'function') {\r\n    this.queue.push(name);\r\n  } else {\r\n    var task = { name: name, parameters: parameters };\r\n    this.queue.push(task);\r\n    if (this.failed) {\r\n      this.execute();\r\n    }\r\n    return task;\r\n  }\r\n};\r\n\r\n},{}],18:[function(_dereq_,module,exports){\r\n(function (process,global){\r\n/*jshint strict: false */\r\n/*global chrome */\r\n\r\nvar merge = _dereq_('./merge');\r\nexports.extend = _dereq_('./deps/extend');\r\nexports.ajax = _dereq_('./deps/ajax');\r\nexports.createBlob = _dereq_('./deps/blob');\r\nvar uuid = _dereq_('./deps/uuid');\r\nexports.Crypto = _dereq_('./deps/md5.js');\r\nvar buffer = _dereq_('./deps/buffer');\r\nvar errors = _dereq_('./deps/errors');\r\nvar EventEmitter = _dereq_('events').EventEmitter;\r\nvar Promise = typeof global.Promise === 'function' ? global.Promise : _dereq_('bluebird');\r\n\r\n// List of top level reserved words for doc\r\nvar reservedWords = [\r\n  '_id',\r\n  '_rev',\r\n  '_attachments',\r\n  '_deleted',\r\n  '_revisions',\r\n  '_revs_info',\r\n  '_conflicts',\r\n  '_deleted_conflicts',\r\n  '_local_seq',\r\n  '_rev_tree'\r\n];\r\nexports.inherits = _dereq_('inherits');\r\nexports.uuids = function (count, options) {\r\n\r\n  if (typeof(options) !== 'object') {\r\n    options = {};\r\n  }\r\n\r\n  var length = options.length;\r\n  var radix = options.radix;\r\n  var uuids = [];\r\n\r\n  while (uuids.push(uuid(length, radix)) < count) { }\r\n\r\n  return uuids;\r\n};\r\n\r\n// Give back one UUID\r\nexports.uuid = function (options) {\r\n  return exports.uuids(1, options)[0];\r\n};\r\n// Determine id an ID is valid\r\n//   - invalid IDs begin with an underescore that does not begin '_design' or '_local'\r\n//   - any other string value is a valid id\r\n// Returns the specific error object for each case\r\nexports.invalidIdError = function (id) {\r\n  if (!id) {\r\n    return errors.MISSING_ID;\r\n  } else if (typeof id !== 'string') {\r\n    return errors.INVALID_ID;\r\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\r\n    return errors.RESERVED_ID;\r\n  }\r\n};\r\n\r\nfunction isChromeApp() {\r\n  return (typeof chrome !== \"undefined\" &&\r\n          typeof chrome.storage !== \"undefined\" &&\r\n          typeof chrome.storage.local !== \"undefined\");\r\n}\r\n\r\nexports.getArguments = function (fun) {\r\n  return function () {\r\n    var len = arguments.length;\r\n    var args = new Array(len);\r\n    var i = -1;\r\n    while (++i < len) {\r\n      args[i] = arguments[i];\r\n    }\r\n    return fun.call(this, args);\r\n  };\r\n};\r\n// Pretty dumb name for a function, just wraps callback calls so we dont\r\n// to if (callback) callback() everywhere\r\nexports.call = exports.getArguments(function (args) {\r\n  if (!args.length) {\r\n    return;\r\n  }\r\n  var fun = args.shift();\r\n  if (typeof fun === 'function') {\r\n    fun.apply(this, args);\r\n  }\r\n});\r\n\r\nexports.isLocalId = function (id) {\r\n  return (/^_local/).test(id);\r\n};\r\n\r\n// check if a specific revision of a doc has been deleted\r\n//  - metadata: the metadata object from the doc store\r\n//  - rev: (optional) the revision to check. defaults to winning revision\r\nexports.isDeleted = function (metadata, rev) {\r\n  if (!rev) {\r\n    rev = merge.winningRev(metadata);\r\n  }\r\n  if (rev.indexOf('-') >= 0) {\r\n    rev = rev.split('-')[1];\r\n  }\r\n  var deleted = false;\r\n  merge.traverseRevTree(metadata.rev_tree, function (isLeaf, pos, id, acc, opts) {\r\n    if (id === rev) {\r\n      deleted = !!opts.deleted;\r\n    }\r\n  });\r\n\r\n  return deleted;\r\n};\r\n\r\nexports.filterChange = function (opts) {\r\n  return function (change) {\r\n    var req = {};\r\n    var hasFilter = opts.filter && typeof opts.filter === 'function';\r\n\r\n    req.query = opts.query_params;\r\n    if (opts.filter && hasFilter && !opts.filter.call(this, change.doc, req)) {\r\n      return false;\r\n    }\r\n    if (opts.doc_ids && opts.doc_ids.indexOf(change.id) === -1) {\r\n      return false;\r\n    }\r\n    if (!opts.include_docs) {\r\n      delete change.doc;\r\n    } else {\r\n      for (var att in change.doc._attachments) {\r\n        if (change.doc._attachments.hasOwnProperty(att)) {\r\n          change.doc._attachments[att].stub = true;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n};\r\n\r\nexports.processChanges = function (opts, changes, last_seq) {\r\n  // TODO: we should try to filter and limit as soon as possible\r\n  changes = changes.filter(exports.filterChange(opts));\r\n  if (opts.limit) {\r\n    if (opts.limit < changes.length) {\r\n      changes.length = opts.limit;\r\n    }\r\n  }\r\n  changes.forEach(function (change) {\r\n    exports.call(opts.onChange, change);\r\n  });\r\n  if (!opts.continuous) {\r\n    exports.call(opts.complete, null, {results: changes, last_seq: last_seq});\r\n  }\r\n};\r\n\r\n// Preprocess documents, parse their revisions, assign an id and a\r\n// revision for new writes that are missing them, etc\r\nexports.parseDoc = function (doc, newEdits) {\r\n  var error = null;\r\n  var nRevNum;\r\n  var newRevId;\r\n  var revInfo;\r\n  var opts = {status: 'available'};\r\n  if (doc._deleted) {\r\n    opts.deleted = true;\r\n  }\r\n\r\n  if (newEdits) {\r\n    if (!doc._id) {\r\n      doc._id = exports.uuid();\r\n    }\r\n    newRevId = exports.uuid({length: 32, radix: 16}).toLowerCase();\r\n    if (doc._rev) {\r\n      revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\r\n      if (!revInfo) {\r\n        throw \"invalid value for property '_rev'\";\r\n      }\r\n      doc._rev_tree = [{\r\n        pos: parseInt(revInfo[1], 10),\r\n        ids: [revInfo[2], {status: 'missing'}, [[newRevId, opts, []]]]\r\n      }];\r\n      nRevNum = parseInt(revInfo[1], 10) + 1;\r\n    } else {\r\n      doc._rev_tree = [{\r\n        pos: 1,\r\n        ids : [newRevId, opts, []]\r\n      }];\r\n      nRevNum = 1;\r\n    }\r\n  } else {\r\n    if (doc._revisions) {\r\n      doc._rev_tree = [{\r\n        pos: doc._revisions.start - doc._revisions.ids.length + 1,\r\n        ids: doc._revisions.ids.reduce(function (acc, x) {\r\n          if (acc === null) {\r\n            return [x, opts, []];\r\n          } else {\r\n            return [x, {status: 'missing'}, [acc]];\r\n          }\r\n        }, null)\r\n      }];\r\n      nRevNum = doc._revisions.start;\r\n      newRevId = doc._revisions.ids[0];\r\n    }\r\n    if (!doc._rev_tree) {\r\n      revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\r\n      if (!revInfo) {\r\n        return errors.BAD_ARG;\r\n      }\r\n      nRevNum = parseInt(revInfo[1], 10);\r\n      newRevId = revInfo[2];\r\n      doc._rev_tree = [{\r\n        pos: parseInt(revInfo[1], 10),\r\n        ids: [revInfo[2], opts, []]\r\n      }];\r\n    }\r\n  }\r\n\r\n  error = exports.invalidIdError(doc._id);\r\n\r\n  for (var key in doc) {\r\n    if (doc.hasOwnProperty(key) && key[0] === '_' && reservedWords.indexOf(key) === -1) {\r\n      error = exports.extend({}, errors.DOC_VALIDATION);\r\n      error.reason += ': ' + key;\r\n    }\r\n  }\r\n\r\n  doc._id = decodeURIComponent(doc._id);\r\n  doc._rev = [nRevNum, newRevId].join('-');\r\n\r\n  if (error) {\r\n    return error;\r\n  }\r\n\r\n  return Object.keys(doc).reduce(function (acc, key) {\r\n    if (/^_/.test(key) && key !== '_attachments') {\r\n      acc.metadata[key.slice(1)] = doc[key];\r\n    } else {\r\n      acc.data[key] = doc[key];\r\n    }\r\n    return acc;\r\n  }, {metadata : {}, data : {}});\r\n};\r\n\r\nexports.isCordova = function () {\r\n  return (typeof cordova !== \"undefined\" ||\r\n          typeof PhoneGap !== \"undefined\" ||\r\n          typeof phonegap !== \"undefined\");\r\n};\r\n\r\nexports.hasLocalStorage = function () {\r\n  if (isChromeApp()) {\r\n    return false;\r\n  }\r\n  try {\r\n    return global.localStorage;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n};\r\nexports.Changes = function () {\r\n\r\n  var api = {};\r\n  var eventEmitter = new EventEmitter();\r\n  var isChrome = isChromeApp();\r\n  var listeners = {};\r\n  var hasLocal = false;\r\n  if (!isChrome) {\r\n    hasLocal = exports.hasLocalStorage();\r\n  }\r\n  if (isChrome) {\r\n    chrome.storage.onChanged.addListener(function (e) {\r\n      // make sure it's event addressed to us\r\n      if (e.db_name != null) {\r\n        eventEmitter.emit(e.dbName.newValue);//object only has oldValue, newValue members\r\n      }\r\n    });\r\n  } else if (hasLocal) {\r\n    if (global.addEventListener) {\r\n      global.addEventListener(\"storage\", function (e) {\r\n        eventEmitter.emit(e.key);\r\n      });\r\n    } else {\r\n      global.attachEvent(\"storage\", function (e) {\r\n        eventEmitter.emit(e.key);\r\n      });\r\n    }\r\n  }\r\n\r\n  api.addListener = function (dbName, id, db, opts) {\r\n    if (listeners[id]) {\r\n      return;\r\n    }\r\n    function eventFunction() {\r\n      db.changes({\r\n        include_docs: opts.include_docs,\r\n        conflicts: opts.conflicts,\r\n        continuous: false,\r\n        descending: false,\r\n        filter: opts.filter,\r\n        view: opts.view,\r\n        since: opts.since,\r\n        query_params: opts.query_params,\r\n        onChange: function (c) {\r\n          if (c.seq > opts.since && !opts.cancelled) {\r\n            opts.since = c.seq;\r\n            exports.call(opts.onChange, c);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    listeners[id] = eventFunction;\r\n    eventEmitter.on(dbName, eventFunction);\r\n  };\r\n\r\n  api.removeListener = function (dbName, id) {\r\n    if (!(id in listeners)) {\r\n      return;\r\n    }\r\n    eventEmitter.removeListener(dbName, listeners[id]);\r\n  };\r\n\r\n  api.clearListeners = function (dbName) {\r\n    eventEmitter.removeAllListeners(dbName);\r\n  };\r\n\r\n  api.notifyLocalWindows = function (dbName) {\r\n    //do a useless change on a storage thing\r\n    //in order to get other windows's listeners to activate\r\n    if (isChrome) {\r\n      chrome.storage.local.set({dbName: dbName});\r\n    } else if (hasLocal) {\r\n      localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\r\n    }\r\n  };\r\n\r\n  api.notify = function (dbName) {\r\n    eventEmitter.emit(dbName);\r\n  };\r\n\r\n  return api;\r\n};\r\n\r\nif (!process.browser || !('atob' in global)) {\r\n  exports.atob = function (str) {\r\n    var base64 = new buffer(str, 'base64');\r\n    // Node.js will just skip the characters it can't encode instead of\r\n    // throwing and exception\r\n    if (base64.toString('base64') !== str) {\r\n      throw (\"Cannot base64 encode full string\");\r\n    }\r\n    return base64.toString('binary');\r\n  };\r\n} else {\r\n  exports.atob = function (str) {\r\n    return atob(str);\r\n  };\r\n}\r\n\r\nif (!process.browser || !('btoa' in global)) {\r\n  exports.btoa = function (str) {\r\n    return new buffer(str, 'binary').toString('base64');\r\n  };\r\n} else {\r\n  exports.btoa = function (str) {\r\n    return btoa(str);\r\n  };\r\n}\r\n\r\n// From http://stackoverflow.com/questions/14967647/encode-decode-image-with-base64-breaks-image (2013-04-21)\r\nexports.fixBinary = function (bin) {\r\n  if (!process.browser) {\r\n    // don't need to do this in Node\r\n    return bin;\r\n  }\r\n\r\n  var length = bin.length;\r\n  var buf = new ArrayBuffer(length);\r\n  var arr = new Uint8Array(buf);\r\n  for (var i = 0; i < length; i++) {\r\n    arr[i] = bin.charCodeAt(i);\r\n  }\r\n  return buf;\r\n};\r\n\r\nexports.once = function (fun) {\r\n  var called = false;\r\n  return exports.getArguments(function (args) {\r\n    if (called) {\r\n      console.trace();\r\n      throw new Error('once called  more than once');\r\n    } else {\r\n      called = true;\r\n      fun.apply(this, args);\r\n    }\r\n  });\r\n};\r\n\r\nexports.toPromise = function (func) {\r\n  //create the function we will be returning\r\n  return exports.getArguments(function (args) {\r\n    var self = this;\r\n    var tempCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\r\n    // if the last argument is a function, assume its a callback\r\n    var usedCB;\r\n    if (tempCB) {\r\n      // if it was a callback, create a new callback which calls it,\r\n      // but do so async so we don't trap any errors\r\n      usedCB = function (err, resp) {\r\n        process.nextTick(function () {\r\n          tempCB(err, resp);\r\n        });\r\n      };\r\n    }\r\n    var promise = new Promise(function (fulfill, reject) {\r\n      try {\r\n        var callback = exports.once(function (err, mesg) {\r\n          if (err) {\r\n            reject(err);\r\n          } else {\r\n            fulfill(mesg);\r\n          }\r\n        });\r\n        // create a callback for this invocation\r\n        // apply the function in the orig context\r\n        args.push(callback);\r\n        func.apply(self, args);\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n    });\r\n    // if there is a callback, call it back\r\n    if (usedCB) {\r\n      promise.then(function (result) {\r\n        usedCB(null, result);\r\n      }, usedCB);\r\n    }\r\n    promise.cancel = function () {\r\n      return this;\r\n    };\r\n    return promise;\r\n  });\r\n};\r\n\r\nexports.adapterFun = function (name, callback) {\r\n  return exports.toPromise(exports.getArguments(function (args) {\r\n    if (!this.taskqueue.isReady) {\r\n      this.taskqueue.addTask(name, args);\r\n      return;\r\n    }\r\n    callback.apply(this, args);\r\n  }));\r\n};\r\n//Can't find original post, but this is close\r\n//http://stackoverflow.com/questions/6965107/converting-between-strings-and-arraybuffers\r\nexports.arrayBufferToBinaryString = function (buffer) {\r\n  var binary = \"\";\r\n  var bytes = new Uint8Array(buffer);\r\n  var length = bytes.byteLength;\r\n  for (var i = 0; i < length; i++) {\r\n    binary += String.fromCharCode(bytes[i]);\r\n  }\r\n  return binary;\r\n};\r\n\r\nexports.cancellableFun = function (fun, self, opts) {\r\n\r\n  opts = opts ? exports.extend(true, {}, opts) : {};\r\n  opts.complete = opts.complete || function () { };\r\n  var complete = exports.once(opts.complete);\r\n\r\n  var promise = new Promise(function (fulfill, reject) {\r\n    opts.complete = function (err, res) {\r\n      if (err) {\r\n        reject(err);\r\n      } else {\r\n        fulfill(res);\r\n      }\r\n    };\r\n  });\r\n\r\n  promise.then(function (result) {\r\n    complete(null, result);\r\n  }, complete);\r\n\r\n  // this needs to be overwridden by caller, dont fire complete until\r\n  // the task is ready\r\n  promise.cancel = function () {\r\n    promise.isCancelled = true;\r\n    if (self.taskqueue.isReady) {\r\n      opts.complete(null, {status: 'cancelled'});\r\n    }\r\n  };\r\n\r\n  if (!self.taskqueue.isReady) {\r\n    self.taskqueue.addTask(function () {\r\n      if (promise.isCancelled) {\r\n        opts.complete(null, {status: 'cancelled'});\r\n      } else {\r\n        fun(self, opts, promise);\r\n      }\r\n    });\r\n    return promise;\r\n  } else {\r\n    fun(self, opts, promise);\r\n    return promise;\r\n  }\r\n};\r\n\r\n}).call(this,_dereq_(\"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{\"./deps/ajax\":6,\"./deps/blob\":7,\"./deps/buffer\":21,\"./deps/errors\":8,\"./deps/extend\":10,\"./deps/md5.js\":11,\"./deps/uuid\":12,\"./merge\":14,\"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js\":23,\"bluebird\":28,\"events\":22,\"inherits\":24}],19:[function(_dereq_,module,exports){\r\nmodule.exports = _dereq_('../package.json').version;\r\n},{\"../package.json\":53}],20:[function(_dereq_,module,exports){\r\n\r\n},{}],21:[function(_dereq_,module,exports){\r\nmodule.exports=_dereq_(20)\r\n},{}],22:[function(_dereq_,module,exports){\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nfunction EventEmitter() {\r\n  this._events = this._events || {};\r\n  this._maxListeners = this._maxListeners || undefined;\r\n}\r\nmodule.exports = EventEmitter;\r\n\r\n// Backwards-compat with node 0.10.x\r\nEventEmitter.EventEmitter = EventEmitter;\r\n\r\nEventEmitter.prototype._events = undefined;\r\nEventEmitter.prototype._maxListeners = undefined;\r\n\r\n// By default EventEmitters will print a warning if more than 10 listeners are\r\n// added to it. This is a useful default which helps finding memory leaks.\r\nEventEmitter.defaultMaxListeners = 10;\r\n\r\n// Obviously not all Emitters should be limited to 10. This function allows\r\n// that to be increased. Set to zero for unlimited.\r\nEventEmitter.prototype.setMaxListeners = function(n) {\r\n  if (!isNumber(n) || n < 0 || isNaN(n))\r\n    throw TypeError('n must be a positive number');\r\n  this._maxListeners = n;\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.emit = function(type) {\r\n  var er, handler, len, args, i, listeners;\r\n\r\n  if (!this._events)\r\n    this._events = {};\r\n\r\n  // If there is no 'error' event listener then throw.\r\n  if (type === 'error') {\r\n    if (!this._events.error ||\r\n        (isObject(this._events.error) && !this._events.error.length)) {\r\n      er = arguments[1];\r\n      if (er instanceof Error) {\r\n        throw er; // Unhandled 'error' event\r\n      } else {\r\n        throw TypeError('Uncaught, unspecified \"error\" event.');\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n\r\n  handler = this._events[type];\r\n\r\n  if (isUndefined(handler))\r\n    return false;\r\n\r\n  if (isFunction(handler)) {\r\n    switch (arguments.length) {\r\n      // fast cases\r\n      case 1:\r\n        handler.call(this);\r\n        break;\r\n      case 2:\r\n        handler.call(this, arguments[1]);\r\n        break;\r\n      case 3:\r\n        handler.call(this, arguments[1], arguments[2]);\r\n        break;\r\n      // slower\r\n      default:\r\n        len = arguments.length;\r\n        args = new Array(len - 1);\r\n        for (i = 1; i < len; i++)\r\n          args[i - 1] = arguments[i];\r\n        handler.apply(this, args);\r\n    }\r\n  } else if (isObject(handler)) {\r\n    len = arguments.length;\r\n    args = new Array(len - 1);\r\n    for (i = 1; i < len; i++)\r\n      args[i - 1] = arguments[i];\r\n\r\n    listeners = handler.slice();\r\n    len = listeners.length;\r\n    for (i = 0; i < len; i++)\r\n      listeners[i].apply(this, args);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nEventEmitter.prototype.addListener = function(type, listener) {\r\n  var m;\r\n\r\n  if (!isFunction(listener))\r\n    throw TypeError('listener must be a function');\r\n\r\n  if (!this._events)\r\n    this._events = {};\r\n\r\n  // To avoid recursion in the case that type === \"newListener\"! Before\r\n  // adding it to the listeners, first emit \"newListener\".\r\n  if (this._events.newListener)\r\n    this.emit('newListener', type,\r\n              isFunction(listener.listener) ?\r\n              listener.listener : listener);\r\n\r\n  if (!this._events[type])\r\n    // Optimize the case of one listener. Don't need the extra array object.\r\n    this._events[type] = listener;\r\n  else if (isObject(this._events[type]))\r\n    // If we've already got an array, just append.\r\n    this._events[type].push(listener);\r\n  else\r\n    // Adding the second element, need to change to array.\r\n    this._events[type] = [this._events[type], listener];\r\n\r\n  // Check for listener leak\r\n  if (isObject(this._events[type]) && !this._events[type].warned) {\r\n    var m;\r\n    if (!isUndefined(this._maxListeners)) {\r\n      m = this._maxListeners;\r\n    } else {\r\n      m = EventEmitter.defaultMaxListeners;\r\n    }\r\n\r\n    if (m && m > 0 && this._events[type].length > m) {\r\n      this._events[type].warned = true;\r\n      console.error('(node) warning: possible EventEmitter memory ' +\r\n                    'leak detected. %d listeners added. ' +\r\n                    'Use emitter.setMaxListeners() to increase limit.',\r\n                    this._events[type].length);\r\n      console.trace();\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\r\n\r\nEventEmitter.prototype.once = function(type, listener) {\r\n  if (!isFunction(listener))\r\n    throw TypeError('listener must be a function');\r\n\r\n  var fired = false;\r\n\r\n  function g() {\r\n    this.removeListener(type, g);\r\n\r\n    if (!fired) {\r\n      fired = true;\r\n      listener.apply(this, arguments);\r\n    }\r\n  }\r\n\r\n  g.listener = listener;\r\n  this.on(type, g);\r\n\r\n  return this;\r\n};\r\n\r\n// emits a 'removeListener' event iff the listener was removed\r\nEventEmitter.prototype.removeListener = function(type, listener) {\r\n  var list, position, length, i;\r\n\r\n  if (!isFunction(listener))\r\n    throw TypeError('listener must be a function');\r\n\r\n  if (!this._events || !this._events[type])\r\n    return this;\r\n\r\n  list = this._events[type];\r\n  length = list.length;\r\n  position = -1;\r\n\r\n  if (list === listener ||\r\n      (isFunction(list.listener) && list.listener === listener)) {\r\n    delete this._events[type];\r\n    if (this._events.removeListener)\r\n      this.emit('removeListener', type, listener);\r\n\r\n  } else if (isObject(list)) {\r\n    for (i = length; i-- > 0;) {\r\n      if (list[i] === listener ||\r\n          (list[i].listener && list[i].listener === listener)) {\r\n        position = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (position < 0)\r\n      return this;\r\n\r\n    if (list.length === 1) {\r\n      list.length = 0;\r\n      delete this._events[type];\r\n    } else {\r\n      list.splice(position, 1);\r\n    }\r\n\r\n    if (this._events.removeListener)\r\n      this.emit('removeListener', type, listener);\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.removeAllListeners = function(type) {\r\n  var key, listeners;\r\n\r\n  if (!this._events)\r\n    return this;\r\n\r\n  // not listening for removeListener, no need to emit\r\n  if (!this._events.removeListener) {\r\n    if (arguments.length === 0)\r\n      this._events = {};\r\n    else if (this._events[type])\r\n      delete this._events[type];\r\n    return this;\r\n  }\r\n\r\n  // emit removeListener for all listeners on all events\r\n  if (arguments.length === 0) {\r\n    for (key in this._events) {\r\n      if (key === 'removeListener') continue;\r\n      this.removeAllListeners(key);\r\n    }\r\n    this.removeAllListeners('removeListener');\r\n    this._events = {};\r\n    return this;\r\n  }\r\n\r\n  listeners = this._events[type];\r\n\r\n  if (isFunction(listeners)) {\r\n    this.removeListener(type, listeners);\r\n  } else {\r\n    // LIFO order\r\n    while (listeners.length)\r\n      this.removeListener(type, listeners[listeners.length - 1]);\r\n  }\r\n  delete this._events[type];\r\n\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.listeners = function(type) {\r\n  var ret;\r\n  if (!this._events || !this._events[type])\r\n    ret = [];\r\n  else if (isFunction(this._events[type]))\r\n    ret = [this._events[type]];\r\n  else\r\n    ret = this._events[type].slice();\r\n  return ret;\r\n};\r\n\r\nEventEmitter.listenerCount = function(emitter, type) {\r\n  var ret;\r\n  if (!emitter._events || !emitter._events[type])\r\n    ret = 0;\r\n  else if (isFunction(emitter._events[type]))\r\n    ret = 1;\r\n  else\r\n    ret = emitter._events[type].length;\r\n  return ret;\r\n};\r\n\r\nfunction isFunction(arg) {\r\n  return typeof arg === 'function';\r\n}\r\n\r\nfunction isNumber(arg) {\r\n  return typeof arg === 'number';\r\n}\r\n\r\nfunction isObject(arg) {\r\n  return typeof arg === 'object' && arg !== null;\r\n}\r\n\r\nfunction isUndefined(arg) {\r\n  return arg === void 0;\r\n}\r\n\r\n},{}],23:[function(_dereq_,module,exports){\r\n// shim for using process in browser\r\n\r\nvar process = module.exports = {};\r\n\r\nprocess.nextTick = (function () {\r\n    var canSetImmediate = typeof window !== 'undefined'\r\n    && window.setImmediate;\r\n    var canPost = typeof window !== 'undefined'\r\n    && window.postMessage && window.addEventListener\r\n    ;\r\n\r\n    if (canSetImmediate) {\r\n        return function (f) { return window.setImmediate(f) };\r\n    }\r\n\r\n    if (canPost) {\r\n        var queue = [];\r\n        window.addEventListener('message', function (ev) {\r\n            var source = ev.source;\r\n            if ((source === window || source === null) && ev.data === 'process-tick') {\r\n                ev.stopPropagation();\r\n                if (queue.length > 0) {\r\n                    var fn = queue.shift();\r\n                    fn();\r\n                }\r\n            }\r\n        }, true);\r\n\r\n        return function nextTick(fn) {\r\n            queue.push(fn);\r\n            window.postMessage('process-tick', '*');\r\n        };\r\n    }\r\n\r\n    return function nextTick(fn) {\r\n        setTimeout(fn, 0);\r\n    };\r\n})();\r\n\r\nprocess.title = 'browser';\r\nprocess.browser = true;\r\nprocess.env = {};\r\nprocess.argv = [];\r\n\r\nprocess.binding = function (name) {\r\n    throw new Error('process.binding is not supported');\r\n}\r\n\r\n// TODO(shtylman)\r\nprocess.cwd = function () { return '/' };\r\nprocess.chdir = function (dir) {\r\n    throw new Error('process.chdir is not supported');\r\n};\r\n\r\n},{}],24:[function(_dereq_,module,exports){\r\nif (typeof Object.create === 'function') {\r\n  // implementation from standard node.js 'util' module\r\n  module.exports = function inherits(ctor, superCtor) {\r\n    ctor.super_ = superCtor\r\n    ctor.prototype = Object.create(superCtor.prototype, {\r\n      constructor: {\r\n        value: ctor,\r\n        enumerable: false,\r\n        writable: true,\r\n        configurable: true\r\n      }\r\n    });\r\n  };\r\n} else {\r\n  // old school shim for old browsers\r\n  module.exports = function inherits(ctor, superCtor) {\r\n    ctor.super_ = superCtor\r\n    var TempCtor = function () {}\r\n    TempCtor.prototype = superCtor.prototype\r\n    ctor.prototype = new TempCtor()\r\n    ctor.prototype.constructor = ctor\r\n  }\r\n}\r\n\r\n},{}],25:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nmodule.exports = INTERNAL;\r\n\r\nfunction INTERNAL() {}\r\n},{}],26:[function(_dereq_,module,exports){\r\n'use strict';\r\nvar INTERNAL = _dereq_('./INTERNAL');\r\nvar Promise = _dereq_('./promise');\r\nvar reject = _dereq_('./reject');\r\nvar resolve = _dereq_('./resolve');\r\n\r\nmodule.exports = function all(iterable) {\r\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\r\n    return reject(new TypeError('must be an array'));\r\n  }\r\n  var len = iterable.length;\r\n  if (!len) {\r\n    return resolve([]);\r\n  }\r\n  var values = [];\r\n  var resolved = 0;\r\n  var i = -1;\r\n  var promise = new Promise(INTERNAL);\r\n  function allResolver(value, i) {\r\n    resolve(value).then(function (outValue) {\r\n      values[i] = outValue;\r\n      if (++resolved === len) {\r\n        promise.resolve(values);\r\n      }\r\n    }, function (error) {\r\n      promise.reject(error);\r\n    });\r\n  }\r\n\r\n  while (++i < len) {\r\n    allResolver(iterable[i], i);\r\n  }\r\n  return promise;\r\n};\r\n},{\"./INTERNAL\":25,\"./promise\":30,\"./reject\":31,\"./resolve\":32}],27:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nmodule.exports = getThen;\r\n\r\nfunction getThen(obj) {\r\n  // Make sure we only access the accessor once as required by the spec\r\n  var then = obj && obj.then;\r\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\r\n    return function appyThen() {\r\n      then.apply(obj, arguments);\r\n    };\r\n  }\r\n}\r\n},{}],28:[function(_dereq_,module,exports){\r\nmodule.exports = exports = _dereq_('./promise');\r\n\r\nexports.resolve = _dereq_('./resolve');\r\nexports.reject = _dereq_('./reject');\r\nexports.all = _dereq_('./all');\r\n},{\"./all\":26,\"./promise\":30,\"./reject\":31,\"./resolve\":32}],29:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nmodule.exports = once;\r\n\r\n/* Wrap an arbitrary number of functions and allow only one of them to be\r\n   executed and only once */\r\nfunction once() {\r\n  var called = 0;\r\n  return function wrapper(wrappedFunction) {\r\n    return function () {\r\n      if (called++) {\r\n        return;\r\n      }\r\n      wrappedFunction.apply(this, arguments);\r\n    };\r\n  };\r\n}\r\n},{}],30:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nvar unwrap = _dereq_('./unwrap');\r\nvar INTERNAL = _dereq_('./INTERNAL');\r\nvar once = _dereq_('./once');\r\nvar tryCatch = _dereq_('./tryCatch');\r\nvar getThen = _dereq_('./getThen');\r\n\r\n// Lazy man's symbols for states\r\nvar PENDING = ['PENDING'],\r\n  FULFILLED = ['FULFILLED'],\r\n  REJECTED = ['REJECTED'];\r\nmodule.exports = Promise;\r\nfunction Promise(resolver) {\r\n  if (!(this instanceof Promise)) {\r\n    return new Promise(resolver);\r\n  }\r\n  if (typeof resolver !== 'function') {\r\n    throw new TypeError('reslover must be a function');\r\n  }\r\n  this.state = PENDING;\r\n  this.queue = [];\r\n  if (resolver !== INTERNAL) {\r\n    safelyResolveThenable(this, resolver);\r\n  }\r\n}\r\nPromise.prototype.resolve = function (value) {\r\n  var result = tryCatch(getThen, value);\r\n  if (result.status === 'error') {\r\n    return this.reject(result.value);\r\n  }\r\n  var thenable = result.value;\r\n\r\n  if (thenable) {\r\n    safelyResolveThenable(this, thenable);\r\n  } else {\r\n    this.state = FULFILLED;\r\n    this.outcome = value;\r\n    var i = -1;\r\n    var len = this.queue.length;\r\n    while (++i < len) {\r\n      this.queue[i].callFulfilled(value);\r\n    }\r\n  }\r\n  return this;\r\n};\r\nPromise.prototype.reject = function (error) {\r\n  this.state = REJECTED;\r\n  this.outcome = error;\r\n  var i = -1;\r\n  var len = this.queue.length;\r\n  while (++i < len) {\r\n    this.queue[i].callRejected(error);\r\n  }\r\n  return this;\r\n};\r\n\r\nPromise.prototype['catch'] = function (onRejected) {\r\n  return this.then(null, onRejected);\r\n};\r\nPromise.prototype.then = function (onFulfilled, onRejected) {\r\n  var onFulfilledFunc = typeof onFulfilled === 'function';\r\n  var onRejectedFunc = typeof onRejected === 'function';\r\n  if (!onFulfilledFunc && this.state === FULFILLED || !onRejected && this.state === REJECTED) {\r\n    return this;\r\n  }\r\n  var promise = new Promise(INTERNAL);\r\n\r\n  var thenHandler =  {\r\n    promise: promise,\r\n  };\r\n  if (this.state !== REJECTED) {\r\n    if (onFulfilledFunc) {\r\n      thenHandler.callFulfilled = function (value) {\r\n        unwrap(promise, onFulfilled, value);\r\n      };\r\n    } else {\r\n      thenHandler.callFulfilled = function (value) {\r\n        promise.resolve(value);\r\n      };\r\n    }\r\n  }\r\n  if (this.state !== FULFILLED) {\r\n    if (onRejectedFunc) {\r\n      thenHandler.callRejected = function (value) {\r\n        unwrap(promise, onRejected, value);\r\n      };\r\n    } else {\r\n      thenHandler.callRejected = function (value) {\r\n        promise.reject(value);\r\n      };\r\n    }\r\n  }\r\n  if (this.state === FULFILLED) {\r\n    thenHandler.callFulfilled(this.outcome);\r\n  } else if (this.state === REJECTED) {\r\n    thenHandler.callRejected(this.outcome);\r\n  } else {\r\n    this.queue.push(thenHandler);\r\n  }\r\n\r\n  return promise;\r\n};\r\nfunction safelyResolveThenable(self, thenable) {\r\n  // Either fulfill, reject or reject with error\r\n  var onceWrapper = once();\r\n  var onError = onceWrapper(function (value) {\r\n    return self.reject(value);\r\n  });\r\n  var result = tryCatch(function () {\r\n    thenable(\r\n      onceWrapper(function (value) {\r\n        return self.resolve(value);\r\n      }),\r\n      onError\r\n    );\r\n  });\r\n  if (result.status === 'error') {\r\n    onError(result.value);\r\n  }\r\n}\r\n},{\"./INTERNAL\":25,\"./getThen\":27,\"./once\":29,\"./tryCatch\":33,\"./unwrap\":34}],31:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nvar Promise = _dereq_('./promise');\r\nvar INTERNAL = _dereq_('./INTERNAL');\r\n\r\nmodule.exports = reject;\r\n\r\nfunction reject(reason) {\r\n\tvar promise = new Promise(INTERNAL);\r\n\treturn promise.reject(reason);\r\n}\r\n},{\"./INTERNAL\":25,\"./promise\":30}],32:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nvar Promise = _dereq_('./promise');\r\nvar INTERNAL = _dereq_('./INTERNAL');\r\n\r\nmodule.exports = resolve;\r\n\r\nvar FALSE = new Promise(INTERNAL).resolve(false);\r\nvar NULL = new Promise(INTERNAL).resolve(null);\r\nvar UNDEFINED = new Promise(INTERNAL).resolve(void 0);\r\nvar ZERO = new Promise(INTERNAL).resolve(0);\r\nvar EMPTYSTRING = new Promise(INTERNAL).resolve('');\r\n\r\nfunction resolve(value) {\r\n  if (value) {\r\n    return new Promise(INTERNAL).resolve(value);\r\n  }\r\n  var valueType = typeof value;\r\n  switch (valueType) {\r\n    case 'boolean':\r\n      return FALSE;\r\n    case 'undefined':\r\n      return UNDEFINED;\r\n    case 'object':\r\n      return NULL;\r\n    case 'number':\r\n      return ZERO;\r\n    case 'string':\r\n      return EMPTYSTRING;\r\n  }\r\n}\r\n},{\"./INTERNAL\":25,\"./promise\":30}],33:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nmodule.exports = tryCatch;\r\n\r\nfunction tryCatch(func, value) {\r\n  var out = {};\r\n  try {\r\n    out.value = func(value);\r\n    out.status = 'success';\r\n  } catch (e) {\r\n    out.status = 'error';\r\n    out.value = e;\r\n  }\r\n  return out;\r\n}\r\n},{}],34:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nvar immediate = _dereq_('immediate');\r\n\r\nmodule.exports = unwrap;\r\n\r\nfunction unwrap(promise, func, value) {\r\n  immediate(function () {\r\n    var returnValue;\r\n    try {\r\n      returnValue = func(value);\r\n    } catch (e) {\r\n      return promise.reject(e);\r\n    }\r\n    if (returnValue === promise) {\r\n      promise.reject(new TypeError('Cannot resolve promise with itself'));\r\n    } else {\r\n      promise.resolve(returnValue);\r\n    }\r\n  });\r\n}\r\n},{\"immediate\":36}],35:[function(_dereq_,module,exports){\r\n\"use strict\";\r\nexports.test = function () {\r\n    return false;\r\n};\r\n},{}],36:[function(_dereq_,module,exports){\r\n\"use strict\";\r\nvar types = [\r\n    _dereq_(\"./nextTick\"),\r\n    _dereq_(\"./mutation\"),\r\n    _dereq_(\"./postMessage\"),\r\n    _dereq_(\"./messageChannel\"),\r\n    _dereq_(\"./stateChange\"),\r\n    _dereq_(\"./timeout\")\r\n];\r\nvar handlerQueue = [];\r\nfunction drainQueue() {\r\n    var i = 0,\r\n        task,\r\n        innerQueue = handlerQueue;\r\n\thandlerQueue = [];\r\n\t/*jslint boss: true */\r\n\twhile (task = innerQueue[i++]) {\r\n\t\ttask();\r\n\t}\r\n}\r\nvar nextTick;\r\nvar i = -1;\r\nvar len = types.length;\r\nwhile (++ i < len) {\r\n    if (types[i].test()) {\r\n        nextTick = types[i].install(drainQueue);\r\n        break;\r\n    }\r\n}\r\nmodule.exports = function (task) {\r\n    var len, i, args;\r\n    var nTask = task;\r\n    if (arguments.length > 1 && typeof task === \"function\") {\r\n        args = new Array(arguments.length - 1);\r\n        i = 0;\r\n        while (++i < arguments.length) {\r\n            args[i - 1] = arguments[i];\r\n        }\r\n        nTask = function () {\r\n            task.apply(undefined, args);\r\n        };\r\n    }\r\n    if ((len = handlerQueue.push(nTask)) === 1) {\r\n        nextTick(drainQueue);\r\n    }\r\n    return len;\r\n};\r\nmodule.exports.clear = function (n) {\r\n    if (n <= handlerQueue.length) {\r\n        handlerQueue[n - 1] = function () {};\r\n    }\r\n    return this;\r\n};\r\n\r\n},{\"./messageChannel\":37,\"./mutation\":38,\"./nextTick\":35,\"./postMessage\":39,\"./stateChange\":40,\"./timeout\":41}],37:[function(_dereq_,module,exports){\r\n(function (global){\r\n\"use strict\";\r\n\r\nexports.test = function () {\r\n    return typeof global.MessageChannel !== \"undefined\";\r\n};\r\n\r\nexports.install = function (func) {\r\n    var channel = new global.MessageChannel();\r\n    channel.port1.onmessage = func;\r\n    return function () {\r\n        channel.port2.postMessage(0);\r\n    };\r\n};\r\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{}],38:[function(_dereq_,module,exports){\r\n(function (global){\r\n\"use strict\";\r\n//based off rsvp\r\n//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/async.js\r\n\r\nvar MutationObserver = global.MutationObserver || global.WebKitMutationObserver;\r\n\r\nexports.test = function () {\r\n    return MutationObserver;\r\n};\r\n\r\nexports.install = function (handle) {\r\n    var observer = new MutationObserver(handle);\r\n    var element = global.document.createElement(\"div\");\r\n    observer.observe(element, { attributes: true });\r\n\r\n    // Chrome Memory Leak: https://bugs.webkit.org/show_bug.cgi?id=93661\r\n    global.addEventListener(\"unload\", function () {\r\n        observer.disconnect();\r\n        observer = null;\r\n    }, false);\r\n    return function () {\r\n        element.setAttribute(\"drainQueue\", \"drainQueue\");\r\n    };\r\n};\r\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{}],39:[function(_dereq_,module,exports){\r\n(function (global){\r\n\"use strict\";\r\nexports.test = function () {\r\n    // The test against `importScripts` prevents this implementation from being installed inside a web worker,\r\n    // where `global.postMessage` means something completely different and can\"t be used for this purpose.\r\n\r\n    if (!global.postMessage || global.importScripts) {\r\n        return false;\r\n    }\r\n\r\n    var postMessageIsAsynchronous = true;\r\n    var oldOnMessage = global.onmessage;\r\n    global.onmessage = function () {\r\n        postMessageIsAsynchronous = false;\r\n    };\r\n    global.postMessage(\"\", \"*\");\r\n    global.onmessage = oldOnMessage;\r\n\r\n    return postMessageIsAsynchronous;\r\n};\r\n\r\nexports.install = function (func) {\r\n    var codeWord = \"com.calvinmetcalf.setImmediate\" + Math.random();\r\n    function globalMessage(event) {\r\n        if (event.source === global && event.data === codeWord) {\r\n            func();\r\n        }\r\n    }\r\n    if (global.addEventListener) {\r\n        global.addEventListener(\"message\", globalMessage, false);\r\n    } else {\r\n        global.attachEvent(\"onmessage\", globalMessage);\r\n    }\r\n    return function () {\r\n        global.postMessage(codeWord, \"*\");\r\n    };\r\n};\r\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{}],40:[function(_dereq_,module,exports){\r\n(function (global){\r\n\"use strict\";\r\n\r\nexports.test = function () {\r\n    return \"document\" in global && \"onreadystatechange\" in global.document.createElement(\"script\");\r\n};\r\n\r\nexports.install = function (handle) {\r\n    return function () {\r\n\r\n        // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\r\n        // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\r\n        var scriptEl = global.document.createElement(\"script\");\r\n        scriptEl.onreadystatechange = function () {\r\n            handle();\r\n\r\n            scriptEl.onreadystatechange = null;\r\n            scriptEl.parentNode.removeChild(scriptEl);\r\n            scriptEl = null;\r\n        };\r\n        global.document.documentElement.appendChild(scriptEl);\r\n\r\n        return handle;\r\n    };\r\n};\r\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{}],41:[function(_dereq_,module,exports){\r\n\"use strict\";\r\nexports.test = function () {\r\n    return true;\r\n};\r\n\r\nexports.install = function (t) {\r\n    return function () {\r\n        setTimeout(t, 0);\r\n    };\r\n};\r\n},{}],42:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nmodule.exports = function (func, emit, sum, log, isArray, toJSON) {\r\n  /*jshint evil: true */\r\n  return eval(\"'use strict'; (\" + func + \");\");\r\n};\r\n\r\n},{}],43:[function(_dereq_,module,exports){\r\n(function (process,global){\r\n'use strict';\r\n\r\nvar pouchCollate = _dereq_('pouchdb-collate');\r\nvar Promise = typeof global.Promise === 'function' ? global.Promise : _dereq_('lie');\r\nvar collate = pouchCollate.collate;\r\nvar evalFunc = _dereq_('./evalfunc');\r\nvar log = (typeof console !== 'undefined') ?\r\n  Function.prototype.bind.call(console.log, console) : function () {};\r\nvar processKey = function (key) {\r\n  // Stringify keys since we want them as map keys (see #35)\r\n  return JSON.stringify(pouchCollate.normalizeKey(key));\r\n};\r\n// This is the first implementation of a basic plugin, we register the\r\n// plugin object with pouch and it is mixin'd to each database created\r\n// (regardless of adapter), adapters can override plugins by providing\r\n// their own implementation. functions on the plugin object that start\r\n// with _ are reserved function that are called by pouchdb for special\r\n// notifications.\r\n\r\n// If we wanted to store incremental views we can do it here by listening\r\n// to the changes feed (keeping track of our last update_seq between page loads)\r\n// and storing the result of the map function (possibly using the upcoming\r\n// extracted adapter functions)\r\n\r\n\r\nfunction createKeysLookup(keys) {\r\n  // creates a lookup map for the given keys, so that doing\r\n  // query() with keys doesn't become an O(n * m) operation\r\n  // lookup values are typically integer indexes, but may\r\n  // map to a list of integers, since keys can be duplicated\r\n  var lookup = {};\r\n\r\n  for (var i = 0, len = keys.length; i < len; i++) {\r\n    var key = processKey(keys[i]);\r\n    var val = lookup[key];\r\n    if (typeof val === 'undefined') {\r\n      lookup[key] = i;\r\n    } else if (typeof val === 'number') {\r\n      lookup[key] = [val, i];\r\n    } else { // array\r\n      val.push(i);\r\n    }\r\n  }\r\n\r\n  return lookup;\r\n}\r\n\r\nfunction sortByIdAndValue(a, b) {\r\n  // sort by id, then value\r\n  var idCompare = collate(a.id, b.id);\r\n  return idCompare !== 0 ? idCompare : collate(a.value, b.value);\r\n}\r\nfunction addAtIndex(idx, result, prelimResults) {\r\n  var val = prelimResults[idx];\r\n  if (typeof val === 'undefined') {\r\n    prelimResults[idx] = result;\r\n  } else if (!Array.isArray(val)) {\r\n    // same key for multiple docs, need to preserve document order, so create array\r\n    prelimResults[idx] = [val, result];\r\n  } else { // existing array\r\n    val.push(result);\r\n  }\r\n}\r\n\r\nfunction sum(values) {\r\n  return values.reduce(function (a, b) {\r\n    return a + b;\r\n  }, 0);\r\n}\r\n\r\nvar builtInReduce = {\r\n  \"_sum\": function (keys, values) {\r\n    return sum(values);\r\n  },\r\n\r\n  \"_count\": function (keys, values, rereduce) {\r\n    return values.length;\r\n  },\r\n\r\n  \"_stats\": function (keys, values) {\r\n    return {\r\n      'sum': sum(values),\r\n      'min': Math.min.apply(null, values),\r\n      'max': Math.max.apply(null, values),\r\n      'count': values.length,\r\n      'sumsqr': (function () {\r\n        var _sumsqr = 0;\r\n        var error;\r\n        for (var idx in values) {\r\n          if (typeof values[idx] === 'number') {\r\n            _sumsqr += values[idx] * values[idx];\r\n          } else {\r\n            error =  new Error('builtin _stats function requires map values to be numbers');\r\n            error.name = 'invalid_value';\r\n            error.status = 500;\r\n            return error;\r\n          }\r\n        }\r\n        return _sumsqr;\r\n      })()\r\n    };\r\n  }\r\n};\r\n\r\nfunction addHttpParam(paramName, opts, params, asJson) {\r\n  // add an http param from opts to params, optionally json-encoded\r\n  var val = opts[paramName];\r\n  if (typeof val !== 'undefined') {\r\n    if (asJson) {\r\n      val = encodeURIComponent(JSON.stringify(val));\r\n    }\r\n    params.push(paramName + '=' + val);\r\n  }\r\n}\r\n\r\nfunction mapUsingKeys(inputResults, keys, keysLookup) {\r\n  // create a new results array from the given array,\r\n  // ensuring that the following conditions are respected:\r\n  // 1. docs are ordered by key, then doc id\r\n  // 2. docs can appear >1 time in the list, if their key is specified >1 time\r\n  // 3. keys can be unknown, in which case there's just a hole in the returned array\r\n\r\n  var prelimResults = new Array(keys.length);\r\n\r\n  inputResults.forEach(function (result) {\r\n    var idx = keysLookup[processKey(result.key)];\r\n    if (typeof idx === 'number') {\r\n      addAtIndex(idx, result, prelimResults);\r\n    } else { // array of indices\r\n      idx.forEach(function (subIdx) {\r\n        addAtIndex(subIdx, result, prelimResults);\r\n      });\r\n    }\r\n  });\r\n\r\n  // flatten the array, remove nulls, sort by doc ids\r\n  var outputResults = [];\r\n  prelimResults.forEach(function (result) {\r\n    if (Array.isArray(result)) {\r\n      outputResults = outputResults.concat(result.sort(sortByIdAndValue));\r\n    } else { // single result\r\n      outputResults.push(result);\r\n    }\r\n  });\r\n\r\n  return outputResults;\r\n}\r\n\r\nfunction viewQuery(db, fun, options) {\r\n  var origMap;\r\n  if (!options.skip) {\r\n    options.skip = 0;\r\n  }\r\n\r\n  if (!fun.reduce) {\r\n    options.reduce = false;\r\n  }\r\n\r\n  var results = [];\r\n  var current;\r\n  var num_started = 0;\r\n  var completed = false;\r\n  var keysLookup;\r\n\r\n  function emit(key, val) {\r\n    var viewRow = {\r\n      id: current.doc._id,\r\n      key: key,\r\n      value: val\r\n    };\r\n\r\n    if (typeof options.startkey !== 'undefined' && collate(key, options.startkey) < 0) {\r\n      return;\r\n    }\r\n    if (typeof options.endkey !== 'undefined' && collate(key, options.endkey) > 0) {\r\n      return;\r\n    }\r\n    if (typeof options.key !== 'undefined' && collate(key, options.key) !== 0) {\r\n      return;\r\n    }\r\n    if (typeof options.keys !== 'undefined') {\r\n      keysLookup = keysLookup || createKeysLookup(options.keys);\r\n      if (typeof keysLookup[processKey(key)] === 'undefined') {\r\n        return;\r\n      }\r\n    }\r\n\r\n    num_started++;\r\n    if (options.include_docs) {\r\n      //in this special case, join on _id (issue #106)\r\n      if (val && typeof val === 'object' && val._id) {\r\n        db.get(val._id,\r\n          function (_, joined_doc) {\r\n            if (joined_doc) {\r\n              viewRow.doc = joined_doc;\r\n            }\r\n            results.push(viewRow);\r\n            checkComplete();\r\n          });\r\n        return;\r\n      } else {\r\n        viewRow.doc = current.doc;\r\n      }\r\n    }\r\n    results.push(viewRow);\r\n  }\r\n  if (typeof fun.map === \"function\" && fun.map.length === 2) {\r\n    //save a reference to it\r\n    origMap = fun.map;\r\n    fun.map = function (doc) {\r\n      //call it with the emit as the second argument\r\n      return origMap(doc, emit);\r\n    };\r\n  } else {\r\n    // ugly way to make sure references to 'emit' in map/reduce bind to the\r\n    // above emit\r\n    fun.map = evalFunc(fun.map.toString(), emit, sum, log, Array.isArray, JSON.parse);\r\n  }\r\n  if (fun.reduce) {\r\n    if (builtInReduce[fun.reduce]) {\r\n      fun.reduce = builtInReduce[fun.reduce];\r\n    } else {\r\n      fun.reduce = evalFunc(fun.reduce.toString(), emit, sum, log, Array.isArray, JSON.parse);\r\n    }\r\n  }\r\n\r\n  //only proceed once all documents are mapped and joined\r\n  function checkComplete() {\r\n    var error;\r\n    if (completed && results.length === num_started) {\r\n\r\n      if (typeof options.keys !== 'undefined' && results.length) {\r\n        // user supplied a keys param, sort by keys\r\n        results = mapUsingKeys(results, options.keys, keysLookup);\r\n      } else { // normal sorting\r\n        results.sort(function (a, b) {\r\n          // sort by key, then id\r\n          var keyCollate = collate(a.key, b.key);\r\n          return keyCollate !== 0 ? keyCollate : collate(a.id, b.id);\r\n        });\r\n      }\r\n      if (options.descending) {\r\n        results.reverse();\r\n      }\r\n      if (options.reduce === false) {\r\n        return options.complete(null, {\r\n          total_rows: results.length,\r\n          offset: options.skip,\r\n          rows: ('limit' in options) ? results.slice(options.skip, options.limit + options.skip) :\r\n            (options.skip > 0) ? results.slice(options.skip) : results\r\n        });\r\n      }\r\n\r\n      var groups = [];\r\n      results.forEach(function (e) {\r\n        var last = groups[groups.length - 1];\r\n        if (last && collate(last.key[0][0], e.key) === 0) {\r\n          last.key.push([e.key, e.id]);\r\n          last.value.push(e.value);\r\n          return;\r\n        }\r\n        groups.push({key: [\r\n          [e.key, e.id]\r\n        ], value: [e.value]});\r\n      });\r\n      groups.forEach(function (e) {\r\n        e.value = fun.reduce.call(null, e.key, e.value);\r\n        if (e.value.sumsqr && e.value.sumsqr instanceof Error) {\r\n          error = e.value;\r\n          return;\r\n        }\r\n        e.key = e.key[0][0];\r\n      });\r\n      if (error) {\r\n        options.complete(error);\r\n        return;\r\n      }\r\n      options.complete(null, {\r\n        total_rows: groups.length,\r\n        offset: options.skip,\r\n        rows: ('limit' in options) ? groups.slice(options.skip, options.limit + options.skip) :\r\n          (options.skip > 0) ? groups.slice(options.skip) : groups\r\n      });\r\n    }\r\n  }\r\n\r\n  db.changes({\r\n    conflicts: true,\r\n    include_docs: true,\r\n    onChange: function (doc) {\r\n      if (!('deleted' in doc) && doc.id[0] !== \"_\") {\r\n        current = {doc: doc.doc};\r\n        fun.map.call(null, doc.doc);\r\n      }\r\n    },\r\n    complete: function () {\r\n      completed = true;\r\n      checkComplete();\r\n    }\r\n  });\r\n}\r\n\r\nfunction httpQuery(db, fun, opts) {\r\n  var callback = opts.complete;\r\n\r\n  // List of parameters to add to the PUT request\r\n  var params = [];\r\n  var body;\r\n  var method = 'GET';\r\n\r\n  // If opts.reduce exists and is defined, then add it to the list\r\n  // of parameters.\r\n  // If reduce=false then the results are that of only the map function\r\n  // not the final result of map and reduce.\r\n  addHttpParam('reduce', opts, params);\r\n  addHttpParam('include_docs', opts, params);\r\n  addHttpParam('limit', opts, params);\r\n  addHttpParam('descending', opts, params);\r\n  addHttpParam('group', opts, params);\r\n  addHttpParam('group_level', opts, params);\r\n  addHttpParam('skip', opts, params);\r\n  addHttpParam('startkey', opts, params, true);\r\n  addHttpParam('endkey', opts, params, true);\r\n  addHttpParam('key', opts, params, true);\r\n\r\n  // If keys are supplied, issue a POST request to circumvent GET query string limits\r\n  // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\r\n  if (typeof opts.keys !== 'undefined') {\r\n    method = 'POST';\r\n    if (typeof fun === 'string') {\r\n      body = JSON.stringify({keys: opts.keys});\r\n    } else { // fun is {map : mapfun}, so append to this\r\n      fun.keys = opts.keys;\r\n    }\r\n  }\r\n\r\n  // Format the list of parameters into a valid URI query string\r\n  params = params.join('&');\r\n  params = params === '' ? '' : '?' + params;\r\n\r\n  // We are referencing a query defined in the design doc\r\n  if (typeof fun === 'string') {\r\n    var parts = fun.split('/');\r\n    db.request({\r\n      method: method,\r\n      url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\r\n      body: body\r\n    }, callback);\r\n    return;\r\n  }\r\n\r\n  // We are using a temporary view, terrible for performance but good for testing\r\n  var queryObject = JSON.parse(JSON.stringify(fun, function (key, val) {\r\n    if (typeof val === 'function') {\r\n      return val + ''; // implicitly `toString` it\r\n    }\r\n    return val;\r\n  }));\r\n\r\n  db.request({\r\n    method: 'POST',\r\n    url: '_temp_view' + params,\r\n    body: queryObject\r\n  }, callback);\r\n}\r\n\r\nexports.query = function (fun, opts, callback) {\r\n  var db = this;\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  opts = opts || {};\r\n  if (callback) {\r\n    opts.complete = callback;\r\n  }\r\n  var tempCB = opts.complete;\r\n  var realCB;\r\n  if (opts.complete) {\r\n    realCB = function (err, resp) {\r\n      process.nextTick(function () {\r\n        tempCB(err, resp);\r\n      });\r\n    };\r\n  }\r\n  var promise = new Promise(function (resolve, reject) {\r\n    opts.complete = function (err, data) {\r\n      if (err) {\r\n        reject(err);\r\n      } else {\r\n        resolve(data);\r\n      }\r\n    };\r\n\r\n    if (db.type() === 'http') {\r\n      if (typeof fun === 'function') {\r\n        return httpQuery(db, {map: fun}, opts);\r\n      }\r\n      return httpQuery(db, fun, opts);\r\n    }\r\n\r\n    if (typeof fun === 'object') {\r\n      return viewQuery(db, fun, opts);\r\n    }\r\n\r\n    if (typeof fun === 'function') {\r\n      return viewQuery(db, {map: fun}, opts);\r\n    }\r\n\r\n    var parts = fun.split('/');\r\n    db.get('_design/' + parts[0], function (err, doc) {\r\n      if (err) {\r\n        opts.complete(err);\r\n        return;\r\n      }\r\n\r\n      if (!doc.views[parts[1]]) {\r\n        opts.complete({ name: 'not_found', message: 'missing_named_view' });\r\n        return;\r\n      }\r\n      viewQuery(db, {\r\n        map: doc.views[parts[1]].map,\r\n        reduce: doc.views[parts[1]].reduce\r\n      }, opts);\r\n    });\r\n  });\r\n  if (realCB) {\r\n    promise.then(function (resp) {\r\n      realCB(null, resp);\r\n    }, realCB);\r\n  }\r\n  return promise;\r\n};\r\n\r\n}).call(this,_dereq_(\"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{\"./evalfunc\":42,\"/Users/daleharvey/src/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js\":23,\"lie\":44,\"pouchdb-collate\":52}],44:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nvar immediate = _dereq_('immediate');\r\nvar isDefineProp = false;\r\n// prevents deoptimization\r\n(function(){\r\n    try {\r\n        Object.defineProperty({}, 'test', {value:true});\r\n        isDefineProp = true;\r\n    }catch(e){}\r\n}());\r\nfunction defineNonEnum(obj, name, value){\r\n    if(isDefineProp){\r\n         Object.defineProperty(obj, name, {\r\n            value: value,\r\n            configurable: true,\r\n            writable: true\r\n        });\r\n    }else{\r\n        obj[name] = value;\r\n    }\r\n}\r\nfunction Promise(resolver) {\r\n\r\n     if (!(this instanceof Promise)) {\r\n        return new Promise(resolver);\r\n    }\r\n\r\n    defineNonEnum(this, 'successQueue', []);\r\n    defineNonEnum(this, 'failureQueue', []);\r\n    defineNonEnum(this, 'resolved', false);\r\n\r\n\r\n    if(typeof resolver === 'function'){\r\n        this.resolvePassed(resolver);\r\n    }\r\n}\r\ndefineNonEnum(Promise.prototype, 'resolvePassed', function(resolver){\r\n    try{\r\n        resolver(this.fulfillUnwrap.bind(this),this.reject.bind(this));\r\n    }catch(e){\r\n        this.reject(e);\r\n    }\r\n});\r\ndefineNonEnum(Promise.prototype, 'reject', function(reason){\r\n    this.resolve(false,reason);\r\n});\r\ndefineNonEnum(Promise.prototype, 'fulfill', function(value){\r\n    this.resolve(true,value);\r\n});\r\ndefineNonEnum(Promise.prototype, 'fulfillUnwrap', function(value){\r\n    unwrap(this.fulfill.bind(this), this.reject.bind(this), value);\r\n});\r\nPromise.prototype.then = function(onFulfilled, onRejected) {\r\n    if(this.resolved){\r\n        return this.resolved(onFulfilled, onRejected);\r\n    } else {\r\n        return this.pending(onFulfilled, onRejected);\r\n    }\r\n};\r\n(function(){\r\n    try {\r\n        Promise.prototype['catch'] = function(onRejected) {\r\n            return this.then(null, onRejected);\r\n        };\r\n    } catch(e){}\r\n}());\r\ndefineNonEnum(Promise.prototype, 'pending', function(onFulfilled, onRejected){\r\n    var self = this;\r\n    return new Promise(function(success,failure){\r\n        if(typeof onFulfilled === 'function'){\r\n            self.successQueue.push({\r\n                resolve: success,\r\n                reject: failure,\r\n                callback:onFulfilled\r\n            });\r\n        }else{\r\n            self.successQueue.push({\r\n                next: success,\r\n                callback:false\r\n            });\r\n        }\r\n\r\n        if(typeof onRejected === 'function'){\r\n            self.failureQueue.push({\r\n                resolve: success,\r\n                reject: failure,\r\n                callback:onRejected\r\n            });\r\n        }else{\r\n            self.failureQueue.push({\r\n                next: failure,\r\n                callback:false\r\n            });\r\n        }\r\n    });\r\n});\r\ndefineNonEnum(Promise.prototype, 'resolve', function (success, value){\r\n\r\n    if(this.resolved){\r\n        return;\r\n    }\r\n\r\n    this.resolved = createResolved(this, value, success?0:1);\r\n\r\n    var queue = success ? this.successQueue : this.failureQueue;\r\n    var len = queue.length;\r\n    var i = -1;\r\n    while(++i < len) {\r\n\r\n        if (queue[i].callback) {\r\n            immediate(execute,queue[i].callback, value, queue[i].resolve, queue[i].reject);\r\n        }else {\r\n            queue[i].next(value);\r\n        }\r\n    }\r\n});\r\n\r\nfunction unwrap(fulfill, reject, value){\r\n    if(value && typeof value.then==='function'){\r\n        value.then(fulfill,reject);\r\n    }else{\r\n        fulfill(value);\r\n    }\r\n}\r\n\r\nfunction createResolved(scope, value, whichArg) {\r\n    function resolved() {\r\n        var callback = arguments[whichArg];\r\n        if (typeof callback !== 'function') {\r\n            return scope;\r\n        }else{\r\n            return new Promise(function(resolve,reject){\r\n                immediate(execute,callback,value,resolve,reject);\r\n            });\r\n        }\r\n    }\r\n    return resolved;\r\n}\r\n\r\nfunction execute(callback, value, resolve, reject) {\r\n    try {\r\n        unwrap(resolve,reject,callback(value));\r\n    } catch (error) {\r\n        reject(error);\r\n    }\r\n}\r\n\r\n\r\n\r\nmodule.exports = Promise;\r\n\r\n},{\"immediate\":46}],45:[function(_dereq_,module,exports){\r\nmodule.exports=_dereq_(35)\r\n},{}],46:[function(_dereq_,module,exports){\r\nmodule.exports=_dereq_(36)\r\n},{\"./messageChannel\":47,\"./mutation\":48,\"./nextTick\":45,\"./postMessage\":49,\"./stateChange\":50,\"./timeout\":51}],47:[function(_dereq_,module,exports){\r\nmodule.exports=_dereq_(37)\r\n},{}],48:[function(_dereq_,module,exports){\r\nmodule.exports=_dereq_(38)\r\n},{}],49:[function(_dereq_,module,exports){\r\nmodule.exports=_dereq_(39)\r\n},{}],50:[function(_dereq_,module,exports){\r\nmodule.exports=_dereq_(40)\r\n},{}],51:[function(_dereq_,module,exports){\r\nmodule.exports=_dereq_(41)\r\n},{}],52:[function(_dereq_,module,exports){\r\n'use strict';\r\n\r\nexports.collate = function (a, b) {\r\n  a = exports.normalizeKey(a);\r\n  b = exports.normalizeKey(b);\r\n  var ai = collationIndex(a);\r\n  var bi = collationIndex(b);\r\n  if ((ai - bi) !== 0) {\r\n    return ai - bi;\r\n  }\r\n  if (a === null) {\r\n    return 0;\r\n  }\r\n  if (typeof a === 'number') {\r\n    return a - b;\r\n  }\r\n  if (typeof a === 'boolean') {\r\n    return a === b ? 0 : (a < b ? -1 : 1);\r\n  }\r\n  if (typeof a === 'string') {\r\n    return stringCollate(a, b);\r\n  }\r\n  if (Array.isArray(a)) {\r\n    return arrayCollate(a, b);\r\n  }\r\n  if (typeof a === 'object') {\r\n    return objectCollate(a, b);\r\n  }\r\n}\r\n\r\n// couch considers null/NaN/Infinity/-Infinity === undefined,\r\n// for the purposes of mapreduce indexes. also, dates get stringified.\r\nexports.normalizeKey = function (key) {\r\n  if (typeof key === 'undefined') {\r\n    return null;\r\n  } else if (typeof key === 'number') {\r\n    if (key === Infinity || key === -Infinity || isNaN(key)) {\r\n      return null;\r\n    }\r\n  } else if (key instanceof Date) {\r\n    return key.toJSON();\r\n  }\r\n  return key;\r\n}\r\n\r\nfunction arrayCollate(a, b) {\r\n  var len = Math.min(a.length, b.length);\r\n  for (var i = 0; i < len; i++) {\r\n    var sort = exports.collate(a[i], b[i]);\r\n    if (sort !== 0) {\r\n      return sort;\r\n    }\r\n  }\r\n  return (a.length === b.length) ? 0 :\r\n    (a.length > b.length) ? 1 : -1;\r\n}\r\nfunction stringCollate(a, b) {\r\n  // See: https://github.com/daleharvey/pouchdb/issues/40\r\n  // This is incompatible with the CouchDB implementation, but its the\r\n  // best we can do for now\r\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\r\n}\r\nfunction objectCollate(a, b) {\r\n  var ak = Object.keys(a), bk = Object.keys(b);\r\n  var len = Math.min(ak.length, bk.length);\r\n  for (var i = 0; i < len; i++) {\r\n    // First sort the keys\r\n    var sort = exports.collate(ak[i], bk[i]);\r\n    if (sort !== 0) {\r\n      return sort;\r\n    }\r\n    // if the keys are equal sort the values\r\n    sort = exports.collate(a[ak[i]], b[bk[i]]);\r\n    if (sort !== 0) {\r\n      return sort;\r\n    }\r\n\r\n  }\r\n  return (ak.length === bk.length) ? 0 :\r\n    (ak.length > bk.length) ? 1 : -1;\r\n}\r\n// The collation is defined by erlangs ordered terms\r\n// the atoms null, true, false come first, then numbers, strings,\r\n// arrays, then objects\r\n// null/undefined/NaN/Infinity/-Infinity are all considered null\r\nfunction collationIndex(x) {\r\n  var id = ['boolean', 'number', 'string', 'object'];\r\n  if (id.indexOf(typeof x) !== -1) {\r\n    if (x === null) {\r\n      return 1;\r\n    }\r\n    return id.indexOf(typeof x) + 2;\r\n  }\r\n  if (Array.isArray(x)) {\r\n    return 4.5;\r\n  }\r\n}\r\n\r\n},{}],53:[function(_dereq_,module,exports){\r\nmodule.exports={\r\n  \"name\": \"pouchdb\",\r\n  \"version\": \"2.1.0\",\r\n  \"description\": \"PouchDB is a pocket-sized database.\",\r\n  \"release\": \"nightly\",\r\n  \"main\": \"./lib/index.js\",\r\n  \"homepage\": \"https://github.com/daleharvey/pouchdb\",\r\n  \"repository\": \"https://github.com/daleharvey/pouchdb\",\r\n  \"keywords\": [\r\n    \"db\",\r\n    \"couchdb\",\r\n    \"pouchdb\"\r\n  ],\r\n  \"tags\": [\r\n    \"db\",\r\n    \"couchdb\",\r\n    \"pouchdb\"\r\n  ],\r\n  \"dependencies\": {\r\n    \"bluebird\": \"~1.0.0\",\r\n    \"inherits\": \"~2.0.1\",\r\n    \"level-js\": \"~2.0.0\",\r\n    \"level-sublevel\": \"~5.2.0\",\r\n    \"leveldown\": \"~0.10.2\",\r\n    \"levelup\": \"~0.18.2\",\r\n    \"lie\": \"^2.6.0\",\r\n    \"pouchdb-mapreduce\": \"1.0.0\",\r\n    \"request\": \"~2.28.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"commander\": \"~2.1.0\",\r\n    \"watchify\": \"~0.4.1\",\r\n    \"uglify-js\": \"~2.4.6\",\r\n    \"jshint\": \"~2.3.0\",\r\n    \"http-proxy\": \"~0.10.3\",\r\n    \"corsproxy\": \"~0.2.13\",\r\n    \"http-server\": \"~0.5.5\",\r\n    \"browserify\": \"~3.24.13\",\r\n    \"wd\": \"~0.2.8\",\r\n    \"tin\": \"~0.4.0\",\r\n    \"mocha\": \"~1.17.1\",\r\n    \"chai\": \"~1.9.0\",\r\n    \"istanbul\": \"~0.2.4\",\r\n    \"ncp\": \"~0.5.0\",\r\n    \"sauce-connect-launcher\": \"0.2.2\",\r\n    \"less\": \"~1.7.0\",\r\n    \"bower\": \"~1.2.8\"\r\n  },\r\n  \"scripts\": {\r\n    \"jshint\": \"jshint -c .jshintrc bin/ lib/ tests/*.js\",\r\n    \"build-js\": \"./bin/build-js.sh\",\r\n    \"build\": \"mkdir -p dist && npm run build-js\",\r\n    \"test-node\": \"./bin/run-mocha.sh\",\r\n    \"test-browser\": \"mkdir -p dist && npm run build-js && ./bin/test-browser.js\",\r\n    \"dev\": \"./bin/dev-server.js\",\r\n    \"test\": \"npm run jshint && ./bin/run-test.sh\",\r\n    \"publish\": \"./bin/publish.sh\",\r\n    \"publish-site\": \"./bin/publish-site.sh\",\r\n    \"build-site\": \"./bin/build-site.sh\",\r\n    \"shell\": \"./bin/repl.js\",\r\n    \"report-coverage\": \"./bin/run-coverage.js\"\r\n  },\r\n  \"browser\": {\r\n    \"./deps/buffer\": false,\r\n    \"request\": false,\r\n    \"leveldown\": \"level-js\",\r\n    \"bluebird\": \"lie\"\r\n  }\r\n}\r\n},{}]},{},[13])\r\n(13)\r\n});"]}